<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.coley48.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言2022.02.28 是我从上家公司离职的日子，心中虽还有些许不舍，但更多的还是轻松和惬意。虽然对自己的技术还是比较自信，但是面对即将踏上新的征程，不得不承认的是在生理上自己还是有些焦虑，导致晚上经常失眠，脑海中一遍遍想象着即将到来的面试场景； 在家复习了整整三周，然后又看了三天面试题，基本上都是 997；本文主要记录在家复习 JavaScript 基础所做的相应笔记；对应项目地址：https">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 学习笔记">
<meta property="og:url" content="http://blog.coley48.cn/2022/03/01/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Coley&#39;s Blog">
<meta property="og:description" content="前言2022.02.28 是我从上家公司离职的日子，心中虽还有些许不舍，但更多的还是轻松和惬意。虽然对自己的技术还是比较自信，但是面对即将踏上新的征程，不得不承认的是在生理上自己还是有些焦虑，导致晚上经常失眠，脑海中一遍遍想象着即将到来的面试场景； 在家复习了整整三周，然后又看了三天面试题，基本上都是 997；本文主要记录在家复习 JavaScript 基础所做的相应笔记；对应项目地址：https">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-01T17:51:16.000Z">
<meta property="article:modified_time" content="2022-05-11T01:25:52.552Z">
<meta property="article:author" content="Coley Brooks">
<meta property="article:tag" content="notes">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.coley48.cn/2022/03/01/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 学习笔记 | Coley's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Coley's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">君之所向，一往无前。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-意见">

    <a href="/reform/" rel="section"><i class="fa fa-calendar fa-fw"></i>意见</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Coley48" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.coley48.cn/2022/03/01/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="Coley Brooks">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coley's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-01 17:51:16" itemprop="dateCreated datePublished" datetime="2022-03-01T17:51:16+00:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-11 01:25:52" itemprop="dateModified" datetime="2022-05-11T01:25:52+00:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">notes</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>152k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4:36</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2022.02.28 是我从上家公司离职的日子，心中虽还有些许不舍，但更多的还是轻松和惬意。虽然对自己的技术还是比较自信，但是面对即将踏上新的征程，不得不承认的是在生理上自己还是有些焦虑，导致晚上经常失眠，脑海中一遍遍想象着即将到来的面试场景；</p>
<p>在家复习了整整三周，然后又看了三天面试题，基本上都是 997；本文主要记录在家复习 JavaScript 基础所做的相应笔记；对应项目地址：<a target="_blank" rel="noopener" href="https://github.com/Coley48/javascript">https://github.com/Coley48/javascript</a></p>
<span id="more"></span>

<h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><ol>
<li>安装 webpack</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack webpack-dev-server webpack-cli</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 webpack</li>
</ol>
<p>在根目录下添加<code>webpack.dev.js</code>和<code>webpack.prod.js</code></p>
<p><code>webpack.dev.js</code>用于开发环境，<code>webpack.prod.js</code>用于生产环境；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产环境中使用 babel-loader；</span></span><br><span class="line">npm i -D @babel/core @babel/preset-env babel-loader</span><br><span class="line">npm i -D @babel/plugin-transform-runtime <span class="comment"># async/await</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据需要安装其他 loader 和 plugin；</span></span><br><span class="line">npm i -D style-loader css-loader html-webpack-plugin</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/html-webpack-plugin">html-webpack-plugin</a></li>
</ul>
<ol start="3">
<li>配置 babel</li>
</ol>
<blockquote>
<p><code>Babel</code> 是一个 JavaScript 编译器，主要用于将采用 <code>ECMAScript 2015+</code> 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中；</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.babeljs.cn/setup#installation">babel配置教程</a></li>
</ul>
<ol start="4">
<li>最后在 <code>package.json</code> 中添加运行脚本</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;serve&quot;: &quot;webpack server --config webpack.dev.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h3><p><strong>什么是 JavaScript ？</strong></p>
<blockquote>
<p>JavaScript 最初被创建的目的是“使网页更生动”；这种编程语言写出来的程序被称为脚本，它们可以被直接写在网页的 <code>HTML</code> 中，在页面加载的时候自动执行；脚本被以纯文本的形式提供和执行，它们不需要特殊的准备或编译即可运行；</p>
</blockquote>
<p>JavaScript 引擎工作基本原理：引擎解析脚本，然后将脚本编译转化为机器语言，最后执行机器语言；</p>
<p><strong>浏览器中的 JavaScript 限制</strong></p>
<p>为了用户的（信息）安全，在浏览器中的 JavaScript 的能力是受限的，目的是防止恶意网页获取用户私人信息或损害用户数据；网页中的 JavaScript 不能读、写、复制和执行硬盘上的任意文件，不同的标签页/窗口之间通常互不了解；</p>
<p><strong>JavaScript 手册</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">JavaScript MDN 中文参考手册</a></li>
<li><a target="_blank" rel="noopener" href="https://caniuse.com/">JavaScript 兼容性表</a><!-- 
#### script 标签</li>
</ul>
<p>应该尽量将较复杂的脚本存放在单独的文件中，使用独立文件的好处是浏览器会下载它，然后将它保存到浏览器的缓存中；之后，其他页面想要相同的脚本就会从缓存中获取，所以文件实际上只会下载一次，这可以节省流量，并使得页面（加载）更快；</p>
<blockquote>
<p>Note: 如果设置了 <code>src</code> 特性，<code>script</code> 标签内容将会被忽略；</p>
</blockquote>
<p>JavaScript 代码以分号结尾，注意添加完整分号，以下代码会报错；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read properties of undefined (reading &#x27;2&#x27;)</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].forEach(alert);</span><br><span class="line"><span class="string">``</span><span class="string">` --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 变量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 必须仅包含字母，数字，符号 $ 和 _；</span></span><br><span class="line"><span class="string">2. 首字符必须非数字；</span></span><br><span class="line"><span class="string">3. 通常使用驼峰命名规则；</span></span><br><span class="line"><span class="string">4. 对大小写敏感；</span></span><br><span class="line"><span class="string">5. 不能使用[保留字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#%E5%85%B3%E9%94%AE%E5%AD%97)命名；</span></span><br><span class="line"><span class="string">6. 允许非英文字母，但不推荐；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 数据类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在 JavaScript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）；JavaScript，被称为“动态类型”（dynamically typed）的编程语言，意思是虽然编程语言中有不同的数据类型，但是你定义的变量并不会在定义后，被限制为某一数据类型；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Number 用于任何类型的数字：整数或浮点数，在 ±(2^53-1) 范围内的整数；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// Infinity 代表数学概念中的 无穷大 ∞；是一个比任何数字都大的特殊值；</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> / <span class="number">0</span> === <span class="literal">Infinity</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN 代表一个计算错误；它是一个不正确的或者一个未定义的数学操作所得到的结果；</span></span><br><span class="line"><span class="comment">// 任何对 NaN 的进一步数学运算都会返回 NaN，且 NaN 不等于任何值，包括自己；</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span> / <span class="number">2</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>BigInt 用于任意长度的整数；</li>
</ul>
<p>Number 类型无法表示大于 (253-1)（即 9007199254740991），或小于 -(253-1) 的整数；目前 IE 还未支持该类型；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾部的 &quot;n&quot; 表示这是一个 BigInt 类型</span></span><br><span class="line"><span class="keyword">const</span> bigInt = <span class="number">1234567890123456789012345678901234567890n</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>String 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型；</li>
</ul>
<p>双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别；反引号是功能扩展引号，它们允许我们通过将变量和表达式包装在 ${…} 中，来将它们嵌入到字符串中；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;Single quotes are ok too&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> phrase = <span class="string">`can embed another <span class="subst">$&#123;str&#125;</span>`</span>; <span class="comment">// 模板字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Boolean 用于 true 和 false；表示逻辑类型；</li>
<li>null 用于未知的值，只有一个 null 值的独立类型；</li>
<li>undefined 用于未定义的值，只有一个 undefined 值的独立类型，代表未被赋值；</li>
</ul>
<blockquote>
<p>Note: 不建议显示地将 <code>undefined</code> 赋值给变量，通常，使用 <code>null</code> 将一个“空”或者“未知”的值写入变量中，而 <code>undefined</code> 则保留作为未进行初始化的事物的默认初始值；</p>
</blockquote>
<blockquote>
<p>Tips: <code>void</code> 并不改变表达式的结果，只是让表达式不返回值；因此可以用 <code>void 0</code> 来获得 <code>undefined</code>；</p>
</blockquote>
<ul>
<li>Symbol 用于唯一的标识符；</li>
<li>Object 用于更复杂的数据结构；</li>
</ul>
<p>当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，可以使用 typeof 运算符返回参数的类型；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是官方承认的 typeof 的错误，这个问题来自于 JavaScript 语言的早期阶段，并为了兼容性而保留了下来；</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 JavaScript 语言中没有一个特别的 “function” 类型，函数隶属于 object 类型，但是 typeof 会对函数区分对待，并返回 &quot;function&quot;；</span></span><br><span class="line"><span class="keyword">typeof</span> alert <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul>
<li>字符串转换：转换发生在输出内容的时候，也可以通过 String(value) 进行显式转换；</li>
<li>数字型转换：转换发生在进行算术操作时，也可以通过 Number(value) 进行显式转换；</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">转换</th>
</tr>
</thead>
<tbody><tr>
<td align="left">undefined</td>
<td align="left">NaN</td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">true / false</td>
<td align="left">1 / 0</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">忽略字符串两端的空白，按原样读取，空字符串变成 0，转换出错则输出 NaN</td>
</tr>
</tbody></table>
<ul>
<li>布尔型转换：转换发生在进行逻辑操作时，也可以通过 Boolean(value) 进行显式转换；</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">转换</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0, null, undefined, NaN, “”</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">其他值</td>
<td align="left">true</td>
</tr>
</tbody></table>
<h4 id="基础运算符，数学"><a href="#基础运算符，数学" class="headerlink" title="基础运算符，数学"></a>基础运算符，数学</h4><p><strong>赋值运算符</strong></p>
<p>赋值语句 x = value 将值 value 写入 x 然后返回 x；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span> - (a = b + <span class="number">1</span>); <span class="comment">// a: 3, c: 0 慎用！</span></span><br></pre></td></tr></table></figure>

<p>链式赋值从右到左进行计算，但可读性不高；</p>
<p><strong>自增 / 自减</strong></p>
<p>++, –，又分为前置形式和后置形式，前置形式返回一个新的值，但后置返回原来的值（做加法/减法之前的值）；</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">JavaScript 运算符优先级表</a></p>
<h4 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h4><p>在比较字符串的大小时，JavaScript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定，换言之，字符串是按字符（母）逐个进行比较的；</p>
<p>字符串的比较算法：</p>
<ol>
<li>首先比较两个字符串的首位字符大小；</li>
<li>如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串，算法结束；</li>
<li>否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较；</li>
<li>重复上述步骤进行比较，直到比较完成某字符串的所有字符为止；</li>
<li>如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="string">&#x27;Z&#x27;</span> &gt; <span class="string">&#x27;A&#x27;</span> ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="string">&#x27;Glow&#x27;</span> &gt; <span class="string">&#x27;Glee&#x27;</span> ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="string">&#x27;Bee&#x27;</span> &gt; <span class="string">&#x27;Be&#x27;</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当使用严格等于 === 时，不相等，因为它们属于不同的类型；</span></span><br><span class="line">alert( <span class="literal">null</span> === <span class="literal">undefined</span> ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当使用非严格等于 == 时，相等，仅仅等于对方而不等于其他任何的值；</span></span><br><span class="line">alert( <span class="literal">null</span> == <span class="literal">undefined</span> ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当使用数学式或其他比较方法 &lt; &gt; &lt;= &gt;= 时，null/undefined 会被转化为数字：null 被转化为 0，undefined 被转化为 NaN；</span></span><br><span class="line">alert( <span class="literal">null</span> &gt; <span class="literal">undefined</span> ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等性检查 == 和普通比较符 &gt; &lt; &gt;= &lt;= 的代码逻辑是相互独立的</span></span><br><span class="line">alert( <span class="literal">null</span> &gt; <span class="number">0</span> );  <span class="comment">// false</span></span><br><span class="line">alert( <span class="literal">null</span> == <span class="number">0</span> ); <span class="comment">// false</span></span><br><span class="line">alert( <span class="literal">null</span> &gt;= <span class="number">0</span> ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 和 null 在相等性检查 == 中不会进行任何的类型转换；</span></span><br><span class="line"><span class="comment">// 它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值</span></span><br><span class="line">alert( <span class="literal">undefined</span> &gt; <span class="number">0</span> ); <span class="comment">// false</span></span><br><span class="line">alert( <span class="literal">undefined</span> &lt; <span class="number">0</span> ); <span class="comment">// false</span></span><br><span class="line">alert( <span class="literal">undefined</span> == <span class="number">0</span> ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="逻辑运算符-if-和"><a href="#逻辑运算符-if-和" class="headerlink" title="逻辑运算符 if 和 ?:"></a>逻辑运算符 if 和 ?:</h4><ul>
<li>或运算符 || 返回的值是操作数的初始形式，不会做布尔转换；</li>
</ul>
<p>执行过程：</p>
<ol>
<li>从左到右依次计算操作数；</li>
<li>将每一个操作数转化为布尔值；若结果为 true，则返回该操作数的初始值；</li>
<li>如果所有的操作数都被计算过（转换结果都是 false），则返回最后一个操作数；</li>
</ol>
<p>常见用法：</p>
<ol>
<li>获取变量列表或者表达式中的第一个真值；</li>
<li>短路求值（Short-circuit evaluation）；</li>
</ol>
<ul>
<li>与运算符 &amp;&amp; 返回的值是第一个假值的初始形式；</li>
<li>非运算符 ! 返回操作数的取反布尔值；</li>
</ul>
<blockquote>
<p>Tips: 两个非运算 <code>!!</code> 有时候用来将某个值转化为布尔类型：</p>
</blockquote>
<h4 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符 ??"></a>空值合并运算符 ??</h4><p><code>a ?? b</code> 表示如果第一个参数不是 null/undefined，则 ?? 返回第一个参数，否则，返回第二个参数；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ?? 等价写法：</span></span><br><span class="line">result = (a !== <span class="literal">null</span> &amp;&amp; a !== <span class="literal">undefined</span>) ? a : b;</span><br></pre></td></tr></table></figure>

<p>与 || 比较：</p>
<ul>
<li>|| 返回第一个真值；</li>
<li>?? 返回第一个已定义的值；</li>
<li>优先级相同；</li>
</ul>
<p>出于安全原因，JavaScript 禁止将 ?? 运算符与 &amp;&amp; 和 || 运算符一起使用，除非使用括号明确指定了优先级；</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>跳出多层循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> input = prompt(<span class="string">`Value at coords (<span class="subst">$&#123;i&#125;</span>,<span class="subst">$&#123;j&#125;</span>)`</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 如果是空字符串或被取消，则中断并跳出这两个循环</span></span><br><span class="line">      <span class="keyword">if</span> (!input) <span class="keyword">break</span> outer; <span class="comment">// (*)</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 用得到的值做些事……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: <code>break</code> 指令必须在代码块内，从技术上讲，任何被标记的代码块都有效；</p>
</blockquote>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在 JavaScript 中，函数是一种特殊的值，函数定义有函数声明和函数表达式两种；二者差别主要在，函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用；而函数声明则不同，在函数声明被定义之前，它就可以被调用；</p>
<p>函数就是行为（action），所以它们的名字通常是动词，它应该简短且尽可能准确地描述函数的作用，这样读代码的人就能清楚地知道这个函数的功能；一种普遍的做法是用动词前缀来开始一个函数，这个前缀模糊地描述了这个行为；</p>
<p>空值的 return 或没有 return 的函数返回值为 undefined；</p>
<p>一个函数应该只包含函数名所指定的功能，而不是做更多与函数名无关的功能；两个独立的行为通常需要两个函数，即使它们通常被一起调用；在这种情况下，我们可以创建第三个函数来调用这两个函数；</p>
<h4 id="在浏览器中调试"><a href="#在浏览器中调试" class="headerlink" title="在浏览器中调试"></a>在浏览器中调试</h4><blockquote>
<p>Tips: 在控制台中要插入多行代码，按 <code>Shift+Enter</code> 来进行换行；</p>
</blockquote>
<ul>
<li>“下一步（Step）”：运行下一条指令，快捷键 F9；</li>
<li>“跨步（Step over）”：运行下一条指令，但 不会进入到一个函数中，快捷键 F10；</li>
<li>“步入（Step into）”，快捷键 F11；</li>
<li>“步出（Step out）”：继续执行到当前函数的末尾，快捷键 Shift+F11；</li>
</ul>
<blockquote>
<p>Tips: 在代码中的某一行上右键，在显示的关联菜单中点击一个非常有用的名为 <code>Continue to here</code> 的选项；</p>
</blockquote>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li>需要注释：</li>
</ul>
<ol>
<li>整体架构，高层次的观点；</li>
<li>函数的用法；</li>
<li>重要又不是很明显的解决方案；</li>
</ol>
<ul>
<li>避免注释：</li>
</ul>
<ol>
<li>描述“代码如何工作”和“代码做了什么”；</li>
<li>已经足够简单或有很好自描述性的代码；</li>
</ol>
<h4 id="忍者代码"><a href="#忍者代码" class="headerlink" title="忍者代码"></a>忍者代码</h4><ol>
<li>不要为了简洁而降低代码可读性；</li>
<li>不用一个字母的变量和单词缩写；</li>
<li>不用无意义的变量名；</li>
<li>避免同义词命名变量或函数；</li>
<li>不在函数或循环中替换变量值；</li>
<li>不在变量名前添加下划线；</li>
<li>避免使用和外部变量同名的变量名；</li>
<li>除了主要任务之外，避免给函数添加一个其他行为；</li>
<li>避免返回非标准结果的函数；</li>
<li>避免将多个功能合并在一个函数中；</li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>前端测试主要分为 3 种：单元测试（Unit Test）、集成测试（Integration Test）、UI 测试（UI Test）；</p>
<ul>
<li>单元测试是最容易实现的：代码中多个组件共用的工具类库、多个组件共用的子组件等；</li>
<li>集成测试通常被应用在：耦合度较高的函数/组件、经过二次封装的函数/组件、多个函数/组件组合而成的函数/组件等；</li>
<li>UI 测试只是对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的；</li>
</ul>
<p>适合引入自动化测试的场景：</p>
<ul>
<li>公共库类的开发维护；</li>
<li>中长期项目的迭代/重构；</li>
<li>引用了不可控的第三方依赖；</li>
</ul>
<p>当通过手动重新运行来测试代码时，很容易漏掉一些东西；自动化测试意味着测试是独立于代码的；它们以各种方式运行我们的函数，并将结果与预期结果进行比较；</p>
<p>BDD（行为驱动开发）规范先行，实现在后，包含了三部分内容：测试、文档和示例；</p>
<p>安装单元测试库 Jest：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D jest</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904194600599560">试试前端自动化测试！（基础篇）</a></li>
<li><a target="_blank" rel="noopener" href="https://jestjs.io/zh-Hans/">Jest 测试框架中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://alexjover.com/blog/write-the-first-vue-js-component-unit-test-in-jest/">Vue.js Jest 单元测试</a></li>
</ul>
<h4 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h4><p><strong>对象属性</strong></p>
<blockquote>
<p>Tips: 对象属性可以用 <code>delete</code> 操作符移除；</p>
</blockquote>
<p>属性名可以是任何字符串或者 symbol，包括使用保留字；包含空格，以数字开头，或包含特殊字符（除 $ 和 _ 以外）的属性名需要加引号；</p>
<p><strong>计算属性</strong></p>
<p>在对象字面量中使用方括号定义动态属性名，括号中可以使用变量或更复杂的表达式；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = prompt(<span class="string">&quot;Which fruit to buy?&quot;</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bag = &#123;</span><br><span class="line">  [fruit]: <span class="number">5</span>, <span class="comment">// 属性名是从 fruit 变量中得到的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( bag.apple ); <span class="comment">// 5 如果 fruit=&quot;apple&quot;</span></span><br></pre></td></tr></table></figure>


<p><strong>in 操作符</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">alert( <span class="string">&quot;age&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="string">&quot;blabla&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>遍历对象：for(let key in obj) 循环；</p>
<blockquote>
<p>Tips: 对象中，整数属性会被进行排序，其他属性则按照创建的顺序显示；整数属性指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串；</p>
</blockquote>
<h4 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h4><blockquote>
<p>Tips: 赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址”；换句话说就是对该对象的“引用”；</p>
</blockquote>
<blockquote>
<p>Tips: JavaScript 变量复制，原始类型可类比为“搬家”，对象类型类比为“配钥匙”；</p>
</blockquote>
<p>使用 <code>Object.assign(dest, [src1, src2, src3...])</code> 方法拷贝对象；</p>
<ul>
<li>第一个参数 dest 是指目标对象；</li>
<li>一个或多个源对象 src1, …, srcN；</li>
<li>该方法将所有源对象的属性拷贝到目标对象 dest 中；</li>
<li>调用结果返回 dest；</li>
<li>如果被拷贝的属性的属性名已经存在，则会被覆盖；</li>
</ul>
<p>或使用 Spread 语法拷贝对象；<code>clone = &#123; ...user &#125;</code></p>
<p>当对象中存在有其他对象的引用时，可以使用递归循环深拷贝，也可以直接使用 Lodash 定义好的方法 <a target="_blank" rel="noopener" href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span> || object === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> copy = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(object, key)) &#123;</span><br><span class="line">      copy[key] = cloneDeep(object[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>JavaScript 中主要的内存管理概念是可达性（Reachability），及存储在内存中并以某种方式可访问或可用的值；</p>
<p>固有的可达值的基本集合，也成为根（roots），包括：</p>
<ol>
<li>当前执行的函数，它的局部变量和参数；</li>
<li>当前嵌套调用链上的其他函数、它们的局部变量和参数；</li>
<li>全局变量；</li>
<li>还有一些内部的根；</li>
</ol>
<p>如果一个值可以通过引用或引用链从根访问任何其他值，则认为该值是可达的；</p>
<p>垃圾回收的基本算法被称为 “mark-and-sweep”，即标记清除；现代浏览器均使用此机制，老浏览器使用引用计数机制；标记算法类似于广度优先遍历；</p>
<p>优化建议：</p>
<ul>
<li><p>分代收集（Generational collection）：对象被分成两组：“新的”和“旧的”；许多对象出现，完成它们的工作并很快死去，它们可以很快被清理；那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少；</p>
</li>
<li><p>增量收集（Incremental collection）：如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟，所以引擎试图将垃圾收集工作分成几部分来做；然后将这几部分会逐一进行处理，这需要它们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟；</p>
</li>
<li><p>闲时收集（Idle-time collection）：垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响；</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2017/04/memory-leak.html">JavaScript 内存泄漏教程</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.wolai.com/mary/qwwq3geBqBcXs2cygGY3Lx">内存泄漏（memory leak）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qappleh/article/details/80337630">JavaScript 内存泄露的4种方式及如何避免</a></p>
</li>
</ul>
<h4 id="对象方法，this"><a href="#对象方法，this" class="headerlink" title="对象方法，this"></a>对象方法，this</h4><p>JavaScript 中的 this 可以用于任何函数，即使它不是对象的方法；this 的值是在代码运行时计算出来的，它取决于代码上下文；</p>
<p>在普通函数中的 this，严格模式下的值为 undefined，非严格模式的情况下，this 将会是全局对象（浏览器为 window）；箭头函数没有自己的 this，其 this 值取决于外部“正常的”函数；</p>
<h4 id="构造器和操作符-new"><a href="#构造器和操作符-new" class="headerlink" title="构造器和操作符 new"></a>构造器和操作符 new</h4><p>从技术上讲，构造函数也是一个常规函数；但一般以大写字母开头并只用 new 操作符执行；当一个函数被使用 new 操作符执行时，它按照以下步骤：</p>
<ol>
<li>一个新的空对象被创建并分配给 this；</li>
<li>函数体执行，通常它会修改 this，为其添加新的属性；</li>
<li>返回 this 的值；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;;（隐式创建）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加属性到 this</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.isAdmin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return this;（隐式返回）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 创建单个复杂对象的代码，可以将它们封装在一个立即调用的构造函数中 <code>new function() &#123; … &#125;</code>；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个函数并立即使用 new 调用它</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.isAdmin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数定义</span></span><br><span class="line">  <span class="built_in">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert( <span class="string">&quot;My name is: &quot;</span> + <span class="built_in">this</span>.name );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于用户创建的其他代码</span></span><br><span class="line">  <span class="comment">// 也许是复杂的逻辑和语句、局部变量等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在一个函数内部，我们可以使用 <code>new.target</code> 属性来检查它是否被使用 <code>new</code> 进行调用了；对于常规调用，它为 <code>undefined</code>，对于使用 <code>new</code> 的调用，则等于该函数；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">new</span>.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User(); <span class="comment">// function User &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式重定向构造器模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123; <span class="comment">// 没有通过 new 运行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(name); <span class="comment">// 添加 new</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = User(<span class="string">&quot;John&quot;</span>); <span class="comment">// 将调用重定向</span></span><br><span class="line">alert(john.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>通常，构造器没有 return 语句；它们的任务是将所有必要的东西写入 this，并自动转换为结果；</p>
<p>当构造器中有 return，若返回值为一个对象，则会返回该对象并覆盖默认的 this；若返回值为原始类型或为空时，则会被忽略，仍然返回默认的 this；</p>
<blockquote>
<p>Tips: 如果没有参数，我们可以省略 <code>new</code> 后的括号；</p>
</blockquote>
<h4 id="可选链"><a href="#可选链" class="headerlink" title="可选链 ?."></a>可选链 ?.</h4><p>如果可选链 ?. 前面的值为 undefined 或者 null，它会停止运算并返回 undefined；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选链</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user?.name?.first);</span><br><span class="line">user.admin?.();</span><br><span class="line">user?.[<span class="string">&quot;key&quot;</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>?.</code> 前的变量必须已声明，且只将 <code>?.</code> 使用在一些东西可以不存在的地方，不要过度使用可选链；</p>
</blockquote>
<p>可选链 ?. 不是一个运算符，而是一个特殊的语法结构；它还可以与函数和方括号一起使用；</p>
<ol>
<li>?.() 用于调用一个可能不存在的函数；</li>
<li>?.[] 用于访问一个可能不存在的属性；</li>
</ol>
<blockquote>
<p>Tips: 删除一个可能不存在的属性，<code>delete user?.name</code>；可以使用 ?. 来安全地读取或删除，但不能写入；</p>
</blockquote>
<h4 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h4><p>规范中，对象的属性键只能是字符串类型或者 Symbol 类型，Symbol 值表示唯一的标识符；</p>
<p>使用 Symbol() 来创建这种类型的值，创建时可以给 Symbol 一个描述（也称为 Symbol 名），这在代码调试时非常有用；可以通过 symbol.description 属性获取 Symbol 的描述；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id 是 symbol 的一个实例化对象</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// id 是描述为 &quot;id&quot; 的 Symbol</span></span><br><span class="line"><span class="keyword">let</span> id2 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id2.description) <span class="comment">// id</span></span><br></pre></td></tr></table></figure>

<p>Symbol 保证是唯一的；即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同；描述只是一个标签，不影响任何东西；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(id1 == id2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>Symbol</code> 不会被自动转换为字符串；只能手动调用 <code>toString()</code>；</p>
</blockquote>
<ul>
<li>“隐藏”属性</li>
</ul>
<p>Symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">user[id] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 在对象字面量中使用 <code>Symbol</code>，需要使用方括号；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;Coley&quot;</span>,</span><br><span class="line">  [id]: <span class="number">12</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Symbol 属性不参与 for..in 循环，Object.keys(user) 也会忽略 Symbol；这是一般“隐藏符号属性”原则的一部分；但 Object.assign 会同时复制字符串和 symbol 属性；</p>
<p>从技术上讲，内建方法 Object.getOwnPropertySymbols(obj) 允许我们获取所有的 Symbol；还有一个 Reflect.ownKeys(obj) 方法可以返回一个对象的所有键，包括 Symbol；</p>
<p><strong>全局 symbol</strong></p>
<p>调用 Symbol.for(key) 方法创建或查询，该方法会先检查全局注册表，如果有一个描述为 key 的 Symbol，则返回该 Symbol，否则将创建一个新 Symbol，并通过给定的 key 将其存储在全局注册表中；</p>
<p>或者调用 Symbol.keyFor(sym) 方法，通过全局 Symbol 返回一个名字；如果查找的 Symbol 不是全局的则会返回 undefined；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从全局注册表中读取</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>); <span class="comment">// 如果该 Symbol 不存在，则创建它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次读取（可能是在代码中的另一个位置）</span></span><br><span class="line"><span class="keyword">let</span> idAgain = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同的 Symbol</span></span><br><span class="line">alert( id === idAgain ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(id); <span class="comment">// id</span></span><br></pre></td></tr></table></figure>

<p>除此之外，JavaScript 内部还有许多系统 Symbol，可以用来微调对象的各个方面，以此改变一些内建行为，这些 Symbol 被列在了 <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-well-known-symbols">Symbol 表</a> 的规范中；</p>
<h4 id="对象——原始值转换"><a href="#对象——原始值转换" class="headerlink" title="对象——原始值转换"></a>对象——原始值转换</h4><p>JavaScript 不允许自定义运算符对对象的处理方式；因此在对对象进行运算时，对象会被自动转换为原始值，并会得到一个原始值的结果；</p>
<p>所有的对象在布尔上下文（context）中均为 true，因此对于对象，不存在 boolean 转换；</p>
<ul>
<li>“string” hint</li>
</ul>
<p>对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 “alert”；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line">alert(obj); <span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象作为属性键</span></span><br><span class="line">anotherObj[obj] = <span class="number">123</span>; <span class="comment">// &#123;[object Object]: 123&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>“number” hint</li>
</ul>
<p>对象到数字的转换，例如当我们进行数学运算时；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式转换</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="built_in">Number</span>(obj); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数学运算（除了二元加法）</span></span><br><span class="line"><span class="keyword">let</span> n = +obj; <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> delta = <span class="keyword">new</span> <span class="built_in">Date</span> - <span class="keyword">new</span> <span class="built_in">Date</span>; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于/大于的比较</span></span><br><span class="line"><span class="keyword">let</span> greater = user1 &gt; user2; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>“default” hint</li>
</ul>
<p>在少数情况下发生，当运算符“不确定”期望值的类型时；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = obj + user; <span class="comment">// [object Object][object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user == <span class="number">1</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 像 <code>&lt;</code> 和 <code>&gt;</code> 这样的小于/大于比较运算符，也可以同时用于字符串和数字；不过，它们使用 <code>number hint</code>，而不是 <code>default</code>，这是历史原因；</p>
</blockquote>
<p>JavaScript 转换算法：</p>
<ol>
<li>调用 obj<a href="hint">Symbol.toPrimitive</a>，带有 symbol 键 Symbol.toPrimitive（系统 symbol）的方法，如果这个方法存在的话；</li>
<li>否则，如果 hint 是 “string”，尝试 obj.toString() 和 obj.valueOf()，对于字符串转换，优先 toString；</li>
<li>否则，如果 hint 是 “number” 或 “default”，尝试 obj.valueOf() 和 obj.toString()，对于数学运算，优先 valueOf；</li>
</ol>
<p><strong>Symbol.toPrimitive</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里是将此对象转换为原始值的代码</span></span><br><span class="line">  <span class="comment">// 它必须返回一个原始值</span></span><br><span class="line">  <span class="comment">// hint = &quot;string&quot;、&quot;number&quot; 或 &quot;default&quot; 中的一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象原型上添加</span></span><br><span class="line"><span class="built_in">Object</span>.prototype[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">&quot;&quot;</span> + o); <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  money: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    alert(<span class="string">`hint: <span class="subst">$&#123;hint&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> hint == <span class="string">&quot;string&quot;</span> ? <span class="string">`&#123;name: &quot;<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>&quot;&#125;`</span> : <span class="built_in">this</span>.money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换演示：</span></span><br><span class="line">alert(user); <span class="comment">// hint: string -&gt; &#123;name: &quot;John&quot;&#125;</span></span><br><span class="line">alert(+user); <span class="comment">// hint: number -&gt; 1000</span></span><br><span class="line">alert(user + <span class="number">500</span>); <span class="comment">// hint: default -&gt; 1500</span></span><br></pre></td></tr></table></figure>

<p><strong>toString 和 valueOf</strong></p>
<p>还可以使用 toString 和 valueOf 方法，但必须返回一个原始值，如果 toString 或 valueOf 返回了一个对象，那么返回值会被忽略；</p>
<p>默认情况下，普通对象具有 toString 和 valueOf 方法：toString 方法返回一个字符串 “[object Object]”；valueOf 方法返回对象自身；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  money: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;string&quot;</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;name: &quot;<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>&quot;&#125;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span></span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 通常我们希望有一个“全能”的地方来处理所有原始转换；这时，我们可以只实现 <code>toString</code>；如果没有 <code>Symbol.toPrimitive</code> 和 <code>valueOf</code>，<code>toString</code> 将处理所有原始转换；</p>
</blockquote>
<blockquote>
<p>Note: 三种方式转换可以返回任何原始类型；但由于历史原因，如果 <code>toString</code> 或 <code>valueOf</code> 返回一个对象，则不会出现 <code>error</code>，但是这种值会被忽略；</p>
</blockquote>
<p>如果将对象作为参数传递，会先被转换为原始值，如果生成的原始值的类型不正确，则继续进行转换；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">// toString 在没有其他方法的情况下处理所有转换</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(obj * <span class="number">2</span>); <span class="comment">// 4，对象被转换为原始值字符串 &quot;2&quot;，之后它被乘法转换为数字 2</span></span><br></pre></td></tr></table></figure>

<h4 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h4><p>JavaScript 允许我们像使用对象一样使用原始类型，如在字符串字面值上调用方法；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先创建一个包含字符串字面值的特殊对象，</span></span><br><span class="line"><span class="comment">// 然后调用 toUpperCase 方法，之后特殊对象被销毁，只留下原始值；</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;string&quot;</span>.toUpperCase()); <span class="comment">// STRING</span></span><br></pre></td></tr></table></figure>

<p>对象包装器：String、Number、Boolean、Symbol 和 BigInt；</p>
<blockquote>
<p>Note: 不要使用 <code>new</code> 操作符调用包装器，因为包装器会返回一个对象，可能会导致判断失效；</p>
</blockquote>
<blockquote>
<p>Note: 特殊的原始类型 <code>null</code> 和 <code>undefined</code> 是例外，它们没有对应的“对象包装器”，也没有提供任何方法；从某种意义上说，它们是“最原始的”；</p>
</blockquote>
<p>原始类型不是对象，不能存储额外的数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line">str.test = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(str.test); <span class="comment">// 非严格模式 undefined</span></span><br><span class="line"><span class="built_in">console</span>.warn(str.test); <span class="comment">// 严格模式 Uncaught TypeError: Cannot create property &#x27;test&#x27; on string &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>JavaScript 中的常规数字以 64 位的格式 IEEE-754 存储，也被称为“双精度浮点数”；在内部，所以有 64 位可以存储一个数字：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号；因此所表示的范围介于 ±(2^53-1) 之间；</p>
<blockquote>
<p>Tips: 定义数字时，可以使用下划线间隔数字以增强可读性：<code>let billion = 1_000_000_000;</code>，JavaScript 引擎会直接忽略数字之间的 <code>_</code>；</p>
</blockquote>
<p>科学计数法，在 JavaScript 中，可以通过在数字后面附加字母 “e” 并指定零的个数来缩短数字；</p>
<p>十六进制数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西；前缀为 0x，然后是数字；二进制和八进制数字系统很少使用，但也支持使用 0b 和 0o 前缀；</p>
<p>使用 parseInt 和 toString(base) 两个方法可以对进制进行转换；</p>
<p>toString 参数 base 的范围可以从 2 到 36，默认情况下是 10；parseInt 方法将源数按指定进制解析为十进制数；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(number.toString(<span class="number">16</span>)); <span class="comment">// &quot;c8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;c8&quot;</span>, <span class="number">16</span>)); <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 将一个较长的数字标识符转换成较短的时候，可以使用 toString(36)；</p>
</blockquote>
<blockquote>
<p>Tips: 使用两个点来调用一个方法，JavaScript 语法隐含了第一个点之后的部分为小数部分；若数字后有两个点，那么 JavaScript 就知道小数部分为空，现在使用该方法 <code>123456..toString(36)</code>，或直接为数字添加一对括号 <code>(123456).toString(36)</code>；</p>
</blockquote>
<p><strong>舍入</strong></p>
<ol>
<li>Math.floor 向下取整；</li>
<li>Math.ceil 向上取整；</li>
<li>Math.round 四舍五入；</li>
<li>Math.trunc 截断小数点部分（IE 不支持）；</li>
<li>Math.prototype.toFixed(n) 保留 n 位小数，返回字符串；</li>
</ol>
<p><strong>精度丢失</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span> ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello！我是一个会自我增加的数字！</span></span><br><span class="line">alert( <span class="number">9999999999999999</span> ); <span class="comment">// 显示 10000000000000000</span></span><br><span class="line"><span class="comment">// 超过 2^53 次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度损失可能会导致数字的增加和减小，在这种特殊的情况下，数字变小了一点，就会向下舍入；</span></span><br><span class="line">alert( <span class="number">6.35</span>.toFixed(<span class="number">1</span>) ); <span class="comment">// 6.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 偶发的无限循环</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">10</span>) &#123;</span><br><span class="line">  i += <span class="number">0.2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 toPrecision 凑整并 parseFloat 转成数字后再显示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strip</span>(<span class="params">num, precision = <span class="number">12</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="built_in">parseFloat</span>(num.toPrecision(precision));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否在误差范围</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(arg1 - arg2) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 数字内部表示的另一个有趣结果是存在两个零：<code>0</code> 和 <code>-0</code>；因为在存储时，使用一位来存储符号，不过运算符将它们视为相同的值；</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/camsong/blog/issues/9">JavaScript 浮点数陷阱及解法</a></p>
<p><strong>isFinite 和 isNaN</strong></p>
<ul>
<li>isNaN(value) 将其参数转换为数字，然后测试它是否为 NaN；值 “NaN” 是独一无二的，它不等于任何东西，包括它自身，任何不能被转换为数值的的值都会返回 true；</li>
<li>Number.isNaN(value) 首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确；</li>
<li>isFinite(value) 将其参数转换为数字，如果是常规数字，则返回 true，而不是 NaN/Infinity/-Infinity；因此该方法可以用于验证字符串值是否为常规数字；</li>
</ul>
<blockquote>
<p>Note: 在所有数字函数中，包括 <code>isFinite</code>，空字符串或仅有空格的字符串均被视为 <code>0</code>；</p>
</blockquote>
<p><strong>Object.is</strong></p>
<p>当内部算法需要比较两个值是否完全相同时，它使用 Object.is（内部称为 SameValue），这种比较方式经常被用在 JavaScript 规范中；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于 NaN</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>，<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较 0 和 -0，内部符号位不同</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>，-<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>除了以上两种特殊情况，其他情况等价于 ===；</p>
<p><strong>parseInt 和 parseFloat</strong></p>
<p>使用加号 + 或 Number() 的数字转换是严格的，如果一个值不完全是一个数字，就会失败并返回一个 NaN；</p>
<p>parseInt 和 parseFloat 可以从字符串中“读取”数字，直到无法读取为止；如果发生 error，则返回收集到的数字；函数 parseInt 返回一个整数，而 parseFloat 返回一个浮点数；当没有数字可读时会返回 NaN；</p>
<blockquote>
<p>Tips: <code>parseInt(str, radix)</code> 函数具有可选的第二个参数，它指定了数字系统的基数，因此 <code>parseInt</code> 还可以解析十六进制数字、二进制数字等的字符串：</p>
</blockquote>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串的内部格式始终是 UTF-16，它不依赖于页面编码；</p>
<p><strong>转义字符</strong></p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">在 Windows 中，两个字符 \r\n 的组合代表一个换行</td>
</tr>
<tr>
<td align="left">&#39;, &quot;</td>
<td align="left">引号</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">反斜线</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表符</td>
</tr>
<tr>
<td align="left">\b, \f, \v</td>
<td align="left">退格，换页，垂直标签</td>
</tr>
<tr>
<td align="left">\xXX</td>
<td align="left">具有给定十六进制 Unicode XX 的 Unicode 字符</td>
</tr>
<tr>
<td align="left">\uXXXX</td>
<td align="left">以 UTF-16 编码的十六进制代码 XXXX 的 Unicode 字符</td>
</tr>
<tr>
<td align="left">\u{X…XXXXXX}</td>
<td align="left">（1 到 6 个十六进制字符）    具有给定 UTF-32 编码的 Unicode 符号</td>
</tr>
</tbody></table>
<blockquote>
<p>Note: 反斜杠 <code>\</code> 在 JavaScript 中用于正确读取字符串，然后消失，内存中的字符串没有 <code>\</code>；</p>
</blockquote>
<p><strong>访问字符</strong></p>
<p>要获取在 pos 位置的一个字符，可以使用方括号 [pos] 或者调用 str.charAt(pos) 方法；区别是如果没有找到字符，[] 返回 undefined，而 charAt 返回一个空字符串；</p>
<blockquote>
<p>Tips: 通过字符串的 <code>length</code> 属性可以获取字符串的长度；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`Hello`</span>;</span><br><span class="line"></span><br><span class="line">alert( str[<span class="number">1000</span>] ); <span class="comment">// undefined</span></span><br><span class="line">alert( str.charAt(<span class="number">1000</span>) ); <span class="comment">// &#x27;&#x27;（空字符串）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 for ... of 遍历字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> <span class="string">&quot;Hello&quot;</span>) &#123;</span><br><span class="line">  alert(char); <span class="comment">// H,e,l,l,o（char 变为 &quot;H&quot;，然后是 &quot;e&quot;，然后是 &quot;l&quot; 等）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>; <span class="comment">// Uncaught TypeError: Cannot assign to read only property &#x27;0&#x27; of string &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>查找子字符串</strong></p>
<p>使用 str.indexOf(substr, pos) 或 str.lastIndexOf(substr, pos) 方法，从给定位置 pos 开始，在 str 中查找 substr，如果没有找到，则返回 -1，否则返回匹配成功的位置；区别是从字符串的首尾两端开始；</p>
<blockquote>
<p>Tips: 可以使用按位取反 <code>~</code>，将数字转换为 <code>32-bit</code> 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反；对于 <code>32-bit</code> 整数，<code>~n</code> 等于 <code>-(n+1)</code>；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Widget&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未查到是 indexOf 返回 -1，取反后值为 0；</span></span><br><span class="line"><span class="keyword">if</span> (~str.indexOf(<span class="string">&quot;Widget&quot;</span>)) &#123;</span><br><span class="line">  alert( <span class="string">&#x27;Found it!&#x27;</span> ); <span class="comment">// 正常运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>str.includes(substr, pos) 根据 str 中是否包含 substr 来返回 true/false，也可以使用第二个可选参数指定开始搜索的起始位置；</p>
<p>方法 str.startsWith 和 str.endsWith 判断字符串是否以某子字符串开头或结尾；</p>
<p><strong>获取子字符串</strong></p>
<p>str.slice(start [, end]) 返回字符串从 start 到（但不包括）end 的部分；如果没有第二个参数，slice 会一直运行到字符串末尾；start/end 也可以为负值，表示起始位置从字符串结尾计算；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line">alert( str.slice(<span class="number">0</span>, <span class="number">5</span>) ); <span class="comment">// &#x27;strin&#x27;</span></span><br><span class="line">alert( str.slice(<span class="number">0</span>, <span class="number">1</span>) ); <span class="comment">// &#x27;s&#x27;</span></span><br><span class="line">alert( str.slice(<span class="number">2</span>) ); <span class="comment">// &#x27;ringify&#x27;</span></span><br><span class="line">alert( str.slice(-<span class="number">4</span>, -<span class="number">1</span>) ); <span class="comment">// &#x27;gif&#x27;</span></span><br></pre></td></tr></table></figure>

<p>str.substring(start [, end]) 返回字符串在 start 和 end 之间 的部分，与 slice 几乎相同，但允许 start 大于 end（两个值会被交换）；当遇到负数时，会被视为 0；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line">alert( str.substring(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line">alert( str.substring(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line">alert( str.substring(<span class="number">6</span>, <span class="number">0</span>) ); <span class="comment">// &quot;string&quot;</span></span><br><span class="line">alert( str.substring(<span class="number">6</span>, -<span class="number">1</span>) ); <span class="comment">// &quot;string&quot;</span></span><br></pre></td></tr></table></figure>

<p>str.substr(start [, length]) 返回字符串从 start 开始的给定 length 的部分；若第一个参数为负数，则从结尾算起；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line">alert( str.substr(<span class="number">2</span>, <span class="number">4</span>) ); <span class="comment">// &#x27;ring&#x27;</span></span><br><span class="line">alert( str.substr(-<span class="number">4</span>, <span class="number">2</span>) ); <span class="comment">// &#x27;gi&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>str.substr</code> 不在 JavaScript 核心规范中的描述，因此，非浏览器环境可能无法支持它；</p>
</blockquote>
<p><strong>比较字符串</strong></p>
<blockquote>
<p>Note: 小写字母总是大于大写字母，带变音符号的字母存在“乱序”的情况；</p>
</blockquote>
<p>所有的字符串都使用 UTF-16 编码，即每个字符都有对应的数字代码；</p>
<p>str.codePointAt(pos) 返回在 pos 位置的字符代码；<br>String.fromCodePoint(code) 通过数字 code 创建字符；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="string">&quot;z&quot;</span>.codePointAt(<span class="number">0</span>) ); <span class="comment">// 122</span></span><br><span class="line">alert( <span class="string">&quot;Z&quot;</span>.codePointAt(<span class="number">0</span>) ); <span class="comment">// 90</span></span><br><span class="line"></span><br><span class="line">alert( <span class="built_in">String</span>.fromCodePoint(<span class="number">90</span>) ); <span class="comment">// Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 65..220 的字符</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">65</span>; i &lt;= <span class="number">220</span>; i++) &#123;</span><br><span class="line">  str += <span class="built_in">String</span>.fromCodePoint(i);</span><br><span class="line">&#125;</span><br><span class="line">alert( str );</span><br><span class="line"><span class="comment">// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ</span></span><br></pre></td></tr></table></figure>

<p>一种特殊的方法来比较不同语言的字符串，调用 str.localeCompare(str2) 会根据语言规则返回一个整数，这个整数能指示字符串 str 在排序顺序中排在字符串 str2 前面 <code>-</code>、相同 <code>0</code>、后面 <code>+</code>；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首字母大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialFirst</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&quot;string&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>).toUpperCase() + str.slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是一种特殊的对象，它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 length 属性；JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建空数组：</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会创建一个给定长度的数组，但不含有任何项</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>); <span class="comment">// [empty x 2] </span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(item1, item2, ...);</span><br></pre></td></tr></table></figure>

<p><strong>pop/push, shift/unshift 方法</strong></p>
<p>pop 取出并返回数组的最后一个元素；push 在数组末端添加元素；shift 取出数组的第一个元素并返回它；unshift 在数组的首端添加元素；其中，push 和 unshift 方法都可以一次添加多个元素；</p>
<blockquote>
<p>Note: <code>push</code>/<code>pop</code> 方法运行的比较快，而 <code>shift</code>/<code>unshift</code> 比较慢，是因为后二者会移动数组里所有元素；数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作；</p>
</blockquote>
<p><strong>遍历数组</strong></p>
<p>可以使用普通 for 循环或者 for..of，但 for..of 遍历数组只能获取元素值，不能获取当前元素的索引；</p>
<blockquote>
<p>Note: <code>for..in</code> 循环会遍历所有属性，不仅仅是这些数字属性；<code>for..in</code> 循环适用于普通对象，并且做了对应的优化，但是不适用于数组，因此速度要慢 <code>10-100</code> 倍；</p>
</blockquote>
<p><strong>数组 length</strong></p>
<p>当我们修改数组的时候，length 属性会自动更新，准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一；</p>
<blockquote>
<p>Tips: <code>length</code> 属性是可写的，清空数组最简单的方法就是：<code>arr.length = 0</code>，但该过程是不可逆的；</p>
</blockquote>
<blockquote>
<p>Note: 如果使用 <code>==</code> 来比较数组，除非比较的是两个引用同一数组的变量，否则它们永远不相等；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大子数组之和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxSubSum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxSum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> partialSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    partialSum += item; <span class="comment">// 将其加到 partialSum</span></span><br><span class="line">    maxSum = <span class="built_in">Math</span>.max(maxSum, partialSum); <span class="comment">// 记住最大值</span></span><br><span class="line">    <span class="keyword">if</span> (partialSum &lt; <span class="number">0</span>) partialSum = <span class="number">0</span>; <span class="comment">// 如果是负数就置为 0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><p><strong>splice</strong></p>
<p>arr.splice(start[, deleteCount, elem1, …, elemN])，从索引 start 开始修改 arr，start 可以为负数：删除 deleteCount 个元素并在当前位置插入 elem1, …, elemN，最后返回已被删除元素的数组；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第一个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">0</span>, <span class="number">1</span>), arr); <span class="comment">// [1] [2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 删除最后一个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(-<span class="number">1</span>, <span class="number">1</span>), arr); <span class="comment">// [5] [2, 3, 4]</span></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="number">100</span>), arr); <span class="comment">// [] [2, 3, 100, 4] </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 将 <code>deleteCount</code> 设置为 <code>0</code>，<code>splice</code> 方法就能够插入元素而不用删除任何元素；</p>
</blockquote>
<p><strong>slice</strong></p>
<p>arr.slice([start], [end]) 返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组；start 和 end 都可以是负数，在这种情况下，从末尾计算索；</p>
<blockquote>
<p>Tips: 可以不带参数地调用：<code>arr.slice()</code> 会创建一个 <code>arr</code> 的副本；进行不影响原始数组的进一步转换；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;t&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>];</span><br><span class="line"></span><br><span class="line">alert( arr.slice(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// e,s（复制从位置 1 到位置 3 的元素）</span></span><br><span class="line">alert( arr.slice(-<span class="number">2</span>) ); <span class="comment">// s,t（复制从位置 -2 到尾端的元素）</span></span><br></pre></td></tr></table></figure>

<p><strong>concat</strong></p>
<p>arr.concat(arg1, arg2…) 创建一个新数组，其中包含来自于其他数组和其他项的值；</p>
<blockquote>
<p>Note: <code>concat</code> 只复制数组中的元素，即使是一个类数组的对象，也会被当作一个整体；除非类数组的对象具有 <code>Symbol.isConcatSpreadable</code> 属性，那么它就会被 <code>concat</code> 当作一个数组来处理；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  length: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike2 = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>,</span><br><span class="line">  length: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( arr.concat([<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>) ); <span class="comment">// 1,2,3,4,5</span></span><br><span class="line">alert( arr.concat(arrayLike, arrayLike2) ); <span class="comment">// 1,2,3,4,5,[object Object],something</span></span><br></pre></td></tr></table></figure>

<p><strong>forEach</strong></p>
<p>arr.forEach 方法允许为数组的每个元素都运行一个函数；且该函数的结果（如果有返回）会被抛弃和忽略；</p>
<p><strong>indexOf/lastIndexOf 和 includes</strong></p>
<p>arr.indexOf(item, from)/arr.lastIndexOf(item, from) 都从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1；后者从右向左搜索；arr.includes(item, from) 从索引 from 开始搜索 item，如果找到返回 true，否则返回 false；</p>
<blockquote>
<p>Tips: 这些方法使用的是严格相等 <code>===</code> 比较，<code>includes</code> 的一个非常小的差别是它能正确处理NaN，而 <code>indexOf/lastIndexOf</code> 则不能；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>, <span class="literal">null</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.indexOf(<span class="literal">NaN</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.indexOf(<span class="literal">null</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.lastIndexOf(<span class="literal">undefined</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.includes(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.includes(<span class="literal">null</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.includes(<span class="literal">undefined</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>find/findIndex 和 filter</strong></p>
<p>在对象数组中查找具有特定条件的对象，可以使用 find/findIndex 和 filter 方法；</p>
<p>arr.find((item, index, array) =&gt; {…}) 依次对数组中的每个元素调用一个回调函数，其中 item 是元素，index 是它的索引，array 是数组本身；如果回调函数返回 true，则返回 item 并停止迭代，如果返回假值（falsy），则返回 undefined；</p>
<p>arr.findIndex 与 arr.find 的区别只有返回值，前者返回元素索引，后者返回元素本身；</p>
<p>arr.filter 方法返回所有匹配（使回调函数返回 true）元素组成的数组；</p>
<p><strong>map 和 some/every</strong></p>
<p>arr.map((item, index, array) =&gt; { … }) 对数组的每个元素都调用函数，并返回一个新的结果数组；</p>
<p>arr.some(fn)/arr.every(fn) 用于检查数组，对数组的每个元素调用函数 fn；如果任何/所有结果为 true，则返回 true，否则返回 false；且存在短路效应；</p>
<p><strong>sort</strong></p>
<p>arr.sort 方法对数组进行原位（in-place） 排序，并更改元素的顺序，原位是指在此数组内，而非生成一个新数组；</p>
<blockquote>
<p>Note: 元素默认情况下被按字符串进行排序；所有元素都被转换为字符串，然后进行比较，对于字符串，按照词典顺序进行排序；</p>
</blockquote>
<p>arr.sort(fn) 方法实现了通用的排序算法，在内部大多数情况下都是经过快速排序或 Timsort 算法优化的；比较函数 fn 可以返回任何数字，实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// [-2, 0, 1, 2, 8, 15]</span></span><br></pre></td></tr></table></figure>

<p>快速排序是对冒泡排序的一种改进，由 C.A.R.Hoare（Charles Antony Richard Hoare，东尼·霍尔）在 1962 年提出；这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序 js 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuickSort</span>(<span class="params">arr, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = start;</span><br><span class="line">  <span class="keyword">let</span> j = end;</span><br><span class="line">  <span class="keyword">let</span> key = arr[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="comment">// 往前找小于的数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">      arr[i++] = arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往后找大于的数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; key) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">      arr[j--] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  arr[i] = key;</span><br><span class="line">  QuickSort(arr, start, i - <span class="number">1</span>);</span><br><span class="line">  QuickSort(arr, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">72</span>, <span class="number">6</span>, <span class="number">57</span>, <span class="number">88</span>, <span class="number">60</span>, <span class="number">42</span>, <span class="number">83</span>, <span class="number">73</span>, <span class="number">48</span>, <span class="number">85</span>];</span><br><span class="line">QuickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [6, 42, 48, 57, 60, 72, 73, 83, 85, 88]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/117.html">快速排序算法详解（原理、实现和时间复杂度）</a></li>
<li><a target="_blank" rel="noopener" href="https://sikasjc.github.io/2018/07/25/timsort/">Timsort原理学习</a></li>
<li><a target="_blank" rel="noopener" href="https://v8.dev/blog/array-sort#timsort">Getting things sorted in V8</a></li>
</ul>
<p><strong>reverse</strong></p>
<p>arr.reverse 方法用于颠倒 arr 中元素的顺序，同时也会返回颠倒后的数组 arr；</p>
<p><strong>split 和 join</strong></p>
<p>str.split(delim[, limit]) 方法通过给定的分隔符 delim 将字符串分割成一个数组；split 还有一个可选的第二个数字参数，可以限制数组长度，忽略额外的元素；</p>
<blockquote>
<p>Tips: 调用带有空字符串参数的 <code>split(&#39;&#39;)</code>，会将字符串拆分为字母数组；如果一个元素为 <code>undefined</code> 或 <code>null</code>，它会被转换为空字符串；</p>
</blockquote>
<p>arr.join(glue) 与 split 相反，该方法会创建并返回一个由连接符连接的数组元素的字符串；</p>
<p><strong>reduce/reduceRight</strong></p>
<p>arr.reduce((accumulator, item, index, array) =&gt; { … }, [initial]) 函数一个接一个地应用于所有数组元素，并将其结果“搬运”到下一个调用，其中 accumulator 是上一个函数调用的结果，第一次等于 initial（若存在）；arr.reduceRight 和 arr.reduce 方法的功能一样，只是遍历为从右到左；</p>
<p><strong>fill 和 copyWithin</strong></p>
<p>arr.fill(value, start, end) 从索引 start 到 end，用重复的 value 填充数组；</p>
<p>arr.copyWithin(target, start, end) 将从位置 start 到 end 的所有元素复制到自身的 target 位置（覆盖现有元素）；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">alert(result); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>如果没有初始值，那么 reduce 会将数组的第一个元素作为初始值，并从第二个元素开始迭代；但如果数组为空，那么在没有初始值的情况下调用 reduce 会导致错误；所以建议始终指定初始值；</p>
<p><strong>Array.isArray</strong></p>
<p>因为数组是基于对象的，不构成单独的语言类型，所以 typeof 不能帮助从数组中区分出普通对象；但可以使用 Array.isArray() 方法判断；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> []); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Array</span>.isArray(&#123;&#125;)); <span class="comment">// false</span></span><br><span class="line">alert(<span class="built_in">Array</span>.isArray([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>thisArg</strong></p>
<p>几乎所有调用函数的数组方法，都接受一个可选的附加参数 thisArg；当数组方法的回调函数为普通函数时，该参数值为 this；当使用对象方法作为数组方法的回调函数时，通过该参数将对象上下文语境传入；（不常用）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> army = &#123;</span><br><span class="line">  minAge: <span class="number">18</span>,</span><br><span class="line">  maxAge: <span class="number">27</span>,</span><br><span class="line">  <span class="function"><span class="title">canJoin</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> user.age &gt; <span class="number">20</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> users = [&#123; <span class="attr">age</span>: <span class="number">16</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">23</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">30</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> soldiers = users.filter(army.canJoin, army);</span><br><span class="line"><span class="built_in">console</span>.log(soldiers); <span class="comment">// [&#123;age: 23&#125;, &#123;age: 30&#125;]</span></span><br></pre></td></tr></table></figure>

<p><strong>其他方法</strong></p>
<p>arr.flat(depth)/arr.flatMap(fn) 可以从多维数组创建一个新的扁平数组；</p>
<p>Array.of(element0[, element1[, …[, elementN]]]) 基于可变数量的参数创建一个新的 Array 实例，而不需要考虑参数的数量或类型；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fisher-Yates shuffle 随机排列数组</span></span><br><span class="line"><span class="comment">// 思路：逆向遍历数组，并将每个元素与其前面的随机的一个元素互换位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 从 0 到 i 的随机索引</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>)); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解构交换元素 array[i] 和 array[j]</span></span><br><span class="line">    [array[i], array[j]] = [array[j], array[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h4><p>可迭代（Iterable）对象是数组的泛化，这个概念是说任何对象都可以被定制为可在 for..of 循环中使用的对象；数组和字符串是使用最广泛的内建可迭代对象；</p>
<p>为了让对象可迭代，需要为对象添加一个名为 Symbol.iterator 的方法，该方法是一个专门用于使对象可迭代的内建 symbol；</p>
<p>for..of 循环：</p>
<ol>
<li>首先会调用 Symbol.iterator 方法（没有就报错）；</li>
<li>这个方法必须返回一个迭代器（iterator）即一个有 next 方法的对象；</li>
<li>此后，for..of 仅适用于这个被返回的对象；</li>
<li>然后通过调用返回对象的 next() 方法 for..of 循环取得下一个数值；</li>
<li>next() 方法返回的结果的格式必须是 { done: Boolean, value: any }；</li>
<li>当 done = true 时，表示循环结束，否则 value 是下一个值；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义可迭代对象 range</span></span><br><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="comment">// 返回一个带有 next 方法的对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      current: <span class="built_in">this</span>.from,</span><br><span class="line">      last: <span class="built_in">this</span>.to,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在每轮 for..of 循环中调用</span></span><br><span class="line">      <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 固定返回一个 &#123; done, value &#125; 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.current &lt; <span class="built_in">this</span>.last</span><br><span class="line">          ? &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;</span><br><span class="line">          : &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; <span class="comment">// 当 done 为 true 时，结束迭代</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> it <span class="keyword">of</span> range) &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(it); <span class="comment">// 1, 2, 3, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 注意可迭代对象的核心功能：关注点分离；<code>range</code> 自身没有 <code>next()</code> 方法，相反，是通过调用 <code>range[Symbol.iterator]()</code> 创建了另一个对象，即所谓的“迭代器”对象，并且它的 <code>next</code> 会为迭代生成值；</p>
</blockquote>
<p>从技术上说，我们可以将它们合并，并使用 range 自身作为迭代器来简化代码，但现在不可能同时在对象上运行两个 for..of 循环：它们共享迭代状态，因为只有一个迭代器，即对象本身；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">this</span>.from;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.current &lt; <span class="built_in">this</span>.to</span><br><span class="line">      ? &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;</span><br><span class="line">      : &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 无穷迭代器，<code>next</code> 没有什么限制，它可以返回越来越多的值，这是正常的，可以通过 <code>break</code> 跳出 <code>for..of</code> 循环；</p>
</blockquote>
<p><strong>可迭代和类数组</strong></p>
<p>Iterable 如上所述，是实现了 Symbol.iterator 方法的对象；Array-like 是有索引和 length 属性的对象，所以它们看起来很像数组；但是一个可迭代对象也许不是类数组对象，反之亦然，类数组对象可能不可迭代</p>
<blockquote>
<p>Note: 字符串即是可迭代的（<code>for..of</code> 对它们有效），又是类数组的（它们有数值索引和 <code>length</code> 属性）；</p>
</blockquote>
<p><strong>Array.from</strong></p>
<p>全局方法 Array.from 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组；Array.from(obj[, mapFn, thisArg]) 完整语法还允许我们提供一个可选的“映射（mapping）”函数；可选的第二个参数 mapFn 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 thisArg 允许我们为该函数设置 this；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(range);</span><br><span class="line">alert(arr); <span class="comment">// 1,2,3,4,5 （数组的 toString 转化方法生效）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求每个数的平方</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(range, <span class="function"><span class="params">num</span> =&gt;</span> num * num);</span><br><span class="line">alert(arr); <span class="comment">// 1,4,9,16,25</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 基于 <code>Array.from</code> 创建代理感知（surrogate-aware）的 <code>slice</code> 方法，即能够处理 <code>UTF-16</code> 扩展字符的 <code>slice</code> 方法；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slice</span>(<span class="params">str, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(str).slice(start, end).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𝒳😂𩷶&#x27;</span>;</span><br><span class="line">alert( slice(str, <span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 😂𩷶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生方法不支持识别代理对（译注：UTF-16 扩展字符）</span></span><br><span class="line">alert( str.slice(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 在规范中，大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高；</p>
</blockquote>
<h4 id="Map-and-Set（映射和集合）"><a href="#Map-and-Set（映射和集合）" class="headerlink" title="Map and Set（映射和集合）"></a>Map and Set（映射和集合）</h4><p><strong>Map</strong></p>
<p>Map 是一个带键的数据项的集合，就像一个 Object 一样；但 Map 允许任何类型的键（key），包括对象；</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">new Map()</td>
<td align="left">创建 map</td>
</tr>
<tr>
<td align="left">map.set(key, value)</td>
<td align="left">根据键存储值，并返回 map 本身，因此可以链式调用</td>
</tr>
<tr>
<td align="left">map.get(key)</td>
<td align="left">根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined</td>
</tr>
<tr>
<td align="left">map.has(key)</td>
<td align="left">如果 key 存在则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="left">map.delete(key)</td>
<td align="left">删除指定键的值</td>
</tr>
<tr>
<td align="left">map.clear()</td>
<td align="left">清空 map</td>
</tr>
<tr>
<td align="left">map.size</td>
<td align="left">返回当前元素个数</td>
</tr>
</tbody></table>
<blockquote>
<p>Note: 虽然 <code>map[key]</code> 也有效，例如我们可以设置 <code>map[key] = 2</code>，这样会将 <code>map</code> 视为 JavaScript 的普通对象 <code>plain object</code>，因此它暗含了所有相应的限制（仅支持 <code>string</code>/<code>symbol</code> 键等）</p>
</blockquote>
<blockquote>
<p>Note: <code>Map</code> 使用 <code>SameValueZero</code> 算法来比较键是否相等，它和严格等于 <code>===</code> 差不多，但区别是 <code>NaN</code> 被看成是等于 <code>NaN</code>，所以 <code>NaN</code> 也可以被用作键；</p>
</blockquote>
<p><strong>Map 迭代</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">map.keys()</td>
<td align="left">返回所有键的迭代器</td>
</tr>
<tr>
<td align="left">map.values()</td>
<td align="left">返回所有值的迭代器</td>
</tr>
<tr>
<td align="left">map.entries()</td>
<td align="left">返回所有实体 [key, value] 的迭代器</td>
</tr>
<tr>
<td align="left">map.forEach((value, key, map) =&gt; {})</td>
<td align="left">与 Array 的类似</td>
</tr>
</tbody></table>
<p>for..of 在遍历 map 时，默认情况下使用的是 map.entries 方法；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化空 Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;str1&quot;</span>).set(<span class="number">1</span>, <span class="string">&quot;num1&quot;</span>).set(<span class="literal">true</span>, <span class="string">&quot;bool1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// [&#x27;1&#x27;, &#x27;str1&#x27;] [1, &#x27;num1&#x27;] [true, &#x27;bool1&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带键值对的二维数组初始化 Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;1&#x27;</span>,  <span class="string">&#x27;str1&#x27;</span>],</span><br><span class="line">  [<span class="number">1</span>,    <span class="string">&#x27;num1&#x27;</span>],</span><br><span class="line">  [<span class="literal">true</span>, <span class="string">&#x27;bool1&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可迭代对象初始化 Map，iter 返回键值对的数组</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(iter);</span><br></pre></td></tr></table></figure>

<p><strong>Map 与对象的转换</strong></p>
<p>Object.entries(obj) 该方法返回对象的键/值对数组，该数组格式完全按照 Map 所需的格式；因此可以根据一个已有的普通对象（plain object）来创建一个 Map；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure>

<p>而 Object.fromEntries 作用是给定一个具有 [key, value] 键值对的数组，它会根据给定数组创建一个对象；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;banana&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">map.set(<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">map.set(<span class="string">&#x27;meat&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个普通对象</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(map.entries()); </span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(map); <span class="comment">// 效果同上，解释如下</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: <code>Object.fromEntries</code> 期望得到一个可迭代对象作为参数，而不一定是数组，并且 <code>map</code> 的标准迭代会返回跟 <code>map.entries()</code> 一样的键/值对；</p>
</blockquote>
<p><strong>Set</strong></p>
<p>Set 是一个特殊的类型集合，没有键，只有值的集合，且它的每一个值只能出现一次；</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">new Set(iterable)</td>
<td align="left">创建一个 set，参数是一个 iterable 对象</td>
</tr>
<tr>
<td align="left">set.add(value)</td>
<td align="left">添加一个值，返回 set 本身</td>
</tr>
<tr>
<td align="left">set.delete(value)</td>
<td align="left">删除值，如果 value 存在则返回 true ，否则返回 false</td>
</tr>
<tr>
<td align="left">set.has(value)</td>
<td align="left">如果 value 在 set 中，返回 true，否则返回 false</td>
</tr>
<tr>
<td align="left">set.clear()</td>
<td align="left">清空 set</td>
</tr>
<tr>
<td align="left">set.size</td>
<td align="left">返回元素个数</td>
</tr>
</tbody></table>
<p>Set 的主要特点是，重复使用同一个值调用 set.add(value) 并不会发生什么改变，这就是 Set 里面的每一个值只出现一次的原因；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>])); <span class="comment">// [1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>Set 迭代</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">set.keys()</td>
<td align="left">返回包含所有值的迭代器</td>
</tr>
<tr>
<td align="left">set.values()</td>
<td align="left">同 keys，为了兼容 Map</td>
</tr>
<tr>
<td align="left">set.entries()</td>
<td align="left">返回所有实体 [value, value] 的迭代器，为了兼容 Map</td>
</tr>
<tr>
<td align="left">set.forEach((value, valueAgain, set) =&gt; {})</td>
<td align="left">与 Array 的类似，也为了兼容 Map</td>
</tr>
</tbody></table>
<blockquote>
<p>Tips: 在 <code>Map</code> 和 <code>Set</code> 中迭代总是按照值插入的顺序进行的，所以我们不能说这些集合是无序的，但是我们不能对元素进行重新排序，也不能直接按其编号来获取元素；</p>
</blockquote>
<h4 id="WeakMap-and-WeakSet"><a href="#WeakMap-and-WeakSet" class="headerlink" title="WeakMap and WeakSet"></a>WeakMap and WeakSet</h4><p><strong>WeakMap</strong></p>
<p>WeakMap 和 Map 的第一个不同点就是，WeakMap 的键必须是对象，不能是原始值；</p>
<p>WeakMap 不支持迭代以及 keys()，values() 和 entries() 方法，所以没有办法获取 WeakMap 的所有键或值；只有 get(key)、set(key, value)、delete(key)、has(key) 方法；</p>
<blockquote>
<p>Note: <code>WeakMap</code> 不会阻止垃圾回收机制对作为键的对象（key object）的回收，在从技术的角度并不能准确知道 何时会被回收，这些都是由 JavaScript 引擎决定的；因此，暂不支持访问 <code>WeakMap</code> 的所有键/值的方法；</p>
</blockquote>
<blockquote>
<p>Tips: <code>WeakMap</code> 的主要应用场景是额外数据的存储；这些数据放到 <code>WeakMap</code> 中，并使用第三方对象作为这些数据的键，那么当该对象被垃圾回收机制回收后，这些数据也会被自动清除；</p>
</blockquote>
<blockquote>
<p>Tips: <code>WeakMap</code> 也可以用于缓存函数的结果，以便将来对同一个对象的调用可以重用这个结果；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cache.js</span></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算并记结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!cache.has(obj)) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="comment">/* calculate the result for */</span> obj;</span><br><span class="line"></span><br><span class="line">    cache.set(obj, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cache.get(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="comment">/* some object */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = process(obj);</span><br><span class="line"><span class="keyword">let</span> result2 = process(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要这个对象时：</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p><strong>WeakSet</strong></p>
<p>与 Set 类似，但是我们只能向 WeakSet 添加对象（而不能是原始值）；且对象只有在其它某个（些）地方能被访问的时候，才能留在 set 中；WeakSet 支持 add，has 和 delete 方法，但不支持 size 和 keys()，并且不可迭代；</p>
<blockquote>
<p>Tips: <code>WeakSet</code> 同 <code>WeakMap</code> 的主要优点是对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除；</p>
</blockquote>
<h4 id="Object-keys，values，entries"><a href="#Object-keys，values，entries" class="headerlink" title="Object.keys，values，entries"></a>Object.keys，values，entries</h4><p>对于普通对象：</p>
<p>Object.keys(obj) 返回一个包含该对象所有的键的数组；<br>Object.values(obj) 返回一个包含该对象所有的值的数组；<br>Object.entries(obj) 返回一个包含该对象所有 [key, value] 键值对的数组；</p>
<blockquote>
<p>Note: <code>Object.*</code> 方法返回的是“真正的”数组对象，而不只是一个可迭代项，这与 <code>Map</code> 有区别，这主要是历史原因；<code>Object.*</code> 还会忽略 <code>symbol</code> 属性；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换对象</span></span><br><span class="line"><span class="keyword">let</span> prices = &#123;</span><br><span class="line">  banana: <span class="number">1</span>,</span><br><span class="line">  orange: <span class="number">2</span>,</span><br><span class="line">  meat: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doublePrices = <span class="built_in">Object</span>.fromEntries(</span><br><span class="line">  <span class="comment">// 将价格转换为数组，将每个键/值对映射为另一对</span></span><br><span class="line">  <span class="comment">// 然后通过 fromEntries 再将结果转换为对象</span></span><br><span class="line">  <span class="built_in">Object</span>.entries(prices).map(<span class="function"><span class="params">entry</span> =&gt;</span> [entry[<span class="number">0</span>], entry[<span class="number">1</span>] * <span class="number">2</span>])</span><br><span class="line">);</span><br><span class="line">alert(doublePrices.meat); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以是一个类似于 map.entries() 的迭代器</span></span><br><span class="line"><span class="built_in">Object</span>.fromEntries(rangeEntries); <span class="comment">// &#123;1: 1, 2: 1, 3: 1, 4: 1&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算属性之和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumSalaries</span>(<span class="params">salaries</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.values(salaries).reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>JavaScript 中最常用的两种数据结构是 Object 和 Array；对象是通过键来存储数据项的单个实体，数组将数据收集到一个有序的集合；</p>
<p>解构赋值是通过将结构中的各元素复制到变量中来达到“解构”的目的，但结构本身是没有被修改的；本质上，解构赋值其实是一种用于对在 = 右侧的值上调用 for..of 并进行赋值的操作的语法糖；</p>
<p><strong>数组解构</strong></p>
<ol>
<li>数组中不想要的元素也可以通过添加额外的逗号来把它丢弃；</li>
<li>等号右侧可以是任何可迭代对象，因为在内部，结构赋值是通过迭代右侧的值来完成工作的；</li>
<li>赋值给等号左侧的任何内容，也可以是一个对象属性；</li>
<li>可以与 .entries() 方法进行循环操作；</li>
<li>可以用于交换变量；</li>
<li>等号左侧可以收集剩余数组项；</li>
<li>如果数组比左边的变量列表短，缺少的值被认为是 undefined；</li>
<li>可在等号左侧指定默认值，默认值可以是更加复杂的表达式甚至可以是函数调用；</li>
<li></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Smith&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [firstName, surname] = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配合 split 使用</span></span><br><span class="line"><span class="keyword">let</span> [firstName, surname] = <span class="string">&quot;John Smith&quot;</span>.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略使用逗号的元素，不需要第二个元素，后面剩余值被忽略</span></span><br><span class="line"><span class="keyword">let</span> [firstName, , title] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等号右侧可以是任何可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="keyword">let</span> [one, two, three] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历键—值对</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(user)) &#123;</span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// name:John, then age:30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换变量</span></span><br><span class="line">[guest, admin] = [admin, guest];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集剩余项，rest 的值就是数组中剩下的元素组成的数组</span></span><br><span class="line"><span class="keyword">let</span> [name1, name2, ...rest] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也不会出现报错，缺省值为 undefined</span></span><br><span class="line"><span class="keyword">let</span> [firstName, surname] = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定未赋值的变量默认值</span></span><br><span class="line"><span class="keyword">let</span> [name = <span class="string">&quot;Guest&quot;</span>, surname = <span class="string">&quot;Anonymous&quot;</span>] = [<span class="string">&quot;Julius&quot;</span>];</span><br><span class="line"><span class="comment">// 表达式或函数只会在这个变量未被赋值的时候才会被计算</span></span><br><span class="line"><span class="keyword">let</span> [name = prompt(<span class="string">&#x27;name?&#x27;</span>), surname = prompt(<span class="string">&#x27;surname?&#x27;</span>)] = [<span class="string">&quot;Julius&quot;</span>];</span><br></pre></td></tr></table></figure>

<p><strong>对象解构</strong></p>
<ol>
<li>可以使用 : 指定属性和变量之间的映射关系；</li>
<li>可以使用 = 设置默认值；</li>
<li>默认值可以是任意表达式或函数调用，且只会在未提供对应的值时才会被计算/调用；</li>
<li>可以只提取所需的内容；</li>
<li>可以提取剩余属性的，并存为对象；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">200</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本使用，且变量的顺序并不重要</span></span><br><span class="line"><span class="keyword">let</span> &#123; title, width, height &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定属性和变量之间的映射关系</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">width</span>: w, <span class="attr">height</span>: h, title &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &quot;=&quot; 设置默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123; width = <span class="number">100</span>, height = <span class="number">200</span>, title &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值可以是任意表达式甚至可以是函数调用</span></span><br><span class="line"><span class="keyword">let</span> &#123; width = prompt(<span class="string">&quot;width?&quot;</span>), title = prompt(<span class="string">&quot;title?&quot;</span>) &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时指定映射关系和默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">width</span>: w = <span class="number">100</span>, <span class="attr">height</span>: h = <span class="number">200</span>, title &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只提取所需的内容</span></span><br><span class="line"><span class="keyword">let</span> &#123; title &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest 存有剩余属性的对象</span></span><br><span class="line"><span class="keyword">let</span> &#123; title, ...rest &#125; = options;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 不使用 <code>let</code> 时可能存在 JavaScript 引擎把 <code>&#123;...&#125;</code> 当作代码块处理；因此需要用括号将解构赋值语句包裹起来；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> title, width, height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;=&#x27;</span></span><br><span class="line">&#123;title, width, height&#125; = &#123;<span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加括号后，正常运行</span></span><br><span class="line">(&#123;title, width, height&#125; = &#123;<span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 如果一个对象或数组嵌套了其他的对象和数组，可以在等号左侧使用更复杂的模式来提取更深层的数据，也称嵌套结构；</p>
</blockquote>
<blockquote>
<p>Tips: 可以把所有参数当作一个对象来传递，然后函数马上把这个对象解构成多个变量；然后通过指定空对象 <code>&#123;&#125;</code> 为整个参数对象的默认值，实现让所有的参数都使用默认值；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">&#123; title = <span class="string">&quot;Untitled&quot;</span>, width: w = <span class="number">100</span>, height: h = <span class="number">200</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;w&#125;</span> <span class="subst">$&#123;h&#125;</span>`</span> ); <span class="comment">// My Menu 100 200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种默认 options 参数</span></span><br><span class="line"><span class="keyword">let</span> defaultOptions = &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> computedOptions = &#123; ...defaultOptions, ...options &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(computedOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p>内建对象：日期（Date）用于存储日期和时间，并提供了日期/时间的管理方法；</p>
<p><strong>创建方法</strong>：</p>
<ol>
<li>new Date() 不带参数，创建当前日期和时间的 Date 对象；</li>
<li>new Date(milliseconds) 传入的整数参数代表自 1970-01-01 00:00:00 以来经过的毫秒数，该整数被称为时间戳，时间戳也可以为负；</li>
<li>new Date(datestring) 若只有一个字符串参数，则会被自动解析；该算法与 Date.parse 所使用的算法相同；</li>
<li>new Date(year, month, date, hours, minutes, seconds, ms) 使用当前时区中的给定组件创建日期，只有前两个参数是必须的；year 必须是四位数，month 是 0 到 11 的整数，date 是当月的具体某一天，缺失则默认 1，hours/minutes/seconds/ms 缺失则均为默认值 0；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new Date()</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// Fri Mar 04 2022 08:57:13 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new Date(milliseconds)</span></span><br><span class="line"><span class="keyword">let</span> Jan01_1970 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>); <span class="comment">// 0 表示 01.01.1970 UTC+0</span></span><br><span class="line"><span class="keyword">let</span> Dec31_1969 = <span class="keyword">new</span> <span class="built_in">Date</span>(-<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>); <span class="comment">// 负时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new Date(datestring)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2017-01-26&quot;</span>);</span><br><span class="line"><span class="comment">// 该时间未被设定，因此被假定为格林尼治标准时间（GMT）的午夜</span></span><br><span class="line"><span class="comment">// 并会根据代码运行时的时区进行调整，因此可能得到以下结果</span></span><br><span class="line"><span class="comment">// Thu Jan 26 2017 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)</span></span><br><span class="line"><span class="comment">// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new Date(year, month, date, hours, minutes, seconds, ms)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 1 Jan 2011, 00:00:00</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">567</span>); <span class="comment">// 1.01.2011, 02:03:04.567</span></span><br></pre></td></tr></table></figure>

<p><strong>访问日期</strong></p>
<ol>
<li>getFullYear() 获取年份（4 位数）；</li>
<li>getMonth() 获取月份，从 0 到 11；</li>
<li>getDate() 获取当月的具体日期，从 1 到 31；</li>
<li>getHours()，getMinutes()，getSeconds()，getMilliseconds() 获取相应的时间组件；</li>
<li>getDay() 获取一周中的第几天，从 0（星期日）到 6（星期六），第一天始终是星期日；</li>
<li>getTime() 返回日期的时间戳，从 1970-1-1 00:00:00 UTC+0 到现在所经过的毫秒数；</li>
<li>getTimezoneOffset() 返回 UTC 与本地时区之间的时差，以分钟为单位；</li>
</ol>
<p>getTimezoneOffset()<br>返回 UTC 与本地时区之间的时差，以分钟为单位</p>
<blockquote>
<p>Note: 很多 JavaScript 引擎都实现了一个非标准化的方法 <code>getYear()</code>，不推荐使用这个方法，直接使用 <code>getFullYear()</code>；</p>
</blockquote>
<blockquote>
<p>Tips: <code>get*</code> （除上述最后两个） 这类方法都是基于当地时区的；可以在 “get” 之后插入 “UTC”，使用 <code>getUTC*</code> 以获取与当地时区的 UTC 对应项；</p>
</blockquote>
<blockquote>
<p>Tips: <code>new Date().getUTCHours() - new Date().getHours()</code> 可得到当地时区相对于 UTC 的偏移；UTC 也即非夏令时的伦敦时间；</p>
</blockquote>
<p><strong>设置日期</strong></p>
<ol>
<li>setFullYear(year, [month], [date])</li>
<li>setMonth(month, [date])</li>
<li>setDate(date)</li>
<li>setHours(hour, [min], [sec], [ms])</li>
<li>setMinutes(min, [sec], [ms])</li>
<li>setSeconds(sec, [ms])</li>
<li>setMilliseconds(ms)</li>
<li>setTime(milliseconds)</li>
</ol>
<p>以上方法除了 setTime() 都有 UTC 变体；</p>
<blockquote>
<p>Tips: 自动校准 是 <code>Date</code> 对象的一个非常方便的特性，当设置超范围的数值，会被自动校准；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动考虑闰年情况</span></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">28</span>);</span><br><span class="line">date.setDate(date.getDate() + <span class="number">2</span>); <span class="comment">// 2016.03.01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 2016.01.02</span></span><br><span class="line"><span class="comment">// 设置为当月的第一天</span></span><br><span class="line">date.setDate(<span class="number">1</span>); <span class="comment">// 2016.01.01</span></span><br><span class="line"><span class="comment">// 天数最小可以设置为 1，所以这里设置的是上一月的最后一天</span></span><br><span class="line">date.setDate(<span class="number">0</span>); <span class="comment">// 2015.12.31</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 利用 Date 对象转数字可快速获取时间戳；<code>+new Date()</code> 即当前时间戳；此外日期可以相减，相减的结果是以毫秒为单位时间差；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// 1646360860388</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">28</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>() - date); <span class="comment">// 31919237496</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 当只需要时间戳而不需要创建日期对象时，可以使用 Date.now() 获取当前时间戳；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测量时间间隔</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now(); <span class="comment">// 从 1 Jan 1970 至今的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> doSomething = i * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> end = <span class="built_in">Date</span>.now(); <span class="comment">// 完成</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">`The loop took <span class="subst">$&#123;end - start&#125;</span> ms`</span> ); <span class="comment">// 相减的是时间戳，而不是日期</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 直接使用日期对象相减得到时间差比使用 <code>getTime()</code> 方法慢，因为 JavaScript 引擎还要做类型转换的额外工作；</p>
</blockquote>
<p>为了得到更加可靠的度量，整个度量测试包应该重新运行多次，现代的 JavaScript 引擎的先进优化策略只对执行很多次的 “hot code” 有效，即对于执行很少次数的代码没有必要优化；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffSubtract</span>(<span class="params">date1, date2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> date2 - date1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffGetTime</span>(<span class="params">date1, date2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> date2.getTime() - date1.getTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bench</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) f(date1, date2);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Date</span>.now() - start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> time1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> time2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主循环中增加“升温”环节</span></span><br><span class="line">bench(diffSubtract);</span><br><span class="line">bench(diffGetTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始度量，交替运行 10 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  time1 += bench(diffSubtract);</span><br><span class="line">  time2 += bench(diffGetTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( <span class="string">&#x27;Total time for diffSubtract: &#x27;</span> + time1 );</span><br><span class="line">alert( <span class="string">&#x27;Total time for diffGetTime: &#x27;</span> + time2 );</span><br></pre></td></tr></table></figure>

<p><strong>Date.parse</strong></p>
<p>Date.parse(str) 方法可以从一个字符串中读取日期；字符串的格式应该为：YYYY-MM-DDTHH:mm:ss.sssZ，其中：</p>
<ol>
<li>YYYY-MM-DD 日期：年-月-日；</li>
<li>字符 “T” 是一个分隔符；</li>
<li>HH:mm:ss.sss 时间：小时，分钟，秒，毫秒；</li>
<li>可选字符 ‘Z’ 为 +-hh:mm 格式的时区，单个字符 Z 代表 UTC+0 时区；</li>
</ol>
<p>Date.parse(str) 调用会解析给定格式的字符串，并返回时间戳，如果给定字符串的格式不正确，则返回 NaN；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ms = <span class="built_in">Date</span>.parse(<span class="string">&#x27;2012-01-26T13:51:50.417-07:00&#x27;</span>); <span class="comment">// 1327611110417</span></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>( <span class="built_in">Date</span>.parse(<span class="string">&#x27;2012-01-26T13:51:50.417-07:00&#x27;</span>) );</span><br></pre></td></tr></table></figure>

<p><strong>其他例子</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取某月的最后一天</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLastDayOfMonth</span>(<span class="params">year, month</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(year, month + <span class="number">1</span>, <span class="number">0</span>).getDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算今天过去了多少秒</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSecondsToday</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Date</span>.now() % (<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>) / <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>相关拓展</strong></p>
<blockquote>
<p>1884 年，华盛顿的国际经度会议规定，将全球按经线从东到西划分为 24 个时区，其中东、西各 12 个时区，同时规定英国（格林尼治天文台旧址）为零时区，这就诞生了第一个世界时：格林尼治标准时间（Greenwich Mean Time，缩写为GMT，又称格林尼治平时）；中国跨 5 个时区，实际上只用东八时区的标准时即北京时间为准；</p>
</blockquote>
<blockquote>
<p>1972 年诞生了：协调世界时（Universal Time Coordinated，缩写为UTC）；UTC 是当前的世界标准时间；UTC 与 GMT 基本上等同，误差不超过 0.9 秒；UTC 的标准格式为 2019-11-11T00:00:00.000Z，T 代表使用 UTC 时间，Z 是 UTC 偏移量，表示 UTC 时间与本地时的差别、即时差，可用以下形式表示: ±[hh]:[mm]、±[hh][mm]、±[hh]，例如北京时间比 GMT 要早 8 小时，写作 2019-11-11T08:00:00.000+0800</p>
</blockquote>
<blockquote>
<p>Unix 时间(Unix Time)，也叫做 POSIX 时间或纪元时间(Epoch Time)，是用来记录时间的流逝，所以也常被叫做时间戳，定义为从 1970-01-01T00:00:00 开始流逝的秒数，不考虑闰秒；之后的时间是正数，之前的是负数；</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zgdwxp/article/details/102728563">时区是怎么划分的？世界各时区的时间如何统一表达？GMT、UTC、UNIX有什么区别？</a></p>
<h4 id="JSON-方法，toJSON"><a href="#JSON-方法，toJSON" class="headerlink" title="JSON 方法，toJSON"></a>JSON 方法，toJSON</h4><p>JSON（JavaScript Object Notation）是表示值和对象的通用格式；</p>
<p><strong>JSON.stringify</strong></p>
<p>该方法将对象转换为 JSON；得到的 json 字符串是一个被称为 JSON 编码（JSON-encoded） 或 序列化（serialized） 或 字符串化（stringified） 或 编组化（marshalled） 的对象；</p>
<p>JSON 中没有单引号或反引号，JSON 格式字符串都使用双引号，包括对象属性名称也强制使用双引号；</p>
<p>JSON 支持以下数据类型：</p>
<ul>
<li>Objects { … }</li>
<li>Arrays [ … ]</li>
<li>strings</li>
<li>numbers</li>
<li>boolean true/false</li>
<li>null</li>
</ul>
<p>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过；</p>
<ul>
<li>函数属性（方法）</li>
<li>Symbol 类型的键和值</li>
<li>存储 undefined 的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 被忽略</span></span><br><span class="line">    alert(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>)]: <span class="number">123</span>, <span class="comment">// 被忽略</span></span><br><span class="line">  something: <span class="literal">undefined</span> <span class="comment">// 被忽略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( <span class="built_in">JSON</span>.stringify(user) ); <span class="comment">// &#123;&#125;（空对象）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>JSON.strinify</code> 支持嵌套对象转换，并且可以自动对其进行转换，但有重要的限制：不得有循环引用；</p>
</blockquote>
<p>JSON.stringify 完整语法是 JSON.stringify(value[, replacer, space])；其中 value 是要编码的值，replacer 是要编码的属性数组或映射函数 function(key, value)，space 是用于格式化的空格数量，或者字符串占位符；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">  number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">  participants: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">  place: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; <span class="comment">// room 引用了 meetup</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性数组</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(meetup, [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;participants&#x27;</span>]) );</span><br><span class="line"><span class="comment">// &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[&#123;&#125;,&#123;&#125;]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造 Object.prototype.toString 方法方便查看 replacer 调用过程</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + <span class="built_in">Object</span>.keys(<span class="built_in">this</span>).join(<span class="string">&quot;, &quot;</span>) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;result:&quot;</span>, <span class="built_in">JSON</span>.stringify(meetup, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> key == <span class="string">&quot;occupiedBy&quot;</span> ? <span class="literal">undefined</span> : value;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 根据输出结果可以看出 stringify 是递归调用的；</span></span><br><span class="line"><span class="comment">// 第一个调用是使用特殊的“包装对象”制作的：&#123;&quot;&quot;: meetup&#125;，</span></span><br><span class="line"><span class="comment">// 该键为空，值是整个目标对象；</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">: [title, participants, place]</span></span><br><span class="line"><span class="comment">title: Conference</span></span><br><span class="line"><span class="comment">participants: [name],[name]</span></span><br><span class="line"><span class="comment">0: [name]</span></span><br><span class="line"><span class="comment">name: John</span></span><br><span class="line"><span class="comment">1: [name]</span></span><br><span class="line"><span class="comment">name: Alice</span></span><br><span class="line"><span class="comment">place: [number, occupiedBy]</span></span><br><span class="line"><span class="comment">number: 23</span></span><br><span class="line"><span class="comment">occupiedBy: [title, participants, place]</span></span><br><span class="line"><span class="comment">result: &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[&#123;&quot;name&quot;:&quot;John&quot;&#125;,&#123;&quot;name&quot;:&quot;Alice&quot;&#125;],&quot;place&quot;:&#123;&quot;number&quot;:23&#125;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义 “toJSON”</strong></p>
<p>像 toString 进行字符串转换，对象也可以提供 toJSON 方法来进行 JSON 转换，如果可用，JSON.stringify 会自动调用它；</p>
<blockquote>
<p>Tips: 所有日期都有一个内建的 <code>toJSON</code> 方法来返回 UTC 格式类型的字符串；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>&#125;) </span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;date&quot;:&quot;2022-03-04T04:05:05.467Z&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: <code>toJSON</code> 既可以用于直接调用 <code>JSON.stringify</code> 也可以用于当对象嵌套在另一个编码对象中时；</p>
</blockquote>
<p><strong>JSON.parse</strong></p>
<p>该方法用于解码 JSON 字符串，完整语法：JSON.parse(str, [reviver])；其中 str 是要解析的 JSON reviver 是可选的函数 function(key,value) 该函数将为每个 (key, value) 对调用，并可以对值进行转换；</p>
<blockquote>
<p>Note: JSON 不支持注释，向 JSON 添加注释无效；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#123;&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = <span class="built_in">JSON</span>.parse(str, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="string">&#x27;date&#x27;</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert( meetup.date.getDate() ); <span class="comment">// 正常运行</span></span><br></pre></td></tr></table></figure>

<p>排除反向引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">  number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">  occupiedBy: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">  place: room</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环引用</span></span><br><span class="line">room.occupiedBy = meetup;</span><br><span class="line">meetup.self = meetup;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排除第一个调用时 value 是 meetup 的情况</span></span><br><span class="line">alert( <span class="built_in">JSON</span>.stringify(meetup, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (key != <span class="string">&quot;&quot;</span> &amp;&amp; value == meetup) ? <span class="literal">undefined</span> : value;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;title&quot;:&quot;Conference&quot;,</span></span><br><span class="line"><span class="comment">  &quot;occupiedBy&quot;:[&#123;&quot;name&quot;:&quot;John&quot;&#125;,&#123;&quot;name&quot;:&quot;Alice&quot;&#125;],</span></span><br><span class="line"><span class="comment">  &quot;place&quot;:&#123;&quot;number&quot;:23&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="递归和堆栈"><a href="#递归和堆栈" class="headerlink" title="递归和堆栈"></a>递归和堆栈</h4><p>递归是一种编程模式，在一个任务可以自然地拆分成多个相同类型但更简单的任务的情况下非常有用；简单来说，函数会调用自身就是所谓的递归；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个递归例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n == <span class="number">1</span>) ? x : (x * pow(x, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最大的嵌套调用次数（包括首次）被称为递归深度，最大递归深度受限于 JavaScript 引擎；通常，引擎在最大迭代深度为 10000 及以下时是可靠的；</p>
<p>在底层，有关正在运行的函数的执行过程的相关信息被存储在其执行上下文中；执行上下文是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置（代码位置），当前的变量，this 的值，以及其它的一些内部细节；</p>
<p>当一个函数进行嵌套调用时，当前函数被暂停，关联的执行上下文被一个叫做执行上下文堆栈的特殊数据结构保存；然后开始执行嵌套调用，嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数；因此，递归深度等于堆栈中上下文的最大数量；</p>
<blockquote>
<p>Note: 任何递归都可以用循环来重写，通常循环变体更有效，且更节省内存；</p>
</blockquote>
<blockquote>
<p>Tips: 一些引擎支持“尾调用（tail call）”优化：如果递归调用是函数中的最后一个调用，那么外部的函数就不再需要恢复执行，因此引擎也就不再需要记住他的执行上下文；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组转单链表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayToList</span>(<span class="params">arr, index = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; arr.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: arr[index],</span><br><span class="line">      next: arrayToList(arr, index + <span class="number">1</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: arr[index],</span><br><span class="line">      next: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> list = arrayToList(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">  value: 1,</span></span><br><span class="line"><span class="comment">  next: &#123;</span></span><br><span class="line"><span class="comment">    value: 2,</span></span><br><span class="line"><span class="comment">    next: &#123;</span></span><br><span class="line"><span class="comment">      value: 3,</span></span><br><span class="line"><span class="comment">      next: &#123;</span></span><br><span class="line"><span class="comment">        value: 4,</span></span><br><span class="line"><span class="comment">        next: null</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波那契</span></span><br><span class="line"><span class="comment">// 递归版本，受限于递归深度，n 较大时，计算时间很长；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n &gt; <span class="number">1</span> ? Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>) : n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进版本 1，使用数组存储中间计算值，避免重复计算；</span></span><br><span class="line"><span class="keyword">let</span> record = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; record.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> record[n];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (record[n] = Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进版本 2，使用对象存储中间计算值，并用闭包封装；</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> caches = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n <span class="keyword">in</span> caches ? caches[n] : (caches[n] = _fib(n - <span class="number">1</span>) + _fib(n - <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _fib(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进版本 3，使用变量存储前两个值，循环计算，速度最快；</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> lastOne = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> lastTwo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">    [lastTwo, lastOne] = [lastOne, lastOne + lastTwo];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lastOne + lastTwo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Rest-参数与-Spread-语法"><a href="#Rest-参数与-Spread-语法" class="headerlink" title="Rest 参数与 Spread 语法"></a>Rest 参数与 Spread 语法</h4><p>在 JavaScript 中，无论函数是如何定义的，你都可以使用任意数量的参数调用函数，未使用的参数会被函数忽略掉；</p>
<p><strong>Rest 参数</strong></p>
<p>Rest 参数可以通过使用三个点 … 并在后面跟着包含剩余参数的数组名称，来将它们包含在函数定义中，这些点的字面意思是“将剩余参数收集到一个数组中”；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个任意个数参数的累加函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumAll</span>(<span class="params">...args</span>) </span>&#123; <span class="comment">// 数组名为 args</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> args) sum += arg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>Rest</code> 参数必须放到参数列表的末尾，因为放在其他参数前面或中间就失去了其意义；</p>
</blockquote>
<p><strong>“arguments” 变量</strong></p>
<p>函数中还有一个名为 arguments 的特殊的类数组对象，该对象按参数索引包含所有参数；arguments 也是可迭代对象；</p>
<blockquote>
<p>Note: 箭头函数没有 <code>arguments</code> 对象；</p>
</blockquote>
<p><strong>Spread 语法</strong></p>
<p>当在函数调用中使用 spread 语法 …arr 时，它会把可迭代对象 arr “展开”到参数列表中；spread 语法也可以与常规值结合使用；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">8</span>, <span class="number">3</span>, -<span class="number">8</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>, ...arr, <span class="number">2</span>, ...arr2, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">let</span> merged = [<span class="number">0</span>, ...arr, <span class="number">2</span>, ...arr2];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转数组</span></span><br><span class="line">[...<span class="string">&quot;hello&quot;</span>]; <span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新对象或数组</span></span><br><span class="line"><span class="keyword">let</span> objCopy = &#123; ...obj &#125;;</span><br><span class="line"><span class="keyword">let</span> arrCopy = [...arr];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: <code>Spread</code> 语法只适用于可迭代对象；而 <code>Array.from</code> 既可以用于类数组对象也可用于可迭代对象，因此，对于转换为数组的任务，<code>Array.from</code> 往往更通用；</p>
</blockquote>
<blockquote>
<p>Tips: <code>Spread</code> 语法可以实现 <code>Object.assign()</code> 一样的浅拷贝效果，且更简介；</p>
</blockquote>
<!-- Object.assign会调用[[Setter]]，Spread语法不会，待验证 -->

<h4 id="变量作用域，闭包"><a href="#变量作用域，闭包" class="headerlink" title="变量作用域，闭包"></a>变量作用域，闭包</h4><p><strong>变量</strong></p>
<p>如果在代码块 {…} 内声明（使用 let 或 const）了一个变量，那么这个变量只在该代码块内可见；该规则也适用于 if，for 和 while 等，以及函数体中；ES6 之前没有块级作用域；</p>
<p>在 JavaScript 中，每个运行的函数，代码块 {…} 以及整个脚本，都有一个被称为词法环境（Lexical Environment） 的内部（隐藏）的关联对象；</p>
<p>其中，词法环境对象由两部分组成：一个存储所有局部变量作为其属性（包括一些其他信息，如 this 的值）的对象，也称为环境记录（Environment Record）；另一个是对外部词法环境的引用，与外部代码相关联；全局词法环境没有外部引用（其引用为 null）；</p>
<blockquote>
<p>Note: “词法环境”是一个规范对象（specification object）：它仅仅是存在于编程语言规范中的“理论上”存在的，用于描述事物如何运作的对象，无法在代码中获取该对象并直接对其进行操作；</p>
</blockquote>
<blockquote>
<p>Note: 一个“变量”只是环境记录这个特殊的内部对象的一个属性；“获取或修改变量”意味着“获取或修改词法环境的一个属性”；</p>
</blockquote>
<blockquote>
<p>Environment Record is an abstract class with three concrete subclasses: declarative Environment Record, object Environment Record, and global Environment Record. Function Environment Records and module Environment Records are subclasses of declarative Environment Record.<br>Every Environment Record has an [[OuterEnv]] field, which is either null or a reference to an outer Environment Record.<br>A var statement declares variables that are scoped to the running execution context’s VariableEnvironment. Within the scope of any VariableEnvironment a common BindingIdentifier may appear in more than one VariableDeclaration but those declarations collectively define only one variable.</p>
</blockquote>
<blockquote>
<p>A function Environment Record is a declarative Environment Record that is used to represent the top-level scope of a function and, if the function is not an ArrowFunction, provides a this binding. [[ThisBindingStatus]] filed value should be lexical, initialized, or uninitialized, If the value is lexical, this is an ArrowFunction and does not have a local this value.</p>
</blockquote>
<blockquote>
<p>The value of the Function component of the running execution context is also called the <code>active function object</code>.</p>
</blockquote>
<blockquote>
<p>The LexicalEnvironment and VariableEnvironment components of an execution context are always Environment Records.</p>
</blockquote>
<p>执行上下文主要包括，Realm、code evaluation state、Function、ScriptOrModule 和词法环境、变量环境（var 关键字声明的变量）、私有环境（包含 class 私有变量）；</p>
<p><strong>函数声明</strong></p>
<p>函数其实也是一个值，就像变量一样，不同之处在于函数声明的初始化会被立即完成（函数声明提升），当创建了一个词法环境时，函数声明会立即变为即用型函数，因此可以在（函数声明）的定义之前调用函数声明；正常来说，这种行为仅适用于函数声明，而不适用于将函数分配给变量的函数表达式；</p>
<p><strong>内部和外部词法环境</strong></p>
<p>当代码要访问一个变量时首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境；这也是内部变量覆盖外部同名变量的原因；</p>
<p>如果在任何地方都找不到这个变量，那么在严格模式下就会报错，在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量；</p>
<p>函数将从内到外依次在对应的词法环境中寻找目标变量，它使用最新的值；旧变量值不会保存在任何地方；当一个函数想要一个变量时，它会从自己的词法环境或外部词法环境中获取当前值；</p>
<p><strong>返回函数</strong></p>
<p>所有的函数在“诞生”时都会记住创建它们的词法环境，从技术上讲，所有函数都有名为 [[Environment]] 的隐藏属性，该属性保存了对创建该函数的词法环境的引用；</p>
<blockquote>
<p>Tips: 函数记住它创建于何处的方式，与函数被在哪儿调用无关；<code>[[Environment]]</code> 引用在函数创建时被设置并永久保存，并且不会改变；只有遇到调用函数时，函数词法环境才会被创建，这也是函数中 this 是动态绑定的原因；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解释阶段</span></span><br><span class="line"><span class="comment">// 1. 脚本开始执行，创建全局执行上下文；</span></span><br><span class="line"><span class="comment">// 2. 创建一个全局词法环境填充所有（let、const、function）声明的变量（未初始化）以及函数；</span></span><br><span class="line"><span class="comment">// 3. 创建一个全局变量环境，填充所有 var 关键字定义的变量，并初始化为 undefined</span></span><br><span class="line"><span class="comment">// 4. 将外部环境置为 null；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line"><span class="comment">// 5. 此时，先定义 counter，值为 undefined；</span></span><br><span class="line"><span class="comment">// 6. 然后执行 makeCounter 后，为 counter 赋值；</span></span><br><span class="line"><span class="keyword">let</span> counter = makeCounter();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 创建新的执行上下文函数，创建函数的词法环境，并存储这个调用的局部变量和参数；</span></span><br><span class="line"><span class="comment">// 8. 同时将外部环境指向全局词法环境；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. 返回时，创建一个嵌套函数，并将嵌套函数的外部词法环境指向 makeCounter；</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 11. 执行 count++ 时，从自身词法环境中查找 count，然后查找 makeCounter 词法环境中的变量，完成修改后返回；</span></span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 执行 counter 函数，创建一个新的词法环境，并从 [[Environment]] 中获取其外部词法环境引用；</span></span><br><span class="line">counter();</span><br></pre></td></tr></table></figure>

<p>闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后；</p>
<blockquote>
<p>Note: 在 JavaScript 中，所有函数都是天生闭包的（除 “new Function” 语法）；也就是说：JavaScript 中的函数会自动通过隐藏的 <code>[[Environment]]</code> 属性记住创建它们的位置，所以它们都可以访问外部变量；</p>
</blockquote>
<p>通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除，但当有一个嵌套函数在外部函数结束后仍可达，则它将具有引用词法环境的 [[Environment]] 属性；因此词法环境仍会被保留在内存；</p>
<p><strong>实践</strong></p>
<blockquote>
<p>Note: 理论上当函数可达时，它外部的所有变量也都将存在；但在实际中，JavaScript 引擎会试图优化它，它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除；</p>
</blockquote>
<blockquote>
<p>Note: 在 <code>V8</code>（Chrome，Edge，Opera）中的一个重要的副作用是，此类变量在调试中将不可用（未定义），或者得到一个同名的外部变量；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “不存在”的变量和“未初始化”的变量之间的特殊差异</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一个变量从技术的角度来讲是存在的，但是在 let 之前还不能使用，该区域也称死区</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError: Cannot access &#x27;x&#x27; before initialization</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>AO</code> 类似于是函数被调用时创建的一个特殊 <code>VO</code>，它在 <code>VO</code> 的基础上添加了实际调用函数时传入的参数和 <code>arguments</code> 对象，还有添加 <code>this</code> 对象；<code>VO</code> 和 <code>AO</code> 被创建时会先后执行著名的函数声明提升和变量声明提升，提升上来的变量和函数挂载到 <code>VO / AO</code> 对象的上，其实是作为它的属性存在的；</p>
</blockquote>
<blockquote>
<p>Tips: 在调试函数时，<code>Scope</code> 的最上层是 <code>Local</code>，也就是当前执行上下文的变量对象，下面就是函数的<code>[[Scopes]]</code> 属性里保存的父级层级链；点击 <code>Call Stack</code> 栏中的函数，还可以切换当前执行上下文，观察下面 <code>Scope</code> 的变化；</p>
</blockquote>
<blockquote>
<p>Tips: 使用 <code>console.dir</code> 可以打印出函数的 <code>length</code>、<code>name</code>，甚至作用域链 [[Scopes]] 等隐藏属性；严格模式下无法获取 <code>caller</code>，<code>callee</code>，<code>arguments</code> 等属性；</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/closure">JavaScript 现代教程-变量作用域，闭包文档</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904050824052744">深入 js——作用域链</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/51336888">JS 规范中的 Execution Context 和 Scope 概念有什么区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/311196297">了解 JS 中的ECStack、EC、VO 和 AO</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904145372053511">JS夯实之执行上下文与词法环境</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12599965/lexical-environment-and-function-scope">Lexical environment and function scope</a></li>
<li><a target="_blank" rel="noopener" href="https://tc39.es/ecma262/#sec-executable-code-and-execution-contexts">Executable Code and Execution Contexts</a></li>
</ul>
<h4 id="旧时的-var"><a href="#旧时的-var" class="headerlink" title="旧时的 var"></a>旧时的 var</h4><p>在 JavaScript 中，有三种声明变量的方式：let，const（现代方式），var（过去留下来的方式）；</p>
<p><strong>var 没有块级作用域</strong></p>
<p>用 var 声明的变量，不是函数作用域就是全局作用域；它们在代码块外也是可见的也就是说，var 声明的变量只有函数作用域和全局作用域，没有块级作用域；</p>
<p>这就导致 if 语句或循环语句外可以访问在 {…} 中使用 var 定义的变量；var 穿透了 if，for 和其它代码块，这是因为在早期的 JavaScript 中，块没有词法环境，而 var 就是这个时期的代表之一；</p>
<p><strong>var 允许重新声明</strong></p>
<p>使用 var，可以重复声明一个变量，不管多少次都行；如果对一个已经声明的变量使用 var，这条新的声明语句会被忽略：</p>
<p><strong>var 提升变量声明</strong></p>
<p>var 声明的变量会在函数开头被定义，与它在代码中定义的位置无关；声明被提升，但是赋值不会；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// phrase 实际声明处</span></span><br><span class="line"></span><br><span class="line">  alert(phrase); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// phrase 赋值</span></span><br><span class="line">  phrase = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代码块会被忽略，phrase 仍然会被声明</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> phrase;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure>

<p><strong>立即执行函数</strong></p>
<p>在之前，JavaScript 中只有 var 这一种声明变量的方式，并且这种方式声明的变量没有块级作用域，于是就有了一种模仿块级作用域的方法，这种方法被称为“立即调用函数表达式”（immediately-invoked function expressions，IIFE）；</p>
<p>通常需要使用圆括号把该函数表达式包起来，以告诉 JavaScript，这个函数是在另一个表达式的上下文中创建的，因此它是一个函数表达式：它不需要函数名，可以立即调用；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 IIFE 的方法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Parentheses around the function&quot;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Parentheses around the whole thing&quot;</span>);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Bitwise NOT operator starts the expression&quot;</span>);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Unary plus starts the expression&quot;</span>);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">~(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Unary plus starts the expression&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h4><p>全局对象提供可在任何地方使用的变量和函数，且其所有属性都可以被直接访问；默认情况下，这些全局变量内建于语言或环境中；在浏览器中，它的名字是 “window”，对 Node.js 而言，它的名字是 “global”，其它环境可能用的是别的名字；</p>
<blockquote>
<p>Tips: 最近，<code>globalThis</code> 被作为全局对象的标准名称加入到了 JavaScript 中，所有环境都应该支持该名称，所有主流浏览器都支持它；</p>
</blockquote>
<blockquote>
<p>Note: 在浏览器中，使用 <code>var</code> 声明的全局函数和变量会成为全局对象的属性；</p>
</blockquote>
<p>如果一个值非常重要，且需要在全局范围内可用，可以直接将其作为属性写入；但一般不建议使用全局变量，全局变量应尽可能的少；与使用外部变量或全局变量相比，函数获取“输入”变量并产生特定“输出”的代码设计更加清晰，不易出错且更易于测试；</p>
<p>另外，一般还使用全局对象来测试对现代语言功能的支持；对于没有某些现代功能的旧版浏览器，可以创建 “polyfills”：添加环境不支持但在现代标准中存在的功能；</p>
<h4 id="函数对象，NFE"><a href="#函数对象，NFE" class="headerlink" title="函数对象，NFE"></a>函数对象，NFE</h4><p>在 JavaScript 中，函数就是对象，可以把函数理解成可被调用的“行为对象（action object）”；我们不仅可以调用它们，还能把它们当作对象来处理：增/删属性，按引用传递等；</p>
<p><strong>name 属性</strong></p>
<p>一个函数的名字可以通过属性 “name” 来访问；名称赋值的逻辑很智能，即使是函数表达式，被创建时没有名字，名称赋值的逻辑也能给它赋予一个正确的名字，然后进行赋值；</p>
<blockquote>
<p>Note: 规范中把这种特性叫做上下文命名，如果函数自己没有提供，那么在赋值中，会根据上下文来推测一个；但当 JavaScript 引擎无法推测名字时，属性 name 就会是空；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">alert(sayHi.name); <span class="comment">// sayHi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象中的方法也有 name 属性</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">alert(user.sayHi.name); <span class="comment">// sayHi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组中创建的匿名函数没有名称</span></span><br><span class="line"><span class="keyword">let</span> funcArr = [<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引擎无法设置正确的名字，所以没有值</span></span><br><span class="line"><span class="built_in">console</span>.warn(funcArr[<span class="number">0</span>].name); <span class="comment">// &lt;空字符串&gt;</span></span><br><span class="line"><span class="built_in">console</span>.warn(funcArr[<span class="number">1</span>].name); <span class="comment">// func</span></span><br></pre></td></tr></table></figure>

<p><strong>length 属性</strong></p>
<p>length 是函数的另一个内建属性，它返回函数入参的个数；</p>
<blockquote>
<p>Tips: rest 参数不参与计数，属性 length 有时在操作其它函数的函数中用于做内省/运行时检查（introspection）；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据函数参数个数的不同做不同处理，也属于多态的一种</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">...handlers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> handler <span class="keyword">of</span> handlers) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(handler.length); <span class="comment">// 1 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handler(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="function">(<span class="params">param</span>) =&gt;</span> param, <span class="function">(<span class="params">...rest</span>) =&gt;</span> rest);</span><br></pre></td></tr></table></figure>

<p><strong>自定义属性</strong></p>
<p>在函数内可以使用函数名为函数添加自定义的属性；可以函数当作对象，在函数里存储属性，这对函数的执行没有任何影响；但变量不是函数属性，反之亦然；</p>
<blockquote>
<p>Tips: 函数属性有时会用来替代闭包；区别在于，闭包的属性外部无法访问；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counter.count++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  counter.count = <span class="number">0</span>;</span><br><span class="line">  counter.set = <span class="function"><span class="params">value</span> =&gt;</span> count = value;</span><br><span class="line">  counter.decrease = <span class="function">() =&gt;</span> count--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = makeCounter();</span><br><span class="line">alert( counter() ); <span class="comment">// 0</span></span><br><span class="line">alert( counter() ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>命名函数表达式</strong></p>
<p>命名函数表达式（NFE，Named Function Expression），指带有名字的函数表达式的术语；但它仍是一个函数表达式，不会成为一个函数声明；NFE 在函数内部可以应用自己，且该函数名在函数外部不可见；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (who) &#123;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    func(<span class="string">&quot;Guest&quot;</span>); <span class="comment">// 使用 func 再次调用函数自身</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sayHi(); <span class="comment">// Hello, Guest</span></span><br><span class="line">func(); <span class="comment">// Error, func is not defined（在函数外不可见）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>jQuery，lodash 等很多 JavaScript 库都充分利用了这个功能，实际上，这么做是为了减少对全局空间的污染，这样一个库就只会有一个全局变量，也降低了命名冲突的可能性；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意数量的括号求和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  sum.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _add.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.count;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_add</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    sum.count += p;</span><br><span class="line">    <span class="keyword">return</span> _add;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _add(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 升级版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function">(<span class="params">b</span>) =&gt;</span> sum(a + b);</span><br><span class="line">  next.valueOf = <span class="function">() =&gt;</span> a;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="new-Function-语法"><a href="#new-Function-语法" class="headerlink" title="new Function 语法"></a>new Function 语法</h4><p>还有一种很少见的函数创建方法；使用 Function 创建函数：<code>new Function ([arg1, arg2, ...argN], functionBody);</code>，由于历史原因，参数也可以按逗号分隔符的形式给出，这种方法实际上是通过运行时通过参数传递过来的字符串创建的；</p>
<p>另外，如果使用 new Function 创建一个函数，那么该函数的 [[Environment]] 并不指向当前的词法环境，而是指向全局环境；</p>
<h4 id="调度：setTimeout-和-setInterval"><a href="#调度：setTimeout-和-setInterval" class="headerlink" title="调度：setTimeout 和 setInterval"></a>调度：setTimeout 和 setInterval</h4><blockquote>
<p>Note: 这两个方法并不在 JavaScript 的规范中，但是大多数运行环境都有内建的调度程序，并且提供了这些方法；目前来讲，所有浏览器以及 Node.js 都支持这两个方法；</p>
</blockquote>
<p><strong>setTimeout</strong></p>
<p>setTimeout 允许我们将函数推迟到一段时间间隔之后再执行；<code>let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)</code>，setTimeout 在调用时会返回一个“定时器标识符（timer identifier）”，可以将它传入 clearTimeout 方法来取消执行；</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">func|code</td>
<td align="left">要执行的函数或代码字符串，一般传入的都是函数；由于历史原因，支持传入代码字符串</td>
</tr>
<tr>
<td align="left">delay</td>
<td align="left">执行前的延时，以毫秒为单位，默认值是 0</td>
</tr>
<tr>
<td align="left">arg1，arg2…</td>
<td align="left">要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">phrase, who</span>) </span>&#123;</span><br><span class="line">  alert( phrase + <span class="string">&#x27;, &#x27;</span> + who );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(sayHi, <span class="number">1000</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;John&quot;</span>); <span class="comment">// Hello, John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果第一个参数位传入的是字符串，JavaScript 会自动为其创建一个函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>, <span class="number">1000</span>); <span class="comment">// 不建议使用，可用箭头函数代替</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定时器</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timerId);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 在浏览器中，定时器标识符是一个数字；在 <code>Node.js</code> 中返回的是一个定时器对象，这个对象包含一系列方法；</p>
</blockquote>
<blockquote>
<p>Tips: <code>setTimeout</code> 有一个特殊用法：<code>setTimeout(func, 0)</code>，或者仅仅是 <code>setTimeout(func)</code>；这样调度可以让 <code>func</code> 尽快执行，该函数被调度在当前脚本执行完成“之后”立即执行；</p>
</blockquote>
<blockquote>
<p>Note: 浏览器环境下，零延时实际上不为零，嵌套定时器的运行频率是受限制的；根据 HTML5 标准 所讲：“经过 <code>5</code> 重嵌套定时器之后，时间间隔被强制设定为至少 <code>4</code> 毫秒”；</p>
</blockquote>
<p><strong>setInterval</strong></p>
<p>setInterval 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数；该方法与 setTimeout 用法相同，所有参数的意义也相同；使用 clearInterval(timerId) 方法清除；</p>
<blockquote>
<p>Note: 在大多数浏览器中，包括 Chrome 和 Firefox，在显示 <code>alert/confirm/prompt</code> 弹窗时，内部的定时器仍旧会继续“嘀嗒”；因此如果未及时关闭弹窗，可能会出现关闭弹窗后立即弹出新的弹窗；</p>
</blockquote>
<p>使用 setInterval 时，函数的实际调用间隔要比代码中设定的时间间隔要短；极端情况下，如果函数执行时间远大于预设时间间隔段时，JavaScript 引擎会等待函数执行完成，然后检查调度程序之后，立即再次执行函数；</p>
<blockquote>
<p>Tips: 相较而言，嵌套的 <code>setTimeout</code> 能够精确地设置两次执行之间的延时，而 <code>setInterval</code> 却不能；并且嵌套的 <code>setTimeout</code> 要比 <code>setInterval</code> 灵活得多；采用这种方式可以根据当前执行结果来调度下一次调用，因此下一次调用可以与当前这一次不同；</p>
</blockquote>
<blockquote>
<p>Tips: 当一个函数传入 <code>setInterval/setTimeout</code> 时，将为其创建一个内部引用，并保存在调度程序中；这样，即使这个函数没有其他引用，也能防止垃圾回收器（GC）将其回收；同时该函数引用的外部变量也会被保留，因此，当我们不再需要调度函数时，最好取消它，即使这是个（占用内存）很小的函数；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任何 setTimeout 都只会在当前代码执行完毕之后才会执行</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> alert(i), <span class="number">100</span>); <span class="comment">// 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这段代码的运行时间 &gt;100ms</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">100000000</span>; j++) &#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>setTimeout()</code> 和 <code>setInterval()</code> 共用一个编号池，技术上，<code>clearTimeout()</code> 和 <code>clearInterval()</code> 可以互换；但是，为了避免混淆，不要混用取消定时函数；</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout">window.setTimeout MDN 中文参考文档</a></li>
</ul>
<h4 id="装饰器模式和转发，call-apply"><a href="#装饰器模式和转发，call-apply" class="headerlink" title="装饰器模式和转发，call/apply"></a>装饰器模式和转发，call/apply</h4><p><strong>装饰器</strong></p>
<p>装饰器（decorator）：一个特殊的函数，可以被看作是可以添加到函数的 “features” 或 “aspects”，可以添加一个或添加多个装饰器；装饰器是可重用的，逻辑独立的；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里可能会有重负载的 CPU 密集型工作</span></span><br><span class="line">  alert(<span class="string">`Called with <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.has(x)) &#123;    <span class="comment">// 如果缓存中有对应的结果</span></span><br><span class="line">      <span class="keyword">return</span> cache.get(x); <span class="comment">// 从缓存中读取结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let result = func(x);</span></span><br><span class="line">    <span class="keyword">let</span> result = func.call(<span class="built_in">this</span>, x);  <span class="comment">// 否则就调用 func</span></span><br><span class="line"></span><br><span class="line">    cache.set(x, result);  <span class="comment">// 然后将结果缓存（记住）下来</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newSlow = cachingDecorator(slow);</span><br></pre></td></tr></table></figure>

<p>特殊的内建函数方法 func.call(context, arg1, arg2, …)，它允许调用一个显式设置 this 的函数；另一个内建方法 func.apply(context, args)，它与 func.call 区别在第二个参数使用类数组对象 args 作为参数列表（arguments）；</p>
<blockquote>
<p>Note: <code>func.call</code> 在 <code>func</code> 函数运行时使用的 <code>this</code> 值可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 <code>null</code> 或 <code>undefined</code>（缺省时） 时会自动替换为指向全局对象，原始值会被包装；</p>
</blockquote>
<blockquote>
<p>Note: <code>Spread</code> 语法 <code>...</code> 允许将可迭代对象 <code>args</code> 作为列表传递给 <code>func.call</code>，而 <code>func.apply</code> 只接受类数组 <code>args</code>；</p>
</blockquote>
<blockquote>
<p>Tips: 即可迭代又是类数组的对象，使用 call 或 apply 均可，但是 apply 可能会更快，因为大多数 JavaScript 引擎在内部对其进行了优化；</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">Function.prototype.call MDN 中文参考文档</a></li>
</ul>
<p><strong>呼叫转移</strong></p>
<p>将所有参数连同上下文一起传递给另一个函数被称为“呼叫转移（call forwarding）”；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个呼叫转移的最简单形式</span></span><br><span class="line"><span class="keyword">let</span> wrapper = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方法借用</strong></p>
<p>方法借用（method borrowing）：从一个对象中获取一个方法，并在另一个对象的上下文中“调用”它；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( [].join.call(<span class="built_in">arguments</span>) ); <span class="comment">// 1,2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hash(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 采用数组方法并将它们应用于参数 <code>arguments</code> 是很常见的，另一种方法是使用 Rest 参数对象，该对象是一个真正的数组；</p>
</blockquote>
<p><strong>防抖和节流</strong></p>
<p>debounce 会在“冷却（cooldown）”期后运行函数一次，适用于处理最终结果；throttle 运行函数的频率不会大于所给定的时间 ms 毫秒，适用于不应该经常进行的定期更新；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 刷新计时器</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>), ms);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="keyword">return</span>; <span class="comment">// 忽略执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h4><p>浏览器中的 setTimeout 方法有些特殊：它为函数调用设定了 this=window（对于 Node.js，this 则会变为计时器（timer）对象；即使是在严格模式下，setTimeout() 的回调函数里面的 this 仍然默认指向 window 对象，并不是 undefined；</p>
<p>函数提供了一个内建方法 bind，可以绑定 this；func.bind(context) 的结果是一个特殊的类似于函数的“外来对象（exotic object）”，它可以像函数一样被调用，并且透明地（transparently）将调用传递给 func 并设定 this=context；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在没有对象（译注：与对象分离）的情况下运行它</span></span><br><span class="line">sayHi(); <span class="comment">// Hello, John!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还是会使用预先绑定（pre-bound）的值，该值是对旧的 user 对象的引用</span></span><br><span class="line"><span class="built_in">setTimeout</span>(user.sayHi.bind(user), <span class="number">1000</span>); <span class="comment">// Hello, John!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用了最新的 sayHi 方法；</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> user.sayHi(), <span class="number">1000</span>); <span class="comment">// Another user in setTimeout!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user 的值在不到 1 秒内发生了改变</span></span><br><span class="line">user = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; alert(<span class="string">&quot;Another user in setTimeout!&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 如果一个对象有很多方法，并且我们都打算将它们都传递出去，那么我们可以在一个循环中完成所有方法的绑定；或者也可以使用 lodash 中的 <code>_.bindAll(object, methodNames)</code> 方法；</p>
</blockquote>
<p>此外，func.bind(context, [arg1], [arg2], …) 不仅可以绑定 this，还可以绑定参数（arguments）；可以通过绑定先有函数的一些参数来创建一个新函数，被称为偏函数应用程序（partial function application）；</p>
<p>使用偏函数可以创建一个具有可读性高的名字（double，triple）的独立函数；另一方面，当我们有一个非常通用的函数，并希望有一个通用型更低的该函数的变体时，偏函数会非常有用；lodash 库有现成的 _.partial 实现；</p>
<blockquote>
<p>Note: 绑定函数的上下文是硬绑定（hard-fixed）的，无法再修改它；因此被绑定函数内部的 this 指向，或者对象的属性值会被固定，即会使用预先绑定（pre-bound）的值；</p>
</blockquote>
<blockquote>
<p>Note: 一个函数不能被重绑定（re-bound），二次绑定的值无效；在非严格模式下，ES5 标准会将值为 <code>null</code> 或 <code>undefined</code> 的 <code>this</code> 绑定到全局对象，也就是 <code>this=window</code>；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个偏函数的例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> double = mul.bind(<span class="literal">null</span>, <span class="number">2</span>); <span class="comment">// 第一个参数必填</span></span><br><span class="line">double(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏函数装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">func, ...argsBound</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用时，获取当前 this，即不关心绑定对象；</span></span><br><span class="line">    <span class="keyword">return</span> func.call(<span class="built_in">this</span>, ...argsBound, ...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = f.bind( &#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125; ).bind( &#123;<span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125; );</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<h4 id="深入理解箭头函数"><a href="#深入理解箭头函数" class="headerlink" title="深入理解箭头函数"></a>深入理解箭头函数</h4><p>箭头函数是针对那些没有自己的“上下文”，但在当前上下文中起作用的短代码的；箭头函数具有以下特点：</p>
<ul>
<li>没有 this；</li>
<li>没有 arguments；</li>
<li>不能使用 new 进行调用；</li>
<li>也没有 super；</li>
</ul>
<blockquote>
<p>Note: 箭头函数不具有 <code>this</code> 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor），因此不能用 <code>new</code> 调用它们；</p>
</blockquote>
<blockquote>
<p>Note: 箭头函数 <code>=&gt;</code> 没有创建任何绑定，箭头函数只是没有 <code>this</code>；<code>this</code> 的查找与常规变量的搜索方式完全相同：在外部词法环境中查找；ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数；箭头函数内部的 this 会指向声明箭头函数时所在作用域的 this；</p>
</blockquote>
<blockquote>
<p>Note: In modules, like <code>&lt;script type=&quot;module&quot;&gt;</code> or <code>node</code>, the value of <code>this</code> is always <code>undefined</code> in the global context. Modules are implicitly in <code>strict mode</code>.</p>
</blockquote>
<p><strong>this 绑定</strong></p>
<p>在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定），this 不能在执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同；在不同情况下，this 值的表现有所不同；</p>
<blockquote>
<p>A regular declarative Environment Record (i.e., one that is neither a function Environment Record nor a module Environment Record) does not provide a this binding.<br>Function Environment Records if envRec.[[ThisBindingStatus]] is not lexical, then Return envRec.[[ThisValue]].<br>Object Environment Records do not provide a this binding.<br>Module Environment Records always provide a this binding.<br>Global Environment Record Return envRec.[[GlobalThisValue]].</p>
</blockquote>
<p>规范环境记录中的 this：</p>
<ol>
<li>全局环境记录，返回 envRec.[[GlobalThisValue]]；</li>
<li>对象环境记录，没有 this；</li>
<li>声明环境记录，<ul>
<li>常规声明环境记录，没有 this；</li>
<li>函数环境记录，非箭头函数返回 envRec.[[ThisValue]]；</li>
<li>模块环境记录，返回 undefined；</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">环境</th>
<th align="left">非严格模式</th>
<th align="left">严格模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">全局上下文</td>
<td align="left">全局对象</td>
<td align="left">全局对象</td>
</tr>
<tr>
<td align="left">函数上下文</td>
<td align="left">全局对象</td>
<td align="left">undefined</td>
</tr>
<tr>
<td align="left">对象上下文</td>
<td align="left">调用的对象</td>
<td align="left">调用的对象</td>
</tr>
<tr>
<td align="left">模块上下文</td>
<td align="left">自动开启严格模式</td>
<td align="left">在浏览器端 ES6 模块（<code>&lt;script type=&quot;module&quot;&gt;</code>）中为 undefined，在 Node CommonJS 模块中为当前模块</td>
</tr>
<tr>
<td align="left">bind, call, apply</td>
<td align="left">传入的 thisArg，非对象 thisArg 会被转为对象</td>
<td align="left">传入的 thisArg，不会进行对象转换</td>
</tr>
<tr>
<td align="left">箭头函数</td>
<td align="left">从创建的执行上下文获取，顶级为全局变量</td>
<td align="left">从创建的执行上下文获取，顶级为 undefined</td>
</tr>
<tr>
<td align="left">eval</td>
<td align="left">直接调用同箭头函数；间接调用为全局对象</td>
<td align="left">直接调用同箭头函数，间接调用为全局对象</td>
</tr>
<tr>
<td align="left">setTimeout, setInterval</td>
<td align="left">将普通函数的 this 绑定为 window 或 Timeout 对象</td>
<td align="left">同非严格模式</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局环境中</span></span><br><span class="line"><span class="comment">// 无论是否在严格模式下，在任何函数体外部的 this 都指向全局对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === globalThis); <span class="comment">// true</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;<span class="built_in">console</span>.log(<span class="built_in">this</span> === globalThis); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数环境中，this 的值取决于函数被调用的方式</span></span><br><span class="line"><span class="comment">// 1. 直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window / global</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;<span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"><span class="comment">// 2. 作为对象方法调用，无关严格模式与否</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.say(); <span class="comment">// user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数绑定和转移 bind, call, apply</span></span><br><span class="line"><span class="comment">// 如果 thisArg 不是对象，则会被尝试转换为对象；null 和 undefined 被转换为全局对象；</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span> &#125;;</span><br><span class="line">user.say.bind()(); <span class="comment">// window / global</span></span><br><span class="line">user.say.bind(<span class="literal">null</span>)(); <span class="comment">// window / global</span></span><br><span class="line">user.say.bind(<span class="string">&quot;str&quot;</span>)(); <span class="comment">// String &#123;&#x27;str&#x27;&#125; / [String: &#x27;str&#x27;]</span></span><br><span class="line">user.say.bind(obj); <span class="comment">// &#123; name: &quot;obj&quot; &#125;</span></span><br><span class="line">user.say.call(); <span class="comment">// window / global</span></span><br><span class="line">user.say.call(<span class="literal">null</span>); <span class="comment">// window / global</span></span><br><span class="line">user.say.call(<span class="number">1234</span>); <span class="comment">// Number &#123;1234&#125; / [Number: 1234]</span></span><br><span class="line">user.say.call(obj); <span class="comment">// &#123; name: &quot;obj&quot; &#125;</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">user.say.bind()(); <span class="comment">// undefined</span></span><br><span class="line">user.say.bind(<span class="literal">null</span>)(); <span class="comment">// null</span></span><br><span class="line">user.say.bind(<span class="string">&quot;str&quot;</span>)(); <span class="comment">// str</span></span><br><span class="line">user.say.bind(obj); <span class="comment">// &#123; name: &quot;obj&quot; &#125;</span></span><br><span class="line">user.say.call(); <span class="comment">// undefined</span></span><br><span class="line">user.say.call(<span class="literal">null</span>); <span class="comment">// null</span></span><br><span class="line">user.say.call(<span class="number">1234</span>); <span class="comment">// 1234</span></span><br><span class="line">user.say.call(obj); <span class="comment">// &#123; name: &quot;obj&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数中</span></span><br><span class="line"><span class="comment">// this 与封闭词法环境的 this 保持一致；在全局代码中，它将被设置为全局对象；</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;</span><br><span class="line"><span class="comment">// return by function</span></span><br><span class="line"><span class="keyword">let</span> returnFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// inside function</span></span><br><span class="line"><span class="keyword">let</span> outerFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _f = <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;;</span><br><span class="line">  _f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// inside object</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  myFun: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCls</span></span>&#123;</span><br><span class="line">  arrow = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span> === MyCls, <span class="built_in">this</span> <span class="keyword">instanceof</span> MyCls)</span><br><span class="line">  <span class="keyword">static</span> staticArrow = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span> === MyCls, <span class="built_in">this</span> <span class="keyword">instanceof</span> MyCls)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// window / global</span></span><br><span class="line">returnFunc()(); <span class="comment">// window / global</span></span><br><span class="line">outerFunc(); <span class="comment">// window / global</span></span><br><span class="line">obj.myFun(); <span class="comment">// window / global</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">fn(); <span class="comment">// window / global</span></span><br><span class="line">returnFunc()(); <span class="comment">// undefined</span></span><br><span class="line">outerFunc(); <span class="comment">// undefined</span></span><br><span class="line">obj.myFun(); <span class="comment">// window / global</span></span><br><span class="line"><span class="comment">// class auto use strict mode</span></span><br><span class="line"><span class="keyword">new</span> MyCls().arrow(); <span class="comment">// false true (instance)</span></span><br><span class="line">MyCls.staticArrow(); <span class="comment">// true false (MyCls)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eval</span></span><br><span class="line"><span class="comment">// 1. 直接调用，eval 代码段中的 this 取决于当前执行上下文</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line">(<span class="built_in">eval</span>)(<span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;!(() =&gt; &#123;console.log(this)&#125;)()&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;!function() &#123;console.log(this)&#125;()&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evalOuter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&quot;console.log(this)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">evalOuter(); <span class="comment">// window / global</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  evalOuter,</span><br><span class="line">&#125;;</span><br><span class="line">obj.evalOuter(); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 其余例子结果相同，略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evalOuter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&quot;console.log(this)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">evalOuter(); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  evalOuter,</span><br><span class="line">&#125;;</span><br><span class="line">obj.evalOuter(); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 间接调用，eval 代码段中的 this 指向全局执行上下文，严格模式同</span></span><br><span class="line"><span class="built_in">eval</span>?.(<span class="string">&quot;console.log(this)&quot;</span>) <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">window</span>.eval(<span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// window</span></span><br><span class="line"><span class="built_in">global</span>.eval(<span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// global</span></span><br><span class="line"><span class="built_in">eval</span>.call(<span class="literal">null</span>, <span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">eval</span>.bind(<span class="literal">null</span>, <span class="string">&quot;console.log(this)&quot;</span>)(); <span class="comment">// window / global</span></span><br><span class="line"><span class="keyword">let</span> originalEval = <span class="function">(<span class="params">code</span>) =&gt;</span> <span class="built_in">eval</span>(code);</span><br><span class="line">originalEval(<span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout, setInterval</span></span><br><span class="line"><span class="comment">// 将传入的普通函数 this 设为全局对象，对箭头函数或 bind 生成的函数无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arrowFunc = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  arrowFunc : <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(func, <span class="number">100</span>); <span class="comment">// window / Timeout</span></span><br><span class="line"><span class="built_in">setTimeout</span>(arrowFunc, <span class="number">100</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.func, <span class="number">100</span>); <span class="comment">// window / Timeout</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.arrowFunc, <span class="number">100</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;func(); obj.func()&#125;, <span class="number">100</span>); <span class="comment">// window + obj / global</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;arrowFunc(); obj.arrowFunc();&#125;, <span class="number">100</span>); <span class="comment">// window + window / global + global</span></span><br><span class="line"><span class="built_in">setTimeout</span>(func.bind(<span class="literal">null</span>), <span class="number">100</span>); <span class="comment">// window + window / global + global</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;func(); obj.func()&#125;, <span class="number">100</span>); <span class="comment">// undefined + obj / undefined + obj</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;arrowFunc(); obj.arrowFunc();&#125;, <span class="number">100</span>); <span class="comment">// window + window / global + global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用丢失</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">refFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="function">(<span class="params">f</span>) =&gt;</span> f();</span><br><span class="line"><span class="keyword">const</span> h = obj.refFunc;</span><br><span class="line"><span class="keyword">const</span> j = <span class="function">() =&gt;</span> obj.refFunc;</span><br><span class="line">g(obj.refFunc); <span class="comment">// No base ref.</span></span><br><span class="line">h(); <span class="comment">// No base ref.</span></span><br><span class="line">j()(); <span class="comment">// No base ref.</span></span><br><span class="line">(<span class="number">0</span>, obj.refFunc)(); <span class="comment">// Another common pattern to remove the base ref.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57204184">ES6 箭头函数的 this 指向详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/59be0fc4f4a6">箭头函数和 this 指向</a></li>
<li><a target="_blank" rel="noopener" href="https://cnblogs.com/jeodeng/p/10658590.html">浅谈箭头函数和 setTimeout 中的 this</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html">JavaScript 的 this 原理</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work?rq=1">How does the “this” keyword work?</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">this MDN 中文参考文档</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval">eval() MDN 中文参考文档</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout">window.setTimeout MDN 中文参考文档</a></li>
</ul>
<h4 id="属性标志和属性描述符"><a href="#属性标志和属性描述符" class="headerlink" title="属性标志和属性描述符"></a>属性标志和属性描述符</h4><p>对象属性（properties），除 value 外，还有三个特殊的特性（attributes），也就是所谓的“标志”；默认都为 true；</p>
<ul>
<li>writable 表示是否值可以被修改；</li>
<li>enumerable 表示是否会被在循环中列出；</li>
<li>configurable 表示是否此特性可以被删除，这些属性也可以被修改；</li>
</ul>
<p><strong>writable</strong></p>
<p>通过更改 writable 标志来把对象属性设置为只读，不能被重新赋值；</p>
<blockquote>
<p>Note: 在非严格模式下，在对不可写的属性等进行写入操作时，不会出现错误，但是操作仍然不会成功；因为在非严格模式下，违反标志的行为（flag-violating action）只会被默默地忽略掉；</p>
</blockquote>
<p><strong>enumerable</strong></p>
<p>通过更改 enumerable 标志来把对象属性设置为不可枚举，不会显示在 for..in 中；也会被 Object.keys 排除；</p>
<p><strong>configurable</strong></p>
<p>通过设置 configurable 标志把对象属性标志设置为不能被删除（delete），它的特性（attribute）不能被修改；</p>
<p>configurable: false 防止更改和删除属性标志，但是允许更改对象的值，不可配置标志（configurable:false）有时会预设在内建对象和属性中；</p>
<blockquote>
<p>Note: 对于不可配置的属性，我们可以将 <code>writable: true</code> 更改为  <code>false</code>，从而防止其值被修改（以添加另一层保护），但无法反向行之；</p>
</blockquote>
<p><strong>Object.getOwnPropertyDescriptor / Object.getOwnPropertyDescriptors</strong></p>
<p>可以通过 Object.getOwnPropertyDescriptor(obj, propertyName) 方法获取，返回一个“属性描述符”对象：包含值和所有的标志；</p>
<p>或者可以使用 Object.getOwnPropertyDescriptors(obj) 方法一次获取对象所有包含 symbol 类型的和不可枚举的属性在内的属性描述符；</p>
<p><strong>Object.defineProperty / Object.defineProperties</strong></p>
<p>可以使用 Object.defineProperty(obj, propertyName, descriptor) 方法修改标志；如果该属性存在，defineProperty 会更新其标志，否则它会使用给定的值和标志创建属性；在这种情况下，如果没有提供标志，则会假定它是 false；</p>
<p>或者使用 Object.defineProperties(obj, descriptors) 方法同时定义多个属性；</p>
<blockquote>
<p>Tips: 克隆对象的“标志感知”方式，但无法克隆原型链：<code>let clone = Object.defineProperties(&#123;&#125;, Object.getOwnPropertyDescriptors(obj))</code>，</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;Coley48&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规方式定义的属性，标志默认全为 true</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(user, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;value: &#x27;Coley48&#x27;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改旧属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&quot;toString&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// 只更新 enumerable 标志</span></span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过不可枚举的属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) <span class="built_in">console</span>.warn(key); <span class="comment">// name</span></span><br><span class="line"><span class="built_in">Object</span>.keys(user); <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义新属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&quot;important&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// value 默认 undefined</span></span><br><span class="line">  <span class="comment">// enumerable 未显式给出，默认为 false</span></span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改不可配置属性 Cannot redefine property: important</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&quot;important&quot;</span>, &#123;</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取全部属性的标志对象</span></span><br><span class="line"><span class="keyword">let</span> descriptors = <span class="built_in">Object</span>.getOwnPropertyDescriptors(user);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptors);</span><br></pre></td></tr></table></figure>

<p><strong>全局封闭对象</strong></p>
<p>属性描述符在单个属性的级别上工作，以下方法可以限制整个对象访问，但在实际开发中较少用到；</p>
<ul>
<li>Object.preventExtensions(obj) 禁止向对象添加新属性</li>
<li>Object.seal(obj) 禁止添加/删除属性；为所有现有的属性设置 configurable: false；</li>
<li>Object.freeze(obj) 禁止添加/删除/更改属性；为所有现有的属性设置 configurable: false, writable: false；</li>
<li>Object.isExtensible(obj) 如果添加属性被禁止，则返回 false，否则返回 true；</li>
<li>Object.isSealed(obj) 如果添加/删除属性被禁止，并且所有现有的属性都具有 configurable: false则返回 true；</li>
<li>Object.isFrozen(obj) 如果添加/删除/更改属性被禁止，并且所有当前属性都是 configurable: false, writable: false，则返回 true；</li>
</ul>
<h4 id="属性的-getter-和-setter"><a href="#属性的-getter-和-setter" class="headerlink" title="属性的 getter 和 setter"></a>属性的 getter 和 setter</h4><p>对象属性分为两种，一种是数据属性，另一种是访问器属性（accessor properties）；本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性；</p>
<p><strong>getter 和 setter</strong></p>
<p>访问器属性由 “getter” 和 “setter” 方法表示，在对象字面量中，它们用 get 和 set 表示；</p>
<p>从外表看，访问器属性看起来就像一个普通属性，这就是访问器属性的设计思想；不以函数的方式调用 getter / setter 属性，当读取 / 设置属性时，getter / setter 会在幕后运行；</p>
<blockquote>
<p>Getters 给你一种方法来定义一个对象的属性，但是在访问它们之前不会计算属性的值。 getter 延迟计算值的成本，直到需要此值，如果不需要，您就不用支付成本；</p>
</blockquote>
<blockquote>
<p>一种额外的优化技术是用智能(或称记忆化)getters 延迟属性值的计算并将其缓存以备以后访问。该值是在第一次调用getter 时计算的，然后被缓存，因此后续访问返回缓存值而不重新计算它。这在以下情况下很有用：</p>
</blockquote>
<p><strong>访问器描述符</strong></p>
<p>访问器属性的描述符与数据属性的不同，没有 value 和 writable，但是有 get 和 set 函数；</p>
<ul>
<li>get 一个没有参数的函数，在读取属性时工作；</li>
<li>set 带有一个参数的函数，当属性被设置时调用；</li>
<li>enumerable 与数据属性的相同；</li>
<li>configurable 与数据属性的相同；</li>
</ul>
<blockquote>
<p>Note: 一个属性要么是访问器（具有 <code>get/set</code> 方法），要么是数据属性（具有 <code>value</code>），但不能两者都是；如果试图在同一个描述符中同时提供 <code>get</code> 和 <code>value</code>，则会出现错误；</p>
</blockquote>
<p>访问器的一大用途是，它们允许随时通过使用 getter 和 setter 替换“正常的”数据属性，来控制和调整这些属性的行为；例如为旧代码添加一个 getter 以实现兼容；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  _name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">      alert(<span class="string">&quot;Name is too short, need at least 4 characters&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> user) alert(key); <span class="comment">// _name</span></span><br><span class="line"></span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br><span class="line">user.name = <span class="string">&quot;&quot;</span>; <span class="comment">// alert ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get">getter MDN 中文参考文档</a></li>
</ul>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><p>在 JavaScript 中，对象有一个特殊的隐藏属性 [[Prototype]]（如规范中所命名的），它要么为 null，要么就是对另一个对象的引用，该对象被称为“原型”；</p>
<p>当从 object 中读取一个缺失的属性时，JavaScript 会自动从原型中获取该属性；在编程中，这被称为“原型继承”（Prototypal inheritance）；</p>
<p>原型链有两个限制：一是引用不能形成闭环，否则 JavaScript 会抛出错误；另一个是忽略对象类型，null 之外的其他类型；</p>
<blockquote>
<p>Note: <code>__proto__</code> 是 <code>[[Prototype]]</code> 因历史原因保留下来的 <code>getter / setter</code>；虽然已经过时，但实际上，包括服务端在内的所有环境都支持它，因此使用它是非常安全的；现代编程语言建议应该使用函数 <code>Object.getPrototypeOf/Object.setPrototypeOf</code> 来取代 <code>__proto__</code> 去 <code>get/set</code> 原型；</p>
</blockquote>
<p>原型仅用于读取属性，对于写入/删除操作可以直接在对象上进行；访问器（accessor）属性有点特殊，因为分配（assignment）操作是由 setter 函数处理的；因此，写入此类属性实际上与调用函数相同；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  surname: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    [<span class="built_in">this</span>.name, <span class="built_in">this</span>.surname] = value.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  __proto__: user,</span><br><span class="line">  isAdmin: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(admin.fullName); <span class="comment">// John Smith (*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setter triggers!</span></span><br><span class="line"><span class="comment">// admin.fullName = &quot;Alice Cooper&quot;; // (**)</span></span><br><span class="line">admin.name = <span class="string">&quot;Coley48&quot;</span>;</span><br><span class="line"></span><br><span class="line">alert(admin.fullName); <span class="comment">// Coley48 Cooper，admin 的内容被修改了</span></span><br><span class="line">alert(user.fullName);  <span class="comment">// John Smith，user 的内容被保护了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for..in</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> admin) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// isAdmin, surname, name, fullName</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 过滤继承属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(admin, key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(key); <span class="comment">// isAdmin, name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.keys 只返回自己的 key</span></span><br><span class="line">alert(<span class="built_in">Object</span>.keys(admin)); <span class="comment">// [&#x27;isAdmin&#x27;, &#x27;name&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> admin.fullName <span class="comment">// 无效，无法通过 admin 删除原型中的属性</span></span><br><span class="line"><span class="keyword">delete</span> user.fullName <span class="comment">// user，admin 中 fullName 均被删除</span></span><br></pre></td></tr></table></figure>

<p>无论在一个对象还是在原型中获取到的方法；在一个方法调用中，this 始终是点符号 . 前面的对象；因此可以实现不同对象共享方法，并且私有状态；</p>
<blockquote>
<p>Tips: <code>obj.hasOwnProperty(key)</code> 方法可以判断 <code>key</code> 是否是 <code>obj</code> 具有自己的（非继承的）属性；一般使用转发调用方式 <code>Object.hasOwnProperty.call(obj, key)</code>；</p>
</blockquote>
<blockquote>
<p>Note: <code>for..in</code> 循环也会迭代继承的属性；而几乎所有键/值获取方法，例如 <code>Object.keys</code> 和 <code>Object.values</code> 等，都会忽略继承的属性；它们只会对对象自身进行操作，不考虑继承自原型的属性；</p>
</blockquote>
<blockquote>
<p>在现代引擎中，从性能的角度来看，从对象还是从原型链获取属性都是没区别的；引擎会记住在哪里找到的该属性，并在下一次请求中重用它；并且一旦有内容更改，它们就会自动更新内部缓存；</p>
</blockquote>
<h4 id="F-prototype"><a href="#F-prototype" class="headerlink" title="F.prototype"></a>F.prototype</h4><p>如果 F.prototype 是一个对象或者 null（赋以其他值会被忽略），那么 new 操作符会使用它为新对象设置 [[Prototype]]；</p>
<blockquote>
<p>Note: 如果在创建之后，F.prototype 属性有了变化（F.prototype = <another object>），那么通过 new F 创建的新对象也将随之拥有新的对象作为 [[Prototype]]，但已经存在的对象将保持旧有的值；</p>
</blockquote>
<p>每个函数都有 prototype 属性，即使我们没有提供它；默认的 prototype 是一个只有属性 constructor 的对象，属性 constructor 指向函数自身；可以使用 constructor 属性来创建一个新对象，该对象使用与现有对象相同的构造器；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造器指向自身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">F.prototype <span class="comment">// &#123;constructor: ƒ&#125;</span></span><br><span class="line">F.prototype.constructor === F <span class="comment">// true</span></span><br><span class="line">F.prototype.constructor.name <span class="comment">// F</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> F();</span><br><span class="line"><span class="keyword">let</span> ff = <span class="keyword">new</span> f.constructor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对原型相关操作的结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Rabbit.prototype = &#123;</span><br><span class="line">  eats: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用了上面的 prototype</span></span><br><span class="line"><span class="keyword">let</span> rabbit1 = <span class="keyword">new</span> Rabbit();</span><br><span class="line"></span><br><span class="line">Rabbit.prototype = &#123;</span><br><span class="line">  eats: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用了新定义的的 prototype</span></span><br><span class="line"><span class="keyword">let</span> rabbit2 = <span class="keyword">new</span> Rabbit();</span><br><span class="line"><span class="comment">// 然后删除新定义的 prototype 的 eats</span></span><br><span class="line"><span class="keyword">delete</span> Rabbit.prototype.eats; </span><br><span class="line"></span><br><span class="line">alert(rabbit1.eats); <span class="comment">// 从之前引用的 prototype 取值 true</span></span><br><span class="line">alert(rabbit2.eats); <span class="comment">// 从新的 prototype 取值 undefined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 为了确保正确的 <code>constructor</code>，我们可以选择添加/删除属性到默认 <code>prototype</code>，而不是将其整个覆盖；</p>
</blockquote>
<h4 id="原生的原型"><a href="#原生的原型" class="headerlink" title="原生的原型"></a>原生的原型</h4><p>所有的内建对象都遵循相同的模式（pattern）：方法都存储在 prototype 中，同时对象本身只存储数据；</p>
<p><strong>Object 和 Object.prototype</strong></p>
<p>Object 是 JavaScript 的一种数据类型，它用于存储各种键值集合和更复杂的实体；Objects 可以通过 Object() 构造函数或者使用对象字面量的方式创建；Object 构造函数为给定的参数创建一个包装类对象（object wrapper），具体有以下情况：</p>
<ul>
<li>如果给定值是 null 或 undefined，将会创建并返回一个空对象；</li>
<li>如果传进去的是一个基本类型的值，则会构造其包装类型的对象；</li>
<li>如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址；</li>
<li>当以非构造函数形式被调用时，Object 的行为等同于 new Object()，返回一个空对象；</li>
</ul>
<blockquote>
<p>Note: 按照规范，所有的内建原型顶端都是 <code>Object.prototype</code>，这就是为什么说“一切都从对象继承而来”；<code>Object.prototype</code> 上方的链中没有更多的 <code>[[Prototype]]</code>；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.__proto__.__proto__.__proto__; <span class="comment">// String Object null</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">Object MDN 中文参考文档</a></li>
</ul>
<p><strong>基础类型</strong></p>
<p>如果试图访问基本数据类型的属性，那么临时包装器对象将会通过内建的构造器 String、Number 和 Boolean 被创建，提供给我们操作字符串、数字和布尔值的方法然后消失；</p>
<blockquote>
<p>Note: null 和 undefined 比较特殊，它们没有对象包装器，所以它们没有方法和属性，并且它们也没有相应的原型；</p>
</blockquote>
<p>在现代编程中，只有一种情况下允许修改原生原型，那就是 polyfilling；但因为原型是全局的，所以很容易造成冲突；</p>
<p><strong>借用原型方法</strong></p>
<p>除了通过复制借用原生原型的方法之外，还可以通过将 <code>obj.__proto__</code> 设置为对应内置对象的 prototype，然后可以使用该原型下的所有方法；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;world!&quot;</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只复制某个方法</span></span><br><span class="line">obj.join = <span class="built_in">Array</span>.prototype.join;</span><br><span class="line"><span class="comment">// 或者指定原型</span></span><br><span class="line">obj.__proto__ = <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line">alert( obj.join(<span class="string">&#x27;,&#x27;</span>) ); <span class="comment">// Hello,world!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装器 + prototype 原型方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.defer = <span class="function"><span class="keyword">function</span> (<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// undefined [1, 2]</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      context.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或使用箭头函数 </span></span><br><span class="line">  <span class="comment">// return (...args) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   setTimeout(this.apply(this, args), ms);</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.defer(<span class="number">1000</span>)(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1 秒后显示 3</span></span><br></pre></td></tr></table></figure>

<h4 id="原型方法，没有-proto-的对象"><a href="#原型方法，没有-proto-的对象" class="headerlink" title="原型方法，没有 __proto__ 的对象"></a>原型方法，没有 <code>__proto__</code> 的对象</h4><p>JavaScript 规范中规定，proto 必须仅在浏览器环境下才能得到支持，因此 <code>__proto__</code> 被认为是过时且不推荐使用的（deprecated）；应该使用以下现代方法代替 <code>__proto__</code>：</p>
<ul>
<li>Object.create(proto, [descriptors]) 利用给定的 proto 作为 [[Prototype]] 和可选的属性描述来创建一个空对象；</li>
<li>Object.getPrototypeOf(obj) 返回对象 obj 的 [[Prototype]]；</li>
<li>Object.setPrototypeOf(obj, proto) 将对象 obj 的 [[Prototype]] 设置为 proto；</li>
</ul>
<p>使用 Object.create 来实现比复制 for..in 循环中的属性更强大的对象克隆方式；以对 obj 进行真正准确地拷贝，包括所有的属性：可枚举和不可枚举的，数据属性和 setters/getters —— 包括所有内容，并带有正确的 [[Prototype]]；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clone = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: JavaScript 引擎对此进行了高度优化，用 <code>Object.setPrototypeOf</code> 或对 <code>obj.__proto__</code> 赋值，“即时”更改原型是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化；</p>
</blockquote>
<p><strong>very plain object</strong></p>
<p>在对象中 <code>__proto__</code> 属性很特别：它必须是对象或者 null，其他原始类型的赋值会被忽略；而使用 Object.create(null) 创建了一个空对象，这个对象没有原型（[[Prototype]] 是 null），所以 <code>__proto__</code> 没有继承 Object.prototype 的 getter/setter，因此可以被赋以任何原始类型值；这样的对象称为 “very plain” 或 “pure dictionary” 对象；</p>
<p><strong>其他静态方法</strong></p>
<ul>
<li>Object.keys(obj) / Object.values(obj) / Object.entries(obj) 返回一个可枚举的由自身的字符串属性名/值/键值对组成的数组；</li>
<li>Object.getOwnPropertySymbols(obj) 返回一个由自身所有的 symbol 类型的键组成的数组；</li>
<li>Object.getOwnPropertyNames(obj) 返回一个由自身所有的字符串键组成的数组；</li>
<li>Reflect.ownKeys(obj) 返回一个由自身所有键组成的数组；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">&quot;Rabbit&quot;</span>);</span><br><span class="line"></span><br><span class="line">rabbit.sayHi(); <span class="comment">// Rabbit</span></span><br><span class="line">Rabbit.prototype.sayHi(); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rabbit).sayHi(); <span class="comment">// undefined</span></span><br><span class="line">rabbit.__proto__.sayHi(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="Class-基本语法"><a href="#Class-基本语法" class="headerlink" title="Class 基本语法"></a>Class 基本语法</h4><p>在现代 JavaScript 中，还有一个更高级的“类（class）”构造方式；而 new 操作符会自动调用 constructor() 方法，因此我们可以在 constructor() 中初始化对象；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的定义实际上声明了一个函数，然后存储类中的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">      alert(<span class="string">&quot;Name is too short.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">user.sayHi();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类其实是一个 constructor 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> User); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(User.prototype.constructor.name); <span class="comment">// User</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(User.prototype)); <span class="comment">// [&#x27;constructor&#x27;, &#x27;sayHi&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class 类与 function 类的差异</span></span><br><span class="line">User(); <span class="comment">// Cannot call a class as a function</span></span><br><span class="line"><span class="comment">// 打印 User 方法的标识符对象</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(User.prototype);</span><br></pre></td></tr></table></figure>

<p>class 不是语法糖，class 与直接使用 function 定义的类有很大差异：</p>
<ol>
<li>通过 class 创建的函数具有特殊的内部属性标记 [[IsClassConstructor]]: true；</li>
<li>类方法不可枚举，类定义将 “prototype” 中的所有方法的 enumerable 标志设置为 false；</li>
<li>类总是使用 use strict；在类构造中的所有代码都将自动进入严格模式；</li>
</ol>
<!-- class类是方法，原型是对象；构造器是方法类；原型对象用于存储实例方法和属性，class类用于存储静态方法和属性； -->

<p><strong>类表达式</strong></p>
<p>就像函数一样，类可以在另外一个表达式中被定义，被传递，被返回，被赋值等；类似于命名函数表达式（Named Function Expressions），类表达式也可以有一个名字，如果类表达式有名字，那么该名字仅在类内部可见；</p>
<p>同对象字面量，类可能包括 getters/setters，计算属性（computed properties）等；</p>
<p>“类字段”是一种允许添加任何属性的语法，与类方法不同，类字段在每个独立对象中被设好，而不是设在 User.prototype；类字段还可以解决丢失 this 的问题；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  click = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> Button(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(button.click, <span class="number">1000</span>); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h4><p>类继承是一个类扩展另一个类的一种方式，可以在现有功能之上创建新功能；</p>
<p>在内部，关键字 extends 使用了旧的原型机制进行工作；它将子类的 prototype.[[Prototype]] 设置为父类的 prototype；</p>
<blockquote>
<p>Tips: 类语法不仅允许指定一个类，在 <code>extends</code> 后可以指定任意表达式，例如一个生成父类的函数调用；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">phrase</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; alert(phrase); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User extends f(&quot;Hello&quot;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi(); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>在子类中可以重写父类同名方法，然后可以使用 super 关键字调用父类方法；箭头函数没有 super，有则会从外部获取；</p>
<p>根据规范，如果一个类扩展了另一个类并且没有 constructor，那么将生成一个只调用 super 的“空” constructor；继承类的 constructor 必须调用 super(…)，并且 (!) 一定要在使用 this 之前调用；</p>
<blockquote>
<p>在 JavaScript 中，继承类（所谓的“派生构造器”，英文为 “derived constructor”）的构造函数与其他函数之间是有区别的；派生构造器具有特殊的内部属性 [[ConstructorKind]]:”derived”；当通过 new 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 this；但是当继承的 constructor 执行时，它不会执行此操作，而是期望父类的 constructor 来完成这项工作；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, earLength</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// super(name);</span></span><br><span class="line">    <span class="built_in">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.earLength = earLength;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">&quot;White Rabbit&quot;</span>, <span class="number">10</span>); <span class="comment">// Error: this is not defined.</span></span><br></pre></td></tr></table></figure>

<p>字段初始化的顺序是基类（还未继承任何东西的那种），在构造函数调用前初始化；派生类，在 super() 后立刻初始化；</p>
<p>父类构造器总是会使用它自己字段的值，而不是被子类重写的那一个类字段；可以通过使用方法或者 getter/setter 替代类字段，来修复这个问题；</p>
<p>JavaScript 为函数添加了一个特殊的内部属性：[[HomeObject]]；当一个函数被定义为类或者对象方法时，它的 [[HomeObject]] 属性就成为了该对象；[[HomeObject]] 不能被更改，所以这个绑定是永久的，[[HomeObject]] 是为类和普通对象中的方法定义的，但是对于对象而言，方法必须确切指定为 method()，而不是 “method: function()”；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  name: <span class="string">&quot;Animal&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// animal.eat.[[HomeObject]] == animal</span></span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  jump: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> jump.`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  __proto__: animal,</span><br><span class="line">  name: <span class="string">&quot;Rabbit&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// rabbit.eat.[[HomeObject]] == rabbit</span></span><br><span class="line">    <span class="built_in">super</span>.eat();</span><br><span class="line">  &#125;,</span><br><span class="line">  jump: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// super.jump(); // &#x27;super&#x27; is only allowed in object methods and classes.</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> longEar = &#123;</span><br><span class="line">  __proto__: rabbit,</span><br><span class="line">  name: <span class="string">&quot;Long Ear&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// longEar.eat.[[HomeObject]] == longEar</span></span><br><span class="line">    <span class="built_in">super</span>.eat();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确执行</span></span><br><span class="line">longEar.eat(); <span class="comment">// Long Ear eats.</span></span><br><span class="line"><span class="comment">// rabbit.jump();</span></span><br></pre></td></tr></table></figure>

<h4 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h4><p>可以把一个方法赋值给类的函数本身，而不是赋给它的 “prototype”，这样的方法被称为 静态的（static）；静态方法和属性可以被继承；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> staticProperty = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="built_in">this</span> === User);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">User.staticMethod(); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果相同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; &#125;</span><br><span class="line">User.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span> === User);</span><br><span class="line">&#125;;</span><br><span class="line">User.staticProperty = <span class="number">10</span>;</span><br><span class="line">User.staticMethod(); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extends 创建两个 [[prototype]]，一个是类本身的，另一个是类原型的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VipUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(VipUser.__proto__ === User); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.warn(VipUser.prototype.__proto__ === User.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="私有的和受保护的属性和方法"><a href="#私有的和受保护的属性和方法" class="headerlink" title="私有的和受保护的属性和方法"></a>私有的和受保护的属性和方法</h4><p>在面向对象的编程中，属性和方法分为两组：</p>
<ul>
<li>内部接口：可以通过该类的其他方法访问，但不能从外部访问的方法和属性；</li>
<li>外部接口：也可以从类的外部访问的方法和属性；</li>
</ul>
<p>为了隐藏内部接口，我们使用受保护的或私有的属性；</p>
<ul>
<li>受保护的字段以 _ 开头，这是一个众所周知的约定，不是在语言级别强制执行的；</li>
<li>私有字段以 # 开头，JavaScript 确保我们只能从类的内部访问它们；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义私有变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  _name = <span class="string">&quot;any&quot;</span>;</span><br><span class="line">  #age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">static</span> #secret = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> <span class="title">secret</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.#secret;</span><br><span class="line">  &#125;</span><br><span class="line">  #<span class="function"><span class="title">whisper</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(User.secret); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// console.log(User.#secret); // Property &#x27;#secret&#x27; is not accessible outside class &#x27;User&#x27; because it has a private identifier</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展内建类"><a href="#扩展内建类" class="headerlink" title="扩展内建类"></a>扩展内建类</h4><p>通常使用 extends 继承内建类，可以扩展内建类的一些方法，或者可以在内建类的原型对象上添加自定义的字段以实现扩展；</p>
<blockquote>
<p>Note: 内建类相互间不继承静态方法；</p>
</blockquote>
<h4 id="类检查：instanceof"><a href="#类检查：instanceof" class="headerlink" title="类检查：instanceof"></a>类检查：instanceof</h4><p>instanceof 操作符用于检查一个对象是否属于某个特定的 class，通常，instanceof 在检查中会将原型链考虑在内；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit();</span><br><span class="line"><span class="built_in">console</span>.log( rabbit <span class="keyword">instanceof</span> Rabbit ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是构造函数，而不是 class</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">new</span> Rabbit() <span class="keyword">instanceof</span> Rabbit ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Symbol.hasInstance</strong></p>
<p>自定义 instanceof，可以在静态方法 Symbol.hasInstance 中设置自定义逻辑；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 instanceOf 检查</span></span><br><span class="line"><span class="comment">// 并假设具有 canEat 属性的都是 animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">canEat</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">alert(obj <span class="keyword">instanceof</span> Animal); <span class="comment">// true：Animal[Symbol.hasInstance](obj) 被调用</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.prototype.isPrototypeOf()</strong></p>
<p>另一个方法：objA.isPrototypeOf(objB) 判断 objA 处在 objB 的原型链中，返回布尔值；但如果中途修改了原型，则之前创建的实例无法被正确判断；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(obj); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变原型指向</span></span><br><span class="line">obj.__proto__ = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(obj); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/object/isPrototypeOf">Object.prototype.isPrototypeOf() MDN 中文参考文档</a></p>
<p><strong>Object.prototype.toString()</strong></p>
<p>使用 Object.prototype.toString 方法来可以揭示类型：按照规范，内建的 toString 方法可以被从对象中提取出来，并在任何其他值的上下文中执行，其结果取决于该值；如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 {}.toString.call 替代 instanceof；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方便起见，将 toString 方法复制到一个变量中</span></span><br><span class="line"><span class="keyword">let</span> objectToString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">alert( objectToString.call(arr) ); <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>

<p>对象的 toString 方法可以使用特殊的对象属性 Symbol.toStringTag 被自定义；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&quot;User&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( &#123;&#125;.toString.call(user) ); <span class="comment">// [object User]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特定于环境的对象和类的 toStringTag：</span></span><br><span class="line">alert( <span class="built_in">window</span>[<span class="built_in">Symbol</span>.toStringTag]); <span class="comment">// Window</span></span><br><span class="line">alert( XMLHttpRequest.prototype[<span class="built_in">Symbol</span>.toStringTag] ); <span class="comment">// XMLHttpRequest</span></span><br><span class="line"></span><br><span class="line">alert( &#123;&#125;.toString.call(<span class="built_in">window</span>) ); <span class="comment">// [object Window]</span></span><br><span class="line">alert( &#123;&#125;.toString.call(<span class="keyword">new</span> XMLHttpRequest()) ); <span class="comment">// [object XMLHttpRequest]</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">类型检查</th>
<th align="left">用于</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">typeof</td>
<td align="left">原始数据类型</td>
<td align="left">string</td>
</tr>
<tr>
<td align="left">instanceof</td>
<td align="left">对象</td>
<td align="left">true/false</td>
</tr>
<tr>
<td align="left">{}.toString</td>
<td align="left">原始数据类型，内建对象，包含 Symbol.toStringTag 属性的对象</td>
<td align="left">string</td>
</tr>
</tbody></table>
<h4 id="Mixin-模式"><a href="#Mixin-模式" class="headerlink" title="Mixin 模式"></a>Mixin 模式</h4><p>Mixin 是一个通用的面向对象编程术语：一个包含可被其他类使用而无需继承的方法的类；Mixin 提供了实现特定行为的方法，但是我们不单独使用它，而是使用它来将这些行为添加到其他类中；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHiBase = &#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHiMixin = &#123;</span><br><span class="line">  <span class="comment">// 设置原型</span></span><br><span class="line">  __proto__: sayHiBase,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.say();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">`Hello <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">sayBye</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">`Bye <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mixin</span></span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, sayHiMixin);</span><br><span class="line"><span class="keyword">new</span> User(<span class="string">&#x27;Coley&#x27;</span>).sayHi(); <span class="comment">// coley</span></span><br><span class="line"><span class="keyword">new</span> User(<span class="string">&#x27;Hush&#x27;</span>).say(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 在 <code>sayHiMixin</code> 内部对父类方法 <code>super.say()</code> 的调用会在 <code>mixin</code> 的原型中查找方法，而不是在 class 中查找；因为方法 <code>say</code> 最初是在 <code>sayHiMixin</code> 中创建的，因此，即使复制了它们，但是 <code>say</code> 的 <code>[[HomeObject]]</code> 内部属性仍引用的是 sayHiMixin；当 <code>super</code> 在 <code>[[HomeObject]].[[Prototype]]</code> 中寻找父方法时，意味着它搜索的是 <code>sayHiMixin.[[Prototype]]</code>，而不是 <code>User.[[Prototype]]</code>；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eventMixin = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 订阅事件，用法：</span></span><br><span class="line"><span class="comment">   *  menu.on(&#x27;select&#x27;, function(item) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">eventName, handler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers) <span class="built_in">this</span>._eventHandlers = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers[eventName]) &#123;</span><br><span class="line">      <span class="built_in">this</span>._eventHandlers[eventName] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._eventHandlers[eventName].push(handler);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 取消订阅，用法：</span></span><br><span class="line"><span class="comment">   *  menu.off(&#x27;select&#x27;, handler)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">eventName, handler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> handlers = <span class="built_in">this</span>._eventHandlers?.[eventName];</span><br><span class="line">    <span class="keyword">if</span> (!handlers) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handlers.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (handlers[i] === handler) &#123;</span><br><span class="line">        handlers.splice(i--, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成具有给定名称和数据的事件</span></span><br><span class="line"><span class="comment">   *  this.trigger(&#x27;select&#x27;, data1, data2);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">trigger</span>(<span class="params">eventName, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers?.[eventName]) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 该事件名称没有对应的事件处理程序（handler）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用事件处理程序（handler）</span></span><br><span class="line">    <span class="built_in">this</span>._eventHandlers[eventName].forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler.apply(<span class="built_in">this</span>, args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/mixins">JavaScript 现代教程-Mixin 模式</a></li>
</ul>
<h4 id="错误处理，try…catch"><a href="#错误处理，try…catch" class="headerlink" title="错误处理，try…catch"></a>错误处理，try…catch</h4><p>try…catch 仅对运行时的 error 有效；这类错误被称为“运行时的错误（runtime errors）”，有时被称为“异常（exceptions）”；</p>
<p>如果在“计划的（scheduled）”代码中发生异常，例如在 setTimeout 中，则 try…catch 不会捕获到异常：为了捕获到计划的（scheduled）函数中的异常，那么 try…catch 必须在这个函数内；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    noSuchVariable; <span class="comment">// try...catch 处理 error 了！</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    alert( <span class="string">&quot;error is caught here!&quot;</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>对于所有内建的 error，error 对象具有两个主要属性和其他非标准的属性：</p>
<ul>
<li>name：Error 名称；</li>
<li>message：关于 error 的详细文字描述；</li>
<li>stack：当前的调用栈：用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息；</li>
</ul>
<p>使用 throw <error object> 会生成一个 error 对象；技术上讲，我们可以将任何东西用作 error 对象。甚至可以是一个原始类型数据，例如数字或字符串，但最好使用对象，最好使用具有 name 和 message 属性的对象（某种程度上保持与内建 error 的兼容性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整语法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//  ... 尝试执行的代码 ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">//  ... 处理 error ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">//  ... 总是会执行的代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>finally</code> 子句适用于 <code>try...catch</code> 的任何出口，这包括显式的 <code>return</code>；</p>
</blockquote>
<p>规范中没有全局 catch 的相关内容，但是代码的执行环境一般会提供这种机制；Node.JS 有 process.on(“uncaughtException”)；在浏览器中，可以将一个函数赋值给特殊的 window.onerror 属性，该函数将在发生未捕获的 error 时执行；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, url, line, col, error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// message：Error 信息；</span></span><br><span class="line">  <span class="comment">// url；发生 error 的脚本的 URL；</span></span><br><span class="line">  <span class="comment">// line，col：发生 error 处的代码的行号和列号；</span></span><br><span class="line">  <span class="comment">// error：Error 对象；</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>全局错误处理程序 window.onerror 的作用通常不是恢复脚本的执行，如果发生编程错误，那这几乎是不可能的，它的作用是将错误信息发送给开发者；</p>
<h4 id="自定义-Error，扩展-Error"><a href="#自定义-Error，扩展-Error" class="headerlink" title="自定义 Error，扩展 Error"></a>自定义 Error，扩展 Error</h4><p>JavaScript 允许将 throw 与任何参数一起使用，所以从技术上讲，我们自定义的 error 不需要从 Error 中继承。但是，如果我们继承，那么就可以使用 obj instanceof Error 来识别 error 对象；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">message</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="built_in">this</span>.constructor.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationError</span> <span class="keyword">extends</span> <span class="title">MyError</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyRequiredError</span> <span class="keyword">extends</span> <span class="title">ValidationError</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">property</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;No property: &quot;</span> + property);</span><br><span class="line">    <span class="built_in">this</span>.property = property;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name 是对的</span></span><br><span class="line">alert( <span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;field&quot;</span>).name ); <span class="comment">// PropertyRequiredError</span></span><br></pre></td></tr></table></figure>

<p>包装异常是一项广泛应用的技术：用于处理低级别异常并创建高级别 error 而不是各种低级别 error 的函数，低级别异常有时会成为该对象的属性；</p>
<h4 id="回调简介"><a href="#回调简介" class="headerlink" title="回调简介"></a>回调简介</h4><p>异步执行某项功能的函数应该提供一个 callback 参数用于在相应事件完成时调用，这被称为“基于回调”的异步编程风格；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态加载脚本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 &lt;script&gt; 标签，并将其附加到页面</span></span><br><span class="line">  <span class="comment">// 这将使得具有给定 src 的脚本开始加载，并在加载完成后运行</span></span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  script.onload = <span class="function">() =&gt;</span> callback(script);</span><br><span class="line">  script.onerror = <span class="function">() =&gt;</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error for <span class="subst">$&#123;src&#125;</span>`</span>));</span><br><span class="line">  <span class="built_in">document</span>.head.append(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>传递给 new Promise 的函数被称为 executor，当 new Promise 被创建，executor 会自动运行；它的参数 resolve 和 reject 是由 JavaScript 自身提供的回调；</p>
<ul>
<li>resolve(value) 如果任务成功完成并带有结果 value；</li>
<li>reject(error) 如果出现了 error，error 即为 error 对象；</li>
</ul>
<p>由 new Promise 构造器返回的 promise 对象具有以下内部属性：</p>
<ul>
<li>state 最初是 “pending”，然后在 resolve 被调用时变为 “fulfilled”，或者在 reject 被调用时变为 “rejected”；</li>
<li>result 最初是 undefined，然后在 resolve(value) 被调用时变为 value，或者在 reject(error) 被调用时变为 error；</li>
</ul>
<p>Promise 可以通过使用 .then、.catch 和 .finally 方法接收处理结果：</p>
<ul>
<li>.then 的第一个参数是一个函数，该函数将在 promise resolved 后运行并接收结果；.then 的第二个参数也是一个函数，该函数将在 promise rejected 后运行并接收 error；</li>
<li>.catch(f) 调用是 .then(null, f) 的完全的模拟，它只是一个简写形式；如果错误在前面以及被处理，该部分不会执行；</li>
<li>.finally(f) 处理程序（handler）没有参数，在某种意义上，f 总是在 promise 被 settled 时运行：即 promise 被 resolve 或 reject；finally 处理程序将结果和 error 传递给下一个处理程序；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// executor</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>));</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;).then(</span><br><span class="line">          (result) =&gt; &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(result); <span class="comment">// Done.</span></span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Unexpected error.&quot;</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">          (error) =&gt; &#123;</span><br><span class="line">              <span class="built_in">console</span>.warn(error); <span class="comment">// Whoops!</span></span><br><span class="line">          &#125;</span><br><span class="line">      ).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 可以接收之前 .then 中的错误</span></span><br><span class="line">          <span class="built_in">console</span>.warn(err); <span class="comment">// Unexpected error.</span></span><br><span class="line">      &#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;Finished.&quot;</span>);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>executor</code> 只能调用一个 <code>resolve</code> 或一个 <code>reject</code>，任何状态的更改都是最终的；所有其他的再对 <code>resolve</code> 和 <code>reject</code> 的调用都会被忽略；此外，直接受一个参数，多余的参数也会被忽略；</p>
</blockquote>
<blockquote>
<p>Note: 通常以 <code>Error</code> 对象 <code>reject</code>；实际上，<code>executor</code> 中还可以立即调用 <code>resolve</code> 或 <code>reject</code>；</p>
</blockquote>
<blockquote>
<p>Tips: 如果 <code>promise</code> 为 <code>pending</code> 状态，<code>.then/catch/finally</code> 处理程序（handler）将等待它。否则，如果 <code>promise</code> 已经是 <code>settled</code> 状态，它们就会立即运行；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">3000</span>).then(<span class="function">() =&gt;</span> alert(<span class="string">&#x27;runs after 3 seconds&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="Promise-链"><a href="#Promise-链" class="headerlink" title="Promise 链"></a>Promise 链</h4><p>每个对 .then 的调用都会返回了一个新的 promise，因此我们可以在其之上调用下一个 .then；形成一个 .then 处理程序（handler）链，也即 Promise 链；</p>
<p>同时 .then(handler) 中所使用的处理程序（handler）可以创建并返回一个 promise，其后的处理程序（handler）将等待它 settled 后再获得其结果（result）；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(result); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// (*)</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(result); <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 确切地说，处理程序（handler）返回的不完全是一个 <code>promise</code>，而是返回的被称为 <code>thenable</code> 对象 — 一个具有方法 <code>.then</code> 的任意对象，它会被当做一个 <code>promise</code> 来对待；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thenable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">num</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现 .then 方法</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    alert(resolve); <span class="comment">// function() &#123; native code &#125;</span></span><br><span class="line">    <span class="comment">// 1 秒后使用 this.num*2 进行 resolve</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="built_in">this</span>.num * <span class="number">2</span>), <span class="number">1000</span>); <span class="comment">// (**)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-promise-进行错误处理"><a href="#使用-promise-进行错误处理" class="headerlink" title="使用 promise 进行错误处理"></a>使用 promise 进行错误处理</h4><p>Promise 的执行者（executor）和 promise 的处理程序（handler）周围有一个“隐式的 try..catch”；如果发生异常，就会被捕获，并被视为 rejection 进行处理；控制权移交至最近的 error 处理程序（handler）；</p>
<p>在浏览器中，我们可以使用 unhandledrejection 事件来捕获这类 error；这个事件是 HTML 标准 的一部分；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unhandledrejection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个事件对象有两个特殊的属性：</span></span><br><span class="line">  alert(event.promise); <span class="comment">// [object Promise] - 生成该全局 error 的 promise</span></span><br><span class="line">  alert(event.reason); <span class="comment">// Error: Whoops! - 未处理的 error 对象</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>);</span><br><span class="line">&#125;); <span class="comment">// 没有用来处理 error 的 catch</span></span><br></pre></td></tr></table></figure>

<p>有一个浏览器技巧，是从 finally 返回零延时（zero-timeout）的 promise；这是因为一些浏览器（比如 Chrome）需要“一点时间”的 promise 处理程序来绘制文档的更改；因此它确保在进入链下一步之前，指示在视觉上是停止的；</p>
<p>函数代码周围有个“隐式的 try..catch”，所以，所有同步错误都会得到处理，但是无法捕获异步的错误；try…catch 是同步工作的；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// throw new Error(&quot;Sync error.&quot;) // 可以捕获</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// reject(new Error(&quot;No&quot;)); // 可以处理</span></span><br><span class="line">        <span class="comment">// throw new Error(&quot;Async error.&quot;); // 无法捕获</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;).catch(alert);</span><br></pre></td></tr></table></figure>

<h4 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h4><p>在 Promise 类中，有 6 种静态方法；</p>
<p><strong>Promise.all</strong></p>
<p>并行执行多个 promise，并等待所有 promise 都准备就绪；Promise.all 接受一个 promise 数组作为参数（从技术上讲，它可以是任何可迭代对象，但通常是一个数组）并返回一个新的 promise；</p>
<p>结果数组中元素的顺序与其在源 promise 中的顺序相同，即使第一个 promise 花费了最长的时间才 resolve，但它仍是结果数组中的第一个；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">3000</span>)), <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">2</span>), <span class="number">2000</span>)), <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">3</span>), <span class="number">1000</span>)) <span class="comment">// 3</span></span><br><span class="line">]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;); <span class="comment">// 1,2,3 当上面这些 promise 准备好时：每个 promise 都贡献了数组中的一个元素</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 一个常见的技巧是，将一个任务数据数组映射（map）到一个 <code>promise</code> 数组，然后将其包装到 <code>Promise.all</code>；</p>
</blockquote>
<p>如果任意一个 promise 被 reject，由 Promise.all 返回的 promise 就会立即 reject，并且带有的就是这个 error；Promise.all 也会立即被 reject，完全忽略列表中其他的 promise，它们的结果也被忽略；</p>
<p>Promise.all(iterable) 允许在 iterable 中使用 non-promise 的“常规”值；常规值将被“按原样”传递给结果数组；</p>
<p><strong>Promise.allSettled</strong></p>
<p>Promise.allSettled 等待所有的 promise 都被 settle，无论结果如何；结果数组有两种数据：</p>
<ul>
<li>{status:”fulfilled”, value:result} 对于成功的响应；</li>
<li>{status:”rejected”, reason:error} 对于 error；</li>
</ul>
<p><strong>Promise.race</strong></p>
<p>与 Promise.all 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）；第一个 settled 的 promise “赢得了比赛”之后，所有进一步的 result/error 都会被忽略；</p>
<p><strong>Promise.any</strong></p>
<p>与 Promise.race 类似，区别在于 Promise.any 只等待第一个 fulfilled 的 promise，并将这个 fulfilled 的 promise 返回；如果给出的 promise 都 rejected，那么则返回 rejected 的 promise 和 AggregateError（一个特殊的 error 对象），在其 errors 属性中存储着所有 promise error；</p>
<p><strong>Promise.resolve</strong></p>
<p>Promise.resolve(value) 用结果 value 创建一个 resolved 的 promise；当可以直接从缓存中获取了当前操作的结果 value，但是期望返回的是一个 promise 时，可以使用 Promise.resolve(value) 将 value “封装”进 promise，以满足期望返回一个 promise 的这个需求；</p>
<p><strong>Promise.reject</strong></p>
<p>与 Promise.resolve 类似 Promise.reject(error) 用 error 创建一个 rejected 的 promise；</p>
<h4 id="Promisification"><a href="#Promisification" class="headerlink" title="Promisification"></a>Promisification</h4><p>promisify(f)：接受一个需要被 promisify 的函数 f，并返回一个包装（wrapper）函数；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123; <span class="comment">// 返回一个包装函数（wrapper-function） (*)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err, result</span>) </span>&#123; <span class="comment">// 我们对 f 的自定义的回调 (**)</span></span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      args.push(callback); <span class="comment">// 将我们的自定义的回调附加到 f 参数（arguments）的末尾</span></span><br><span class="line"></span><br><span class="line">      f.call(<span class="built_in">this</span>, ...args); <span class="comment">// 调用原始的函数</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">let</span> loadScriptPromise = promisify(loadScript);</span><br><span class="line">loadScriptPromise(...).then(...);</span><br></pre></td></tr></table></figure>

<h4 id="微任务（Microtask）"><a href="#微任务（Microtask）" class="headerlink" title="微任务（Microtask）"></a>微任务（Microtask）</h4><p>Promise 的处理程序（handlers）.then、.catch 和 .finally 都是异步的；而异步任务需要适当的管理，为此，ECMA 标准规定了一个内部队列 PromiseJobs，通常被称为“微任务队列（microtask queue）”（V8 术语）；</p>
<p>如规范中所述：队列（queue）是先进先出的：首先进入队列的任务会首先运行；同时，只有在 JavaScript 引擎中没有其它任务在运行时，才开始执行任务队列中的任务；</p>
<p>如果一个 promise 的 error 未被在微任务队列的末尾进行处理，则会出现“未处理的 rejection”；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Promise Failed!&quot;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> promise.catch(<span class="function"><span class="params">err</span> =&gt;</span> alert(<span class="string">&#x27;caught&#x27;</span>)), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Promise Failed!</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unhandledrejection&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> alert(event.reason));</span><br></pre></td></tr></table></figure>

<h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>async 函数总是返回一个 promise，其他值将自动被包装在一个 resolved 的 promise 中；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(alert); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>await 的关键词，只在 async 函数内工作；await 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果；</p>
<p>await 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行；这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等；</p>
<blockquote>
<p>Tips: 在现代浏览器中，当我们处于一个 <code>module</code> 中时，那么在顶层使用 <code>await</code> 也是被允许的；实测只在 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签中可用；或者可以使用立即执行函数；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/promise-chaining/user.json&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> response.json();</span><br><span class="line">  ...</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>await 允许使用 thenable 对象；如果 await 接收了一个非 promise 的 Thenable 对象，它就会调用这个 .then 方法，并将内建的函数 resolve 和 reject 作为参数传入（就像它对待一个常规的 Promise executor 时一样）；然后 await 等待直到这两个函数中的某个被调用，然后使用得到的结果继续执行后续任务；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thenable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">num</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    alert(resolve);</span><br><span class="line">    <span class="comment">// 1000ms 后使用 this.num*2 进行 resolve</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="built_in">this</span>.num * <span class="number">2</span>), <span class="number">1000</span>); <span class="comment">// (*)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 等待 1 秒，之后 result 变为 2</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> Thenable(<span class="number">1</span>);</span><br><span class="line">  alert(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p>如果一个 promise 正常 resolve，await promise 返回的就是其结果。但是如果 promise 被 reject，它将 throw 这个 error；这时可以在 async 函数中用 try..catch 来捕获上面提到的那个 error，与常规的 throw 使用的是一样的方式；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>));</span><br><span class="line">  <span class="comment">// 等价于 throw new Error(&quot;Whoops!&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://no-such-url&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    alert(err); <span class="comment">// TypeError: failed to fetch</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: <code>async/await</code> 可以和 <code>Promise.all</code> 一起使用；</p>
</blockquote>
<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p> Generator 可以按需一个接一个地返回（“yield”）多个值；它们可与 iterable 完美配合使用，从而可以轻松地创建数据流；在此类函数被调用时，它不会运行其代码，而是返回一个被称为 “generator object” 的特殊对象，来管理执行流程；</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"><span class="built_in">console</span>.log(generator); <span class="comment">// Generator &#123;_invoke: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> one = generator.next();</span><br><span class="line"><span class="keyword">let</span> two = generator.next();</span><br><span class="line"><span class="keyword">let</span> three = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(one, two, three);</span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125; &#123;value: 2, done: false&#125; &#123;value: 3, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p> 一个 generator 的主要方法就是 next()，当 next 被调用时，它会恢复上图所示的运行，执行直到最近的 yield <value> 语句（value 可以被省略，默认为 undefined），然后函数执行暂停，并将产出的（yielded）值返回到外部代码；</p>
<p>Generator 是可迭代的，但当 done: true 时，for..of 循环会忽略最后一个 value；因此，如果我们想要通过 for..of 循环显示所有的结果，必须使用 yield 返回它们；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> generator) &#123;</span><br><span class="line">  alert(value); <span class="comment">// 1，然后是 2，然后是 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sequence = [<span class="number">0</span>, ...generateSequence()];</span><br><span class="line">alert(sequence); <span class="comment">// 0, 1, 2, 3</span></span><br></pre></td></tr></table></figure>

<p>可以通过提供一个 generator 函数作为 Symbol.iterator，来使用 generator 进行迭代；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [Symbol.iterator]: function*() 的简写形式</span></span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> value = <span class="built_in">this</span>.from; value &lt;= <span class="built_in">this</span>.to; value++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( [...range] ); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<p>对于 generator 而言，我们可以使用 yield* 这个特殊的语法来将一个 generator “嵌入”（组合）到另一个 generator 中；yield* 指令将执行委托给另一个 generator，这个术语意味着 yield* gen 在 generator gen 上进行迭代，并将其产出（yield）的值透明地（transparently）转发到外部；执行结果与我们内联嵌套 generator 中的代码获得的结果相同；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) <span class="keyword">yield</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatePasswordCodes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0..9</span></span><br><span class="line">  <span class="keyword">yield</span>* generateSequence(<span class="number">48</span>, <span class="number">57</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A..Z</span></span><br><span class="line">  <span class="keyword">yield</span>* generateSequence(<span class="number">65</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a..z</span></span><br><span class="line">  <span class="keyword">yield</span>* generateSequence(<span class="number">97</span>, <span class="number">122</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> code <span class="keyword">of</span> generatePasswordCodes()) &#123;</span><br><span class="line">  str += <span class="built_in">String</span>.fromCharCode(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(str); <span class="comment">// 0..9A..Za..z</span></span><br></pre></td></tr></table></figure>

<p>与常规函数不同，generator 和调用 generator 的代码可以通过在 next/yield 中传递值来交换结果；yield 不仅可以向外返回结果，而且还可以将外部的值传递到 generator 内；调用 generator.next(arg)，就能将参数 arg 传递到 generator 内部，这个 arg 参数会变成 yield 的结果；</p>
<p>此外，调用 generator.throw(err) 向 yield 传递一个 error，在这种情况下，err 将被抛到对应的 yield 所在的那一行；如果我们没有在那里捕获这个 error，那么，通常，它会掉入外部调用代码（如果有），如果在外部也没有被捕获，则会杀死脚本；</p>
<p>还可以通过 generator.return(value) 完成 generator 的执行并返回给定的 value；如果我们在已完成的 generator 上再次使用 generator.return()，它将再次返回该值；通常只用于在特定条件下停止 generator；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 向外部代码传递一个问题并等待答案</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> <span class="string">&quot;2 + 2 = ?&quot;</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">  alert(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = gen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> question = generator.next().value; <span class="comment">// &lt;-- yield 返回的 value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果传递到 generator 中</span></span><br><span class="line">generator.next(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">generator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;The answer is not found in my database&quot;</span>));</span><br><span class="line"><span class="comment">// 主动返回</span></span><br><span class="line">g.return(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="异步迭代和-generator"><a href="#异步迭代和-generator" class="headerlink" title="异步迭代和 generator"></a>异步迭代和 generator</h4><p>异步迭代允许我们对按需通过异步请求而得到的数据进行迭代：</p>
<ul>
<li>使用 Symbol.asyncIterator 取代 Symbol.iterator；next() 方法；</li>
<li>应该返回一个 promise（带有下一个值，并且状态为 fulfilled），关键字 async 也可以实现这一点，我们可以简单地使用 async next()；</li>
<li>我们应该使用 for await (let item of iterable) 循环来迭代这样的对象；</li>
</ul>
<blockquote>
<p>Note: 需要常规的同步 <code>iterator</code> 的功能，无法与异步 <code>iterator</code> 一起使用，因为它期望找到 <code>Symbol.iterator</code>，而不是 <code>Symbol.asyncIterator</code>；因此 <code>Spread</code> 语法 <code>...</code> 和 <code>for..of</code> 无法异步工作；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步 generator</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">    <span class="comment">// 可以使用 await 了！</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> generator = generateSequence(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> value <span class="keyword">of</span> generator) &#123;</span><br><span class="line">    alert(value); <span class="comment">// 1，然后 2，然后 3，然后 4，然后 5（在每个 alert 之间有延迟）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>常规的 generator 可用作 Symbol.iterator 以使迭代代码更短，异步 generator 可用作 Symbol.asyncIterator 来实现异步迭代；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line">  <span class="comment">// 这一行等价于 [Symbol.asyncIterator]: async function*() &#123;</span></span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> value = <span class="built_in">this</span>.from; value &lt;= <span class="built_in">this</span>.to; value++) &#123;</span><br><span class="line">      <span class="comment">// 在 value 之间暂停一会儿，等待一些东西</span></span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">      <span class="keyword">yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> value <span class="keyword">of</span> range) &#123;</span><br><span class="line">    alert(value); <span class="comment">// 1，然后 2，然后 3，然后 4，然后 5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块 Module"></a>模块 Module</h4><p>简单讲，一个模块（module）就是一个文件，一个脚本就是一个模块；一个模块可以包含用于特定目的的类或函数库；</p>
<ul>
<li>AMD 最古老的模块系统之一，最初由 require.js 库实现；</li>
<li>CommonJS 为 Node.js 服务器创建的模块系统；</li>
<li>UMD 另外一个模块系统，建议作为通用的模块系统，它与 AMD 和 CommonJS 都兼容；</li>
</ul>
<p>语言级的模块系统在 2015 年的时候出现在了标准（ES6）中，此后逐渐发展，现在已经得到了所有主流浏览器和 Node.js 的支持；</p>
<p>模块可以相互加载，并可以使用特殊的指令 export 和 import 来交换功能，从另一个模块调用一个模块的函数；</p>
<ul>
<li>export 关键字标记了可以从当前模块外部访问的变量和函数；</li>
<li>import 关键字允许从其他模块导入功能；</li>
</ul>
<blockquote>
<p>Note: 由于模块支持特殊的关键字和功能，因此我们必须通过使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 特性（attribute）来告诉浏览器，此脚本应该被当作模块（module）来对待；同时模块只通过 <code>HTTP(s)</code> 工作，而非本地；</p>
</blockquote>
<p>对浏览器和服务端的 JavaScript 来说都有效的模块<strong>核心功能</strong>：</p>
<ul>
<li>模块始终在严格模式下运行，始终使用 “use strict”；</li>
<li>每个模块都有自己的顶级作用域（top-level scope）；一个模块中的顶级作用域变量和函数在其他脚本中是不可见的；模块应该 export 想要被外部访问的内容，并 import 所需要的内容；</li>
<li>模块代码仅在第一次导入时被解析，如果同一个模块被导入到多个其他位置，那么它的代码只会执行一次，即在第一次被导入时，然后将其导出（export）的内容提供给进一步的导入（importer）；</li>
<li>import.meta 对象包含关于当前模块的信息，其内容取决于其所在的环境；在浏览器环境中，它包含当前脚本的 URL，或者如果它是在 HTML 中的话，则包含当前页面的 URL；</li>
<li>在一个模块中，顶级 this 是 undefined；非模块脚本的顶级 this 是全局对象；</li>
</ul>
<blockquote>
<p>Note: 在浏览器中，可以通过将变量显式地分配给 <code>window</code> 的一个属性，使其成为窗口级别的全局变量，无论脚本是否带有 <code>type=&quot;module&quot;</code>；但对于模块，应该使用导入/导出而不是依赖全局变量；</p>
</blockquote>
<blockquote>
<p>Note: 顶层模块代码应该用于初始化，创建模块特定的内部数据结构；如果需要多次调用某些东西，则应该将其以函数的形式导出；</p>
</blockquote>
<p>只对浏览器中拥有 type=”module” 标识脚本有效的<strong>特定功能</strong>：</p>
<ul>
<li>模块脚本总是被延迟的，与 defer 特性对外部脚本和内联脚本的影响相同；</li>
<li>对于非模块脚本，async 特性（attribute）仅适用于外部脚本；异步脚本会在准备好后立即运行，独立于其他脚本或 HTML 文档；对于模块脚本，它也适用于内联脚本；</li>
<li>具有 type=”module” 的外部脚本（external script），相同 src 的外部脚本仅运行一次；且从另一个源获取的脚本，远程服务器必须提供表示允许获取的 header Access-Control-Allow-Origin；</li>
<li>在浏览器中，import 必须给出相对或绝对的 URL 路径，import 中不允许没有任何路径的模块，这种模块被称为“裸（bare）”模块；</li>
<li>旧时的浏览器不理解 type=”module”，未知类型的脚本会被忽略；</li>
</ul>
<blockquote>
<p>Note: 下载外部模块脚本 <code>&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt;</code> 不会阻塞 <code>HTML</code> 的处理，它们会与其他资源并行加载；模块脚本会等到 <code>HTML</code> 文档完全准备就绪（即使它们很小并且比 <code>HTML</code> 加载速度更快），然后才会运行；</p>
</blockquote>
<blockquote>
<p>Note: 使用 nomodule 特性来提供一个后备：<code>&lt;script nomodule&gt;...&lt;/script&gt;</code>；</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/60a8a74f5eee">Cannot use import statement outside a module</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904067651600391">CommonJS和ES6模块的区别</a></li>
</ul>
<h4 id="导出和导入"><a href="#导出和导入" class="headerlink" title="导出和导入"></a>导出和导入</h4><p>通常要明确列出需要导入的内容：</p>
<ul>
<li>打包工具中优化器（optimizer）就会从打包好的代码中删除那些未被使用的函数，从而使构建更小，这就是所谓的摇树（tree-shaking）；</li>
<li>导入的显式列表可以更好地概述代码结构：使用的内容和位置；使得代码支持重构，并且重构起来更容易；</li>
<li>明确列出要导入的内容会使得名称较短；</li>
</ul>
<p>模块提供了一个特殊的默认导出 export default 语法，以使“一个模块只做一件事”的方式看起来更好；每个文件最多只能有一个默认的导出，因此导出的实体可能没有名称；</p>
<table>
<thead>
<tr>
<th align="left">命名的导出</th>
<th align="left">默认的导出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">export class User {…}</td>
<td align="left">export default class User {…}</td>
</tr>
<tr>
<td align="left">import {User} from …</td>
<td align="left">import User from …</td>
</tr>
</tbody></table>
<p>从技术上讲，我们可以在一个模块中同时有默认的导出和命名的导出，但是通常不会混合使用它们，模块要么是命名的导出要么是默认的导出；</p>
<p>在某些情况下，default 关键词被用于引用默认的导出；默认引入可以使用不同的名称来导入相同的内容；</p>
<p>“重新导出（Re-export）”语法 export … from … 允许导入内容，并立即将其导出；export … from 与 import/export 相比的显著区别是重新导出的模块在当前文件中不可用；</p>
<blockquote>
<p>Note: 重新导出时，默认导出需要单独处理；</p>
</blockquote>
<blockquote>
<p>Note: 在代码块 <code>&#123;...&#125;</code> 中的 <code>import/export</code> 语句无效；</p>
</blockquote>
<p>导出方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="comment">// 导出数组</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> months = [<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>,<span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 const 声明的变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MODULES_YEAR = <span class="number">2015</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者统一导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; months, MODULES_YEAR, User &#125;; <span class="comment">// 导出变量列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出为其他名字</span></span><br><span class="line"><span class="keyword">export</span> &#123; sayHi <span class="keyword">as</span> hi, sayBye <span class="keyword">as</span> bye &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sayHi;</span><br><span class="line"><span class="keyword">export</span> &#123; sayHi <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; sayHi &#125; <span class="keyword">from</span> <span class="string">&#x27;./say.js&#x27;</span>; <span class="comment">// 重新导出 sayHi</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> User &#125; <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>; <span class="comment">// 重新导出 default</span></span><br><span class="line"><span class="comment">// 效果同，区别是在当前模块下重新导出无法使用</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; User <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新导出含有默认导出的模块</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>; <span class="comment">// 重新导出命名的导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>; <span class="comment">// 重新导出默认的导出</span></span><br></pre></td></tr></table></figure>

<p>导入方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; months, User &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有内容导入为一个对象</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> say <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 as 让导入具有不同的名字</span></span><br><span class="line"><span class="keyword">import</span> &#123; sayHi <span class="keyword">as</span> hi, sayBye <span class="keyword">as</span> bye &#125; <span class="keyword">from</span> <span class="string">&#x27;./say.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> User, sayHi &#125; <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有默认导入时导入为对象</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> user <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> User = user.default; <span class="comment">// 默认的导出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入模块（其代码，并运行），但不要将其任何导出赋值给变量</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;module&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>动态导入</strong></p>
<p>import(module) 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象，可以在代码中的任意位置调用这个表达式；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(modulePath)</span><br><span class="line">  .then(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> err);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 await</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(modulePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 含默认导出</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./say.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> say = obj.default;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 动态导入在常规脚本中工作时，它们不需要 script type=”module”；import 不是一个函数，只是一种特殊语法，恰好使用了括号；</p>
</blockquote>
<h4 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h4><p>一个 Proxy 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<ul>
<li>target 是要包装的对象，可以是任何东西，包括函数；</li>
<li>handler 代理配置：带有“捕捉器”（“traps”，即拦截操作的方法）的对象；</li>
</ul>
<p>对 proxy 进行操作，如果在 handler 中存在相应的捕捉器，则它将运行，并且 Proxy 有机会对其进行处理，否则将直接对 target 进行处理；Proxy 是一种特殊的“奇异对象（exotic object）”，它没有自己的属性；如果 handler 为空，则透明地将操作转发给 target；</p>
<p>对于对象的大多数操作，JavaScript 规范中有一个所谓的“内部方法”，它描述了最底层的工作方式，对于每个内部方法，此表中都有一个捕捉器，Proxy 捕捉器会拦截这些方法的调用；</p>
<table>
<thead>
<tr>
<th align="left">内部方法</th>
<th align="left">Handler 方法</th>
<th align="left">何时触发</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[[Get]]</td>
<td align="left">get</td>
<td align="left">读取属性</td>
</tr>
<tr>
<td align="left">[[Set]]</td>
<td align="left">set</td>
<td align="left">写入属性</td>
</tr>
<tr>
<td align="left">[[HasProperty]]</td>
<td align="left">has</td>
<td align="left">in 操作符</td>
</tr>
<tr>
<td align="left">[[Delete]]</td>
<td align="left">deleteProperty</td>
<td align="left">delete 操作符</td>
</tr>
<tr>
<td align="left">[[Call]]</td>
<td align="left">apply</td>
<td align="left">函数调用</td>
</tr>
<tr>
<td align="left">[[Construct]]</td>
<td align="left">construct</td>
<td align="left">new 操作符</td>
</tr>
<tr>
<td align="left">[[GetPrototypeOf]]</td>
<td align="left">getPrototypeOf</td>
<td align="left">Object.getPrototypeOf</td>
</tr>
<tr>
<td align="left">[[SetPrototypeOf]]</td>
<td align="left">setPrototypeOf</td>
<td align="left">Object.setPrototypeOf</td>
</tr>
<tr>
<td align="left">[[IsExtensible]]</td>
<td align="left">isExtensible</td>
<td align="left">Object.isExtensible</td>
</tr>
<tr>
<td align="left">[[PreventExtensions]]</td>
<td align="left">preventExtensions</td>
<td align="left">Object.preventExtensions</td>
</tr>
<tr>
<td align="left">[[DefineOwnProperty]]</td>
<td align="left">defineProperty</td>
<td align="left">Object.defineProperty, Object.defineProperties</td>
</tr>
<tr>
<td align="left">[[GetOwnProperty]]</td>
<td align="left">getOwnPropertyDescriptor</td>
<td align="left">Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries</td>
</tr>
<tr>
<td align="left">[[OwnPropertyKeys]]</td>
<td align="left">ownKeys</td>
<td align="left">Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys/values/entries</td>
</tr>
</tbody></table>
<p><strong>get 捕获器</strong></p>
<p>要拦截读取操作，可以添加 get(target, property, receiver) 捕获器；</p>
<ul>
<li>target 是目标对象，该对象被作为第一个参数传递给 new Proxy；</li>
<li>property 目标属性名；</li>
<li>receiver 如果目标属性是一个 getter 访问器属性，则 receiver 就是本次读取属性所在的 this 对象，通常是 proxy 对象本身；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">numbers = <span class="keyword">new</span> <span class="built_in">Proxy</span>(numbers, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[prop];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert( numbers[<span class="number">1</span>] ); <span class="comment">// 1</span></span><br><span class="line">alert( numbers[<span class="number">123</span>] ); <span class="comment">// 0（没有这个数组项）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 代理应该在所有地方都完全替代目标对象，目标对象被代理后，任何人都不应该再引用目标对象；</p>
</blockquote>
<p><strong>set 捕获器</strong></p>
<p>set(target, property, value, receiver)，当写入属性时 set 捕捉器被触发，其中 value 为目标属性的值；如果写入操作（setting）成功，set 捕捉器应该返回 true，否则返回 false（触发 TypeError）；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onlyNumbers = [];</span><br><span class="line"></span><br><span class="line">onlyNumbers = <span class="keyword">new</span> <span class="built_in">Proxy</span>(onlyNumbers, &#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, prop, val</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 拦截写入属性操作</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> val == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">            target[prop] = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">onlyNumbers.push(<span class="number">1</span>); <span class="comment">// 添加成功</span></span><br><span class="line">onlyNumbers.push(<span class="number">2</span>); <span class="comment">// 添加成功</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Length is: &quot;</span> + onlyNumbers.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: &#x27;set&#x27; on proxy: trap returned falsish for property &#x27;2</span></span><br><span class="line">onlyNumbers.push(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>ownKeys 和 getOwnPropertyDescriptor 捕获器</strong></p>
<p>Object.keys，for..in 循环和大多数其他遍历对象属性的方法都使用内部方法 [[OwnPropertyKeys]]（由 ownKeys 捕捉器拦截) 来获取属性列表；</p>
<ul>
<li>Object.getOwnPropertyNames(obj) 返回非 Symbol 键；</li>
<li>Object.getOwnPropertySymbols(obj) 返回 Symbol 键；</li>
<li>Object.keys/values() 返回带有 enumerable 标志的非 Symbol 键/值；</li>
<li>for..in 循环遍历所有带有 enumerable 标志的非 Symbol 键，以及原型对象的键；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;Coley&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">    <span class="comment">// 使用 ownKeys 捕捉器拦截 for..in 对 user 的遍历</span></span><br><span class="line">    <span class="comment">// 一旦要获取属性列表就会被调用，可以返回不相干的属性</span></span><br><span class="line">    <span class="function"><span class="title">ownKeys</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// return Object.keys(target).filter(key =&gt; !key.startsWith(&#x27;_&#x27;));</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line">        <span class="comment">// 返回没有的属性，其描述符为空，没有 enumerable 标志，会被略过，需要 getOwnPropertyDescriptor 返回 enumerable 为 true；</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getOwnPropertyDescriptor</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 被每个属性调用</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>, <span class="comment">// false 屏蔽，使属性不可迭代</span></span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">            <span class="comment">/* ...其他标志，可能是 &quot;value:...&quot; */</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(user)); <span class="comment">// a, b, c</span></span><br></pre></td></tr></table></figure>

<p><strong>deleteProperty 捕获器</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    _password: <span class="string">&quot;***&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">checkPassword</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//对象方法必须能读取 _password</span></span><br><span class="line">        <span class="keyword">return</span> value === <span class="built_in">this</span>._password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop.startsWith(<span class="string">&quot;_&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Access denied&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> value = target[prop];</span><br><span class="line">        <span class="comment">// 内部方法可以读取内部属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&quot;function&quot;</span> ? value.bind(target) : value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 拦截属性删除</span></span><br><span class="line">        <span class="keyword">if</span> (prop.startsWith(<span class="string">&quot;_&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Access denied&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">delete</span> target[prop];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;get&quot; 不允许读取 _password</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(user._password); <span class="comment">// Error: Access denied</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;deleteProperty&quot; 不允许删除 _password</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> user._password; <span class="comment">// Error: Access denied</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>has 捕获器</strong></p>
<p>has 捕捉器会拦截 in 调用，因此可以实现 in 操作符来检查一个数字是否在 range 范围内；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">    start: <span class="number">1</span>,</span><br><span class="line">    end: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">range = <span class="keyword">new</span> <span class="built_in">Proxy</span>(range, &#123;</span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prop &gt;= target.start &amp;&amp; prop &lt;= target.end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> <span class="keyword">in</span> range); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">50</span> <span class="keyword">in</span> range); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>apply 捕获器</strong></p>
<p>apply(target, thisArg, args) 捕捉器能使代理以函数的方式被调用；</p>
<ul>
<li>target 是目标对象（函数也是对象）；</li>
<li>thisArg 是 this 的值；</li>
<li>args 是参数列表；</li>
</ul>
<p>普通的包装函数不会转发属性读取/写入操作或者任何其他操作；进行包装后，就失去了对原始函数属性的访问，例如 name，length 和其他属性；使用 Proxy 可以将所有操作都能被转发到原始函数；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">f, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(f, &#123;</span><br><span class="line">        <span class="function"><span class="title">apply</span>(<span class="params">target, thisArg, args</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> target.apply(thisArg, args), ms);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;user&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi = delay(sayHi, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sayHi.length); <span class="comment">// 1 (*) proxy 将“获取 length”的操作转发给目标对象</span></span><br><span class="line"></span><br><span class="line">sayHi(<span class="string">&quot;John&quot;</span>); <span class="comment">// Hello, John!（3 秒后）</span></span><br></pre></td></tr></table></figure>

<p>Reflect 是一个内建对象，可简化 Proxy 的创建；Reflect 对象使调用这些内部方法成为了可能，它的方法是内部方法的最小包装；</p>
<p>尤其是，Reflect 允许我们将操作符（new，delete，……）作为函数（Reflect.construct，Reflect.deleteProperty，……）执行调用；</p>
<p>此外，对于每个可被 Proxy 捕获的内部方法，在 Reflect 中都有一个对应的方法，其名称和参数与 Proxy 捕捉器相同；所以，如果一个捕捉器想要将调用转发给对象，则只需使用相同的参数调用 <code>Reflect.&lt;method&gt;</code> 就足够了；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">age</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(user, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.name); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(user, <span class="string">&quot;no-such-prop&quot;</span>);</span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(user, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">`GET <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver); <span class="comment">// (1)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, prop, val, receiver</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">`SET <span class="subst">$&#123;prop&#125;</span>=<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, val, receiver); <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = user.name; <span class="comment">// 显示 &quot;GET name&quot;</span></span><br><span class="line">user.name = <span class="string">&quot;Pete&quot;</span>; <span class="comment">// 显示 &quot;SET name=Pete&quot;</span></span><br></pre></td></tr></table></figure>

<p>当存在原型继承时，特别是访问继承对象的 get 访问器属性时，需要用到 receiver 参数，保证将正确的 this 传递给 getter；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  _name: <span class="string">&quot;Guest&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123; <span class="comment">// receiver = admin</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver); <span class="comment">// (*)</span></span><br><span class="line">    <span class="comment">// 或者 return Reflect.get(...arguments);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  __proto__: userProxy,</span><br><span class="line">  _name: <span class="string">&quot;Admin&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(admin.name); <span class="comment">// Admin</span></span><br></pre></td></tr></table></figure>

<p>Proxy 存在一些局限性：</p>
<ul>
<li>内建对象具有“内部插槽”，对这些对象的访问无法被代理；</li>
<li>私有类字段也是如此，因为它们也是在内部使用插槽实现的；因此，代理方法的调用必须具有目标对象作为 this 才能访问它们；</li>
<li>对象的严格相等性检查 === 无法被拦截；</li>
<li>性能：基准测试（benchmark）取决于引擎，但通常使用最简单的代理访问属性所需的时间也要长几倍；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了“内部插槽”存储数据，而不通过 [[Get]]/[[Set]] 内部方法</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(map, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">    <span class="comment">// 会将将原始对象暴露给该方法，可能使其进一步传递并破坏其他代理功能；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value == <span class="string">&#x27;function&#x27;</span> ? value.bind(target) : value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.set(<span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">alert(proxy.get(<span class="string">&#x27;test&#x27;</span>)); <span class="comment">// 1（工作了！）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 出于历史原因，内建 <code>Array</code> 没有使用内部插槽，所以，代理数组时没有这种问题；</p>
</blockquote>
<p>一个可撤销的代理是可以被禁用的代理，<code>let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler)</code>；该调用返回一个带有 proxy 和 revoke 函数的对象以将其禁用；这样的代理会将操作转发给对象，并且我们可以随时将其禁用；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  data: <span class="string">&quot;Valuable data&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(object, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 proxy 传递到其他某处，而不是对象...</span></span><br><span class="line">alert(proxy.data); <span class="comment">// Valuable data</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍后，在我们的代码中</span></span><br><span class="line">revoke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy 不再工作（revoked）</span></span><br><span class="line">alert(proxy.data); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...<span class="string">&quot;abcde&quot;</span>];</span><br><span class="line"></span><br><span class="line">arr = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            prop = +prop + target.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy MDN 中文参考文档</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/proxy">JavaScript 现代教程-Proxy 和 Reflect</a></li>
</ul>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>调用 eval(code) 会运行代码字符串，并返回最后一条语句的结果；</p>
<p>严格模式下，eval 有属于自己的词法环境，因此我们不能从外部访问在 eval 中声明的函数和变量；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script 中</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&quot;this&quot;</span>)); <span class="comment">// window</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(this); let x = 6&quot;</span>); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&quot;this&quot;</span>)); <span class="comment">// obj</span></span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">&quot;console.log(this); let x = 8;&quot;</span>); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">window</span>.eval(<span class="string">&quot;this&quot;</span>)); <span class="comment">// window</span></span><br><span class="line">        <span class="built_in">window</span>.eval(<span class="string">&quot;console.log(this); let x = 10;&quot;</span>); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.func();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>

<p>不建议使用 eval：</p>
<ul>
<li>如果 eval 中的代码没有使用外部变量，请以 window.eval(…) 的形式调用 eval；</li>
<li>如果 eval 中的代码需要访问局部变量，我们可以使用 new Function 替代 eval，并将它们作为参数传递；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;alert(a)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">f(<span class="number">5</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="柯里化（Currying）"><a href="#柯里化（Currying）" class="headerlink" title="柯里化（Currying）"></a>柯里化（Currying）</h4><p>柯里化（Currying）是一种关于函数的高阶技术，柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)；柯里化不会调用函数，它只是对函数进行转换；</p>
<p>柯里化更高级的实现，如 lodash 库的 <a target="_blank" rel="noopener" href="https://lodash.com/docs#curry">_.curry</a>，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高级柯里化实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(args2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> curriedSum = curry(sum);</span><br><span class="line"></span><br><span class="line">alert( curriedSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) ); <span class="comment">// 6，仍然可以被正常调用</span></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>) ); <span class="comment">// 6，对第一个参数的柯里化</span></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) ); <span class="comment">// 6，全柯里化</span></span><br></pre></td></tr></table></figure>

<h4 id="Reference-Type"><a href="#Reference-Type" class="headerlink" title="Reference Type"></a>Reference Type</h4><p>为确保 obj.methed() 调用正常运行，JavaScript 中点 ‘.’ 返回的不是一个函数，而是一个特殊的 Reference Type 的值；</p>
<p>Reference Type 是 ECMA 中的一个“规范类型”，被用在 JavaScript 语言内部，因此不能直接使用它；</p>
<p>Reference Type 的值是一个三个值的组合 (base, name, strict)，其中：</p>
<ul>
<li>base 是对象；</li>
<li>name 是属性名；</li>
<li>strict 在 use strict 模式下为 true；</li>
</ul>
<p>当 () 被在 Reference Type 上调用时，它们会接收到关于对象和对象的方法的完整信息，然后可以设置正确的 this；Reference Type 是一个特殊的“中间人”内部类型，目的是从 . 传递信息给 () 调用；</p>
<p>任何例如赋值 func = obj.func 等其他的操作，都会将 Reference Type 作为一个整体丢弃掉，而会取 obj.func（一个函数）的值并继续传递，所以任何后续操作都“丢失”了 this；</p>
<p>this 的值仅在函数直接被通过点符号 obj.method() 或方括号 obj<a href="">‘method’</a> 语法（此处它们作用相同）调用时才被正确传递；除了方法调用之外的任何操作（如赋值 = 或 ||），都会把它转换为一个不包含允许设置 this 信息的普通值；</p>
<h4 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h4><p>BigInt 是一种特殊的数字类型，它提供了对任意长度整数的支持；创建 bigint 的方式有两种：在一个整数字面量后面加 n 或者调用 BigInt 函数，该函数从字符串、数字等中生成 bigint；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bigint = <span class="number">1234567890123456789012345678901234567890n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sameBigint = <span class="built_in">BigInt</span>(<span class="string">&quot;1234567890123456789012345678901234567890&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bigintFromNumber = <span class="built_in">BigInt</span>(<span class="number">10</span>); <span class="comment">// 与 10n 相同</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 对 <code>bigint</code> 的所有操作，返回的结果也是 <code>bigint</code>；不可以把 <code>bigint</code> 和常规数字类型混合使用；<code>BigInt</code> 不支持一元加法；</p>
</blockquote>
<blockquote>
<p>Note: 转换操作始终是静默的，绝不会报错，但是如果 <code>bigint</code> 太大而数字类型无法容纳，则会截断多余的位，因此我们应该谨慎进行此类转换；</p>
</blockquote>
<blockquote>
<p>Note: 由于 <code>number</code> 和 <code>bigint</code> 属于不同类型，它们可能在进行 <code>==</code> 比较时相等，但在进行 <code>===</code>（严格相等）比较时不相等；</p>
</blockquote>
<p>当在 if 或其他布尔运算中时，bigint 的行为类似于 number，在 if 中，bigint 0n 为假，其他值为 true；</p>
<p>目前并没有一个众所周知的好用的 polyfill，不过，<a target="_blank" rel="noopener" href="https://github.com/GoogleChromeLabs/jsbi">JSBI</a> 库提出了另一种解决方案，该库使用自己的方法实现了大的数字，可以使用它们替代原生的 bigint；</p>
<h4 id="浏览器环境，规格"><a href="#浏览器环境，规格" class="headerlink" title="浏览器环境，规格"></a>浏览器环境，规格</h4><p>JavaScript 规范将能运行 JavaScript 的环境称为主机环境，每个环境都提供了特定于平台的功能；</p>
<p>文档对象模型（Document Object Model），简称 DOM，将所有页面内容表示为可以修改的对象；document 对象是页面的主要“入口点”，我们可以使用它来更改或创建页面上的任何内容；</p>
<p>另外也有一份针对 CSS 规则和样式表的、单独的规范 CSS Object Model (CSSOM)，这份规范解释了如何将 CSS 表示为对象，以及如何读写这些对象；</p>
<p>浏览器对象模型（Browser Object Model），简称 BOM，表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象；</p>
<h4 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h4><p>根据文档对象模型（DOM），每个 HTML 标签都是一个对象，嵌套的标签是闭合标签的“子标签（children）”，标签内的文本也是一个对象；</p>
<p>标签被称为 元素节点（或者仅仅是元素），并形成了树状结构：<code>&lt;html&gt;</code> 在根节点；元素内的文本形成 文本节点，被标记为 <code>＃text</code>；一个文本节点只包含一个字符串，它没有子项，并且总是树的叶子；</p>
<blockquote>
<p>Note: 由于历史原因，<code>&lt;head&gt;</code> 之前的空格和换行符均被忽略，如果我们在 <code>&lt;/body&gt;</code> 之后放置一些东西，那么它会被自动移动到 body 内，并处于 body 中的最下方，因为 HTML 规范要求所有内容必须位于 <code>&lt;body&gt;</code> 内；</p>
</blockquote>
<p>如果浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它；</p>
<ul>
<li>将文档中纯文本内容包装到 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code>，并添加<code>&lt;head&gt;</code>；</li>
<li>自动添加关闭标签；</li>
<li>自动为 <code>&lt;table&gt;</code> 创建缺失的 <code>&lt;tbody&gt;</code>；</li>
</ul>
<blockquote>
<p>Note: <code>HTML</code> 中的所有内容，包括注释，都会成为 <code>DOM</code> 的一部分，甚至 <code>HTML</code> 开头的 <code>&lt;!DOCTYPE...&gt;</code> 指令也是一个 <code>DOM</code> 节点；</p>
</blockquote>
<p>常用的4中 DOM 节点：</p>
<ul>
<li>document：DOM 的“入口点”；</li>
<li>元素节点：HTML 标签，树构建块；</li>
<li>文本节点：包含文本；</li>
<li>注释：有时我们可以将一些信息放入其中，它不会显示，但 JS 可以从 DOM 中读取它；</li>
</ul>
<blockquote>
<p>Tips: 浏览器开发者工具中，可以通过 <code>$0</code> 来进行操作最后选中的元素，先前选择的是 <code>$1</code>，<code>$2</code>…以此类推；如果存在引用 <code>DOM</code> 节点的变量，那么我们可以在控制台（Console）中使用命令 <code>inspect(node)</code>，来在元素（Elements）选项卡中查看它；</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="http://software.hixie.ch/utilities/js/live-dom-viewer/">查看 DOM 结构在线工具</a></li>
</ul>
<h4 id="遍历-DOM"><a href="#遍历-DOM" class="headerlink" title="遍历 DOM"></a>遍历 DOM</h4><p>最顶层的 document 节点是 document.documentElement，这是对应 <code>&lt;html&gt;</code> 标签的 DOM 节点；document.body 对应 <code>&lt;body&gt;</code>，document.head 对应 <code>&lt;head&gt;</code>；</p>
<p><strong>访问子节点</strong></p>
<p>childNodes 集合列出了所有子节点，包括文本节点和注释节点；childNodes 实际上并不是一个数组，而是一个类数组的可迭代对象，成为 DOM 集合；</p>
<blockquote>
<p>Note: DOM 集合是只读的，且几乎所有的 DOM 集合都是实时的，即它们反映了 DOM 的当前状态；</p>
</blockquote>
<p>firstChild 和 lastChild 属性是访问第一个和最后一个子元素的快捷方式，还有一个特别的函数 elem.hasChildNodes() 用于检查节点是否有子节点；</p>
<p><strong>访问兄弟节点和父节点</strong></p>
<p>下一个兄弟节点在 nextSibling 属性中，上一个是在 previousSibling 属性中；通过 parentNode 来访问父节点；</p>
<p><strong>纯元素导航</strong></p>
<p>但希望操纵的是代表标签的和形成页面结构的元素节点时，使用：</p>
<ul>
<li>使用 children 访问那些作为元素节点的子代的节点；</li>
<li>firstElementChild，lastElementChild 访问标签子元素；</li>
<li>previousElementSibling，nextElementSibling 访问标签子元素；</li>
<li>parentElement 访问标签父节点；</li>
</ul>
<blockquote>
<p>Note: <code>parentElement</code> 属性返回的是“元素类型”的父节点，而 <code>parentNode</code> 返回的是“任何类型”的父节点，这些属性通常来说是一样的：它们都是用于获取父节点；除了 <code>document.documentElement</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="built_in">document</span>.documentElement.parentNode ); <span class="comment">// document</span></span><br><span class="line">alert( <span class="built_in">document</span>.documentElement.parentElement ); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意节点 elem</span></span><br><span class="line"><span class="keyword">while</span>(elem = elem.parentElement) &#123; <span class="comment">// 向上，直到 &lt;html&gt;</span></span><br><span class="line">  alert( elem );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="搜索：getElement，querySelector"><a href="#搜索：getElement，querySelector" class="headerlink" title="搜索：getElement，querySelector"></a>搜索：getElement<em>，querySelector</em></h4><p><strong>getElementById</strong></p>
<p>如果一个元素有 id 特性（attribute），那我们就可以使用 document.getElementById(id) 方法获取该元素；</p>
<blockquote>
<p>Note: 通过 <code>id</code> 命名的全局变量来访问元素，这是规范中考虑到兼容性描述的一种标准；但是这可能会造成命名冲突，不建议使用；</p>
</blockquote>
<p><strong>querySelector 和 querySelectorAll</strong></p>
<p>elem.querySelector(css) 调用会返回给定 CSS 选择器的第一个元素，elem.querySelectorAll(css)，返回 elem 中与给定 CSS 选择器匹配的所有元素，都支持 css 伪类；</p>
<p><strong>matches</strong></p>
<p>elem.matches(css) 不会查找任何内容，它只会检查 elem 是否与给定的 CSS 选择器匹配，它返回 true 或 false；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> <span class="built_in">document</span>.body.children) &#123;</span><br><span class="line">  <span class="keyword">if</span> (elem.matches(<span class="string">&#x27;a[href$=&quot;zip&quot;]&#x27;</span>)) &#123;</span><br><span class="line">    alert(<span class="string">&quot;The archive reference: &quot;</span> + elem.href );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>closest</strong></p>
<p>elem.closest(css) 方法会查找与 CSS 选择器匹配的最近的祖先，包括 elem 本身；</p>
<p><strong>getElementsBy*</strong></p>
<ul>
<li>elem.getElementsByTagName(tag) 查找具有给定标签的元素，并返回它们的集合，tag 参数也可以是对于任何标签的通配符 <code>*</code>；</li>
<li>elem.getElementsByClassName(className) 返回具有给定CSS类的元素；</li>
<li>document.getElementsByName(name) 返回在文档范围内具有给定 name 特性的元素；</li>
</ul>
<blockquote>
<p>Note: 所有的 <code>getElementsBy*</code> 方法都会返回一个 实时的（live）集合，这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”；而 <code>querySelectorAll</code> 返回的是一个静态的集合；</p>
</blockquote>
<h4 id="节点属性：type，tag-和-content"><a href="#节点属性：type，tag-和-content" class="headerlink" title="节点属性：type，tag 和 content"></a>节点属性：type，tag 和 content</h4><p>EventTarget 是根的“抽象（abstract）”类，该类的对象从未被创建；它作为一个基础，以便让所有 DOM 节点都支持所谓的“事件（event）”；</p>
<p>Node 也是一个“抽象”类，充当 DOM 节点的基础；它提供了树的核心功能：parentNode，nextSibling，childNodes 等（它们都是 getter）；Node 类的对象从未被创建，但是有一些继承自它的具体的节点类，例如：文本节点的 Text，元素节点的 Element，注释节点的 Comment；</p>
<p>Element 是 DOM 元素的基本类；它提供了元素级的导航（navigation），例如 nextElementSibling，children，以及像 getElementsByTagName 和 querySelector 这样的搜索方法；浏览器中不仅有 HTML，还会有 XML 和 SVG，Element 类充当更多特定类的基本类：SVGElement，XMLElement 和 HTMLElement；</p>
<blockquote>
<p>Note: <code>document</code> 是 <code>HTMLDocument</code> 类的一个实例；</p>
</blockquote>
<p><strong>nodeType 属性</strong></p>
<p>nodeType 属性提供了另一种“过时的”用来获取 DOM 节点类型的方法；该属性是一个只读的数值型值：</p>
<ul>
<li>对于元素节点 elem.nodeType == 1；</li>
<li>对于文本节点 elem.nodeType == 3；</li>
<li>对于 document 对象 elem.nodeType == 9；</li>
</ul>
<p><strong>标签：nodeName 和 tagName</strong></p>
<p>可以从 nodeName 或者 tagName 属性中读取一个 DOM 节点的标签名；tagName 属性仅适用于 Element 节点；nodeName 是为任意 Node 定义的，对于元素，它的意义与 tagName 相同，对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="built_in">document</span>.body.nodeName ); <span class="comment">// BODY</span></span><br><span class="line">alert( <span class="built_in">document</span>.body.tagName ); <span class="comment">// BODY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for comment</span></span><br><span class="line">alert( <span class="built_in">document</span>.body.firstChild.tagName ); <span class="comment">// undefined（不是一个元素）</span></span><br><span class="line">alert( <span class="built_in">document</span>.body.firstChild.nodeName ); <span class="comment">// #comment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for document</span></span><br><span class="line">alert( <span class="built_in">document</span>.tagName ); <span class="comment">// undefined（不是一个元素）</span></span><br><span class="line">alert( <span class="built_in">document</span>.nodeName ); <span class="comment">// #document</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>浏览器有两种处理文档（document）的模式：HTML 和 XML；通常，HTML 模式用于网页，只有在浏览器接收到带有 header Content-Type: application/xml+xhtml 的 XML-document 时，XML 模式才会被启用；</p>
</blockquote>
<p><strong>innerHTML：内容</strong></p>
<p>innerHTML 属性允许将元素中的 HTML 获取为字符串形式；innerHTML 属性仅对元素节点有效；</p>
<blockquote>
<p>Note: 如果 <code>innerHTML</code> 将一个 <code>&lt;script&gt;</code> 标签插入到 <code>document</code> 中，它会成为 <code>HTML</code> 的一部分，但是不会执行；</p>
</blockquote>
<blockquote>
<p>Note: <code>innerHTML+=</code> 会进行完全重写，该操作会先移除旧内容，然后写入新内容，因此其内部的图片和其他资源都将重写加载；同时大多浏览器在 innerHTML 内容改变后会取消文字选中状态；</p>
</blockquote>
<p><strong>outerHTML：元素的完整 HTML</strong></p>
<p>outerHTML 属性包含了元素的完整 HTML，就像 innerHTML 加上元素本身一样；与 innerHTML 不同，写入 outerHTML 不会改变元素，而是在 DOM 中替换它；</p>
<p><strong>nodeValue/data：文本节点内容</strong></p>
<p>对于元素节点以外的其他节点类型，例如文本节点，具有它们的对应项：nodeValue 和 data 属性，这两者在实际使用中几乎相同，只有细微规范上的差异；因此可以将信息或模板说明嵌入到 HTML 中的注释中，然后从 data 属性中读取它，并处理嵌入的指令；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  Hello</span><br><span class="line">  <span class="comment">&lt;!-- Comment --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> text = <span class="built_in">document</span>.body.firstChild;</span></span><br><span class="line"><span class="javascript">    alert(text.data); <span class="comment">// Hello</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> comment = text.nextSibling;</span></span><br><span class="line"><span class="javascript">    alert(comment.data); <span class="comment">// Comment</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>textContent：纯文本</strong></p>
<p>textContent 提供了对元素内的 文本 的访问权限：仅文本，去掉所有 <code>&lt;tags&gt;</code>；textContent 允许以安全方式写入文本，所有符号（symbol）均按字面意义处理；</p>
<p><strong>hidden 属性</strong></p>
<p>“hidden” 特性（attribute）和 DOM 属性（property）指定元素是否可见，从技术上来说，hidden 与 style=”display:none” 做的是相同的事，但 hidden 写法更简洁；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Both divs below are hidden<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span>With the attribute &quot;hidden&quot;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>JavaScript assigned the property &quot;hidden&quot;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  elem.hidden = <span class="literal">true</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="特性和属性（Attributes-and-properties）"><a href="#特性和属性（Attributes-and-properties）" class="headerlink" title="特性和属性（Attributes and properties）"></a>特性和属性（Attributes and properties）</h4><p>当浏览器加载页面时，它会“读取”（或者称之为：“解析”）HTML 并从中生成 DOM 对象；对于元素节点，大多数标准的 HTML 特性（attributes）会自动变成 DOM 对象的属性（properties）；</p>
<blockquote>
<p>Note: <code>DOM</code> 节点是常规的 JavaScript 对象，<code>DOM</code> 属性和方法的行为就像常规的 Javascript 对象一样；</p>
</blockquote>
<p>在 HTML 中，标签可能拥有特性（attributes），当浏览器解析 HTML 文本，并根据标签创建 DOM 对象时，浏览器会辨别 标准的 特性并以此创建 DOM 属性；</p>
<p>如果一个特性不是标准的，那么就没有相对应的 DOM 属性，所有特性都可以通过使用以下方法进行访问：</p>
<ul>
<li>elem.hasAttribute(name) 检查特性是否存在；</li>
<li>elem.getAttribute(name) 获取这个特性值；</li>
<li>elem.setAttribute(name, value) 设置这个特性值；</li>
<li>elem.removeAttribute(name) 移除这个特性；</li>
</ul>
<p>或者也可以使用 elem.attributes 读取所有特性：属于内建 Attr 类的对象的集合，attributes 集合是可迭代对象，该对象将所有元素的特性（标准和非标准的）作为 name 和 value 属性存储在对象中；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span> <span class="attr">about</span>=<span class="string">&quot;Elephant&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    alert( elem.getAttribute(<span class="string">&#x27;About&#x27;</span>) ); <span class="comment">// (1) &#x27;Elephant&#x27;，读取</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    elem.setAttribute(<span class="string">&#x27;Test&#x27;</span>, <span class="number">123</span>); <span class="comment">// (2) 写入</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    alert( elem.outerHTML ); <span class="comment">// (3) 查看特性是否在 HTML 中（在）</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">of</span> elem.attributes) &#123; <span class="comment">// (4) 列出所有</span></span></span><br><span class="line"><span class="javascript">      alert( <span class="string">`<span class="subst">$&#123;attr.name&#125;</span> = <span class="subst">$&#123;attr.value&#125;</span>`</span> );</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外 HTML 特性的名字是大小写不敏感的，其次特性的值总是字符串类型的；</p>
<p>当一个标准的特性或者属性被改变，对应的属性或者特性也会自动更新；</p>
<blockquote>
<p>Note: 但也有例外，如 <code>input.value</code> 只能从特性同步到属性，可用于用户行为导致 <code>value</code> 的更改，然后在这些操作之后，从 <code>HTML</code> 的特性中恢复“原始”值；</p>
</blockquote>
<p>其他特例：</p>
<ul>
<li>input.checked 属性（对于 checkbox 的）是布尔型的；</li>
<li>style 特性是字符串类型的，但 style 属性是一个对象；</li>
<li>href DOM 属性一直是一个 完整的 URL，即使该特性包含一个相对路径或者包含一个 #hash；</li>
</ul>
<p><strong>非标准的特性，dataset</strong></p>
<p>非标准的特性常常用于将自定义的数据从 HTML 传递到 JavaScript，或者用于为 JavaScript “标记” HTML 元素；</p>
<p>以 “data-” 开头的特性均被保留供开发者使用，并且它们可在 dataset 属性中使用；多个单词组合的特性，会转成对应的驼峰命名的属性；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">data-about</span>=<span class="string">&quot;Elephants&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  alert(<span class="built_in">document</span>.body.dataset.about); <span class="comment">// Elephants</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改文档（document）"><a href="#修改文档（document）" class="headerlink" title="修改文档（document）"></a>修改文档（document）</h4><p><strong>创建元素</strong></p>
<ul>
<li>document.createElement(tag) 用给定的标签创建一个新 元素节点（element node）；</li>
<li>document.createTextNode(text) 用给定的文本创建一个 文本节点；</li>
</ul>
<p><strong>插入元素</strong></p>
<p>字符串被以一种安全的方式插入到页面中，特殊符号都会被作转义处理来保证正确显示；</p>
<ul>
<li>node.append(…nodes or strings) 在 node 末尾插入节点或字符串；</li>
<li>node.prepend(…nodes or strings) 在 node 开头插入节点或字符串；</li>
<li>node.before(…nodes or strings) 在 node 前面插入节点或字符串；</li>
<li>node.after(…nodes or strings) 在 node 后面插入节点或字符串；</li>
<li>node.replaceWith(…nodes or strings) 将 node 替换为给定的节点或字符串；</li>
</ul>
<p>旧方法都会返回插入/删除的节点：</p>
<ul>
<li>parentElem.appendChild(node) 将 node 附加为 parentElem 的最后一个子元素；</li>
<li>parentElem.insertBefore(node, nextSibling) 在 parentElem 的 nextSibling 前插入 node；</li>
<li>parentElem.replaceChild(node, oldChild) 将 parentElem 的后代中的 oldChild 替换为 node；</li>
<li>parentElem.removeChild(node) 从 parentElem 中删除 node（假设 node 为 parentElem 的后代）；</li>
</ul>
<p><strong>插入代码块</strong></p>
<p>elem.insertAdjacentHTML(where, html) 方法第一个参数是代码字（code word），指定相对于 elem 的插入位置，第二个参数是 HTML 字符串，该字符串会被“作为 HTML” 插入；</p>
<ul>
<li>“beforebegin” 将 html 插入到 elem 前插入；</li>
<li>“afterbegin” 将 html 插入到 elem 开头；</li>
<li>“beforeend” 将 html 插入到 elem 末尾；</li>
<li>“afterend” 将 html 插入到 elem 后；</li>
</ul>
<p>elem.insertAdjacentText(where, text) 语法一样，但是将 text 字符串“作为文本”插入而不是作为 HTML；elem.insertAdjacentElement(where, elem) 语法一样，但是插入的是一个元素；</p>
<p><strong>移除节点</strong></p>
<p>可以使用 node.remove() 移除一个节点；或者通过插入方法移动节点；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span>&gt;</span>First<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;second&quot;</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 无需调用 remove</span></span></span><br><span class="line"><span class="javascript">  second.after(first); <span class="comment">// 获取 #second，并在其后面插入 #first</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>克隆节点</strong></p>
<p>调用 elem.cloneNode(true) 来创建元素的一个“深”克隆，具有所有特性（attribute）和子元素，如果我们调用 elem.cloneNode(false)，那克隆就不包括子元素；</p>
<p><strong>DocumentFragment</strong></p>
<p>DocumentFragment 是一个特殊的 DOM 节点，用作来传递节点列表的包装器（wrapper）；</p>
<p><strong>document.write</strong></p>
<p>调用 document.write(html) 意味着将 html “就地马上”写入页面，html 字符串可以是动态生成的，所以它很灵活，可以使用 JavaScript 创建一个完整的页面并对其进行写入；</p>
<p>document.write 调用只在页面加载时工作，如果页面加载完成后调用，则现有文档内容将被擦除；</p>
<p>从技术上讲，当在浏览器正在读取（“解析”）传入的 HTML 时调用 document.write 方法来写入一些东西，浏览器会像它本来就在 HTML 文本中那样使用它，因为不涉及 DOM 修改，所以运行起来出奇的快；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除元素内子元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (elem.firstChild) &#123;</span><br><span class="line">    elem.firstChild.remove();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">  elem.innerHTML = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 根据规范，<code>&lt;table&gt;</code> 只允许特定于表格的标签，浏览器会把 <code>&lt;table&gt;</code> 内的文本添加到了表格前面；</p>
</blockquote>
<h4 id="样式和类"><a href="#样式和类" class="headerlink" title="样式和类"></a>样式和类</h4><p>通常有两种设置元素样式的方式：</p>
<ul>
<li>在 CSS 中创建一个类，并添加它：<code>&lt;div class=&quot;...&quot;&gt;</code>；</li>
<li>将属性直接写入 style：<code>&lt;div style=&quot;...&quot;&gt;</code>；</li>
</ul>
<p>属性 className 对应于 “class” 特性；如果对 elem.className 进行赋值，它将替换类中的整个字符串；classList 是一个特殊的对象，它具有 add/remove/toggle 单个类的方法；</p>
<ul>
<li>elem.classList.add/remove(class) 添加/移除类；</li>
<li>elem.classList.toggle(class) 如果类不存在就添加类，存在就移除它；</li>
<li>elem.classList.contains(class) 检查给定类，返回 true/false；</li>
</ul>
<p>elem.style 属性是一个对象，它对应于 “style” 特性（attribute）中所写的内容，对于多词（multi-word）属性，使用驼峰式 camelCase；</p>
<blockquote>
<p>Note: 像 <code>-moz-border-radius</code> 和 <code>-webkit-border-radius</code> 这样的浏览器前缀属性，也遵循同样的规则：连字符 <code>-</code> 表示大写；</p>
</blockquote>
<p>我们使用 style.* 来对各个样式属性进行赋值，使用特殊属性 style.cssText 以字符串的形式设置完整的样式；</p>
<h4 id="计算样式：getComputedStyle"><a href="#计算样式：getComputedStyle" class="headerlink" title="计算样式：getComputedStyle"></a>计算样式：getComputedStyle</h4><p>style 属性仅对 “style” 特性（attribute）值起作用，而没有任何 CSS 级联（cascade）；</p>
<p>使用 getComputedStyle(element, [pseudo]) 方法获取元素的计算属性；其中 element 是需要被读取样式值的元素，pseudo 伪元素（如果需要），空字符串或无参数则意味着元素本身，结果是一个具有样式属性解析值的对象；</p>
<blockquote>
<p>Note: 计算 (computed) 样式值是所有 CSS 规则和 CSS 继承都应用后的值，这是 CSS 级联（cascade）的结果；解析 (resolved) 样式值是最终应用于元素的样式值值，浏览器将使用计算（computed）值，并使所有单位均为固定的，且为绝对单位；</p>
</blockquote>
<blockquote>
<p>Note: JavaScript 看不到 <code>:visited</code> 所应用的样式；此外，CSS 中也有一个限制，即禁止在 <code>:visited</code> 中应用更改几何形状的样式，这是为了确保一个不好的页面无法测试链接是否被访问，进而窥探隐私；</p>
</blockquote>
<h4 id="元素大小和滚动"><a href="#元素大小和滚动" class="headerlink" title="元素大小和滚动"></a>元素大小和滚动</h4><blockquote>
<p>Note: 一些浏览器（并非全部）通过从内容（上面标记为 “content width”）中获取空间来为滚动条保留空间；</p>
</blockquote>
<p>offsetParent 是最接近的 CSS 定位的祖先，或者是 td，th，table，body；</p>
<blockquote>
<p>Note: 有以下几种情况下，<code>offsetParent</code> 的值为 <code>null</code>：</p>
<ul>
<li>对于未显示的元素（display:none 或者不在文档中）；</li>
<li>对于 <code>&lt;body&gt;</code> 与 <code>&lt;html&gt;</code>；</li>
<li>对于带有 position:fixed 的元素；</li>
</ul>
</blockquote>
<p>属性 offsetLeft/offsetTop 提供相对于 offsetParent 左上角的 x/y 坐标；<br>属性 offsetWidth/offsetHeight 提供了元素的“外部” width/height，包括边框的完整大小；</p>
<blockquote>
<p>Note: 如果一个元素（或其任何祖先）具有 <code>display:none</code> 或不在文档中，则所有几何属性均为零（或 offsetParent 为 null）；</p>
</blockquote>
<p>属性 clientLeft/clientTop 在元素内部，用于测量内侧与外侧的相对坐标，大多数情况下其数值等于边框宽高，但当滚动条在左侧时，clientLeft 等于左边框宽加滚动条宽度；</p>
<p>属性 clientWidth/clientHeight 包括了 “content width” 和 “padding”，但不包括滚动条宽度；</p>
<p>属性 scrollWidth/scrollHeight 是内容区域的完整内部宽度/高度，包括滚动出的部分；<br>属性 scrollLeft/scrollTop 是元素的隐藏、滚动部分的 width/height；</p>
<blockquote>
<p>Tips: 大多数几何属性是只读的，但是 <code>scrollLeft/scrollTop</code> 是可修改的，并且浏览器会滚动该元素；</p>
</blockquote>
<blockquote>
<p>Note: CSS <code>width/height</code> 取决于另一个属性：<code>box-sizing</code>，它定义了“什么是” CSS 宽度和高度，出于 CSS 的目的而对 <code>box-sizing</code> 进行的更改可能会破坏此类 JavaScript 操作，其次，CSS 的 <code>width/height</code> 可能是 <code>auto</code>，有时滚动条也会造成一定的影响；因此通常不从 CSS 中获取 <code>width/height</code>；</p>
</blockquote>
<blockquote>
<p>Tips: 可以创建一个带有滚动条的元素，但是没有边框（border）和内边距（padding），其全宽度 <code>offsetWidth</code> 和内部内容宽度 <code>clientWidth</code> 之间的差值就是滚动条的宽度；</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/size-and-scroll">JavaScript 现代教程-元素大小和滚动文档</a></li>
</ul>
<h4 id="Window-大小和滚动"><a href="#Window-大小和滚动" class="headerlink" title="Window 大小和滚动"></a>Window 大小和滚动</h4><p>可以使用 document.documentElement 的 clientWidth/clientHeight 获取窗口宽高；浏览器也支持像 window.innerWidth/innerHeight 这样的属性，window.innerWidth/innerHeight 包括了滚动条；</p>
<blockquote>
<p>Tips: <code>window.innerWidth - document.documentElement.clientWidth</code> 也可获得滚动条宽度；</p>
</blockquote>
<p>为了可靠地获得完整的文档高度，我们应该采用以下这些属性的最大值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollHeight = <span class="built_in">Math</span>.max(</span><br><span class="line">  <span class="built_in">document</span>.body.scrollHeight, <span class="built_in">document</span>.documentElement.scrollHeight,</span><br><span class="line">  <span class="built_in">document</span>.body.offsetHeight, <span class="built_in">document</span>.documentElement.offsetHeight,</span><br><span class="line">  <span class="built_in">document</span>.body.clientHeight, <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;Full document height, with scrolled out part: &#x27;</span> + scrollHeight);</span><br></pre></td></tr></table></figure>

<p>使用 window.pageXOffset/pageYOffset 属性获取当前滚动位置；使用特殊方法 window.scrollBy(x,y) 和 window.scrollTo(pageX,pageY) 实现页面滚动；</p>
<ul>
<li>方法 scrollBy(x,y) 将页面滚动至 相对于当前位置的 (x, y) 位置；</li>
<li>方法 scrollTo(pageX,pageY) 将页面滚动至 绝对坐标，使得可见部分的左上角具有相对于文档左上角的坐标 (pageX, pageY)；</li>
<li>对 elem.scrollIntoView(top) 的调用将滚动页面以使 elem 可见；如果 top=true（默认值），页面滚动，使 elem 出现在窗口顶部，元素的上边缘将与窗口顶部对齐，如果 top=false，页面滚动，使 elem 出现在窗口底部，元素的底部边缘将与窗口底部对齐；</li>
</ul>
<blockquote>
<p>Tips: 使用 <code>elem.style.overflow = &quot;hidden&quot;</code> 禁止滚动；</p>
</blockquote>
<h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><p>大多数 JavaScript 方法处理的是以下两种坐标系中的一个：</p>
<ul>
<li>相对于窗口：类似于 position:fixed，从窗口的顶部/左侧边缘计算得出（clientX/clientY）；</li>
<li>相对于文档：与文档根（document root）中的 position:absolute 类似，从文档的顶部/左侧边缘计算得出（pageX/pageY）；</li>
</ul>
<p>clientX/clientY 窗口相对坐标随着页面滚动会发生变化，因为同一个点越来越靠近窗口左侧/顶部；<br>pageX/pageY 元素在文档中的相对坐标保持不变，从文档顶部（现在已滚动出去）开始计算；</p>
<p>方法 elem.getBoundingClientRect() 返回最小矩形的窗口坐标，该矩形将 elem 作为内建 DOMRect 类的对象；包括以下属性：</p>
<ul>
<li>x/y：矩形原点相对于窗口的 X/Y 坐标；</li>
<li>width/height：矩形的 width/height（可以为负）；</li>
<li>top/bottom：顶部/底部矩形边缘的 Y 坐标；</li>
<li>left/right：左/右矩形边缘的 X 坐标；</li>
</ul>
<blockquote>
<p>Note: 由于历史原因，IE 浏览器不支持 x/y 属性；</p>
</blockquote>
<p>对 document.elementFromPoint(x, y) 的调用会返回在窗口坐标 (x, y) 处嵌套最多（the most nested）的元素；只对在可见区域内的坐标 (x,y) 起作用，对于在窗口之外的坐标，elementFromPoint 返回 null；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> centerX = <span class="built_in">document</span>.documentElement.clientWidth / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> centerY = <span class="built_in">document</span>.documentElement.clientHeight / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> elem = <span class="built_in">document</span>.elementFromPoint(centerX, centerY);</span><br><span class="line">elem.style.background = <span class="string">&quot;red&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元素的文档坐标</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCoords</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> box = elem.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    top: box.top + <span class="built_in">window</span>.pageYOffset,</span><br><span class="line">    right: box.right + <span class="built_in">window</span>.pageXOffset,</span><br><span class="line">    bottom: box.bottom + <span class="built_in">window</span>.pageYOffset,</span><br><span class="line">    left: box.left + <span class="built_in">window</span>.pageXOffset</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>当 HTML 的加载和处理均完成，DOM 被完全构建完成时触发 DOMContentLoaded 事件；当一个 CSS 动画完成时会触发 transitionend 事件；</p>
<p><strong>事件处理程序</strong></p>
<p>为了对事件作出响应，可以分配一个在事件发生时运行的函数处理程序（handler）；处理程序可以设置在 HTML 中名为 <code>on&lt;event&gt;</code> 的特性（attribute）中，也可以使用 DOM 属性（property）<code>on&lt;event&gt;</code> 来分配处理程序；</p>
<p>如果一个处理程序是通过 HTML 特性（attribute）分配的，那么随后浏览器读取它，并从特性的内容创建一个新函数，并将这个函数写入 DOM 属性（property）；</p>
<p>每个事件只有一个 <code>on&lt;event&gt;</code> 属性，无法分配更多事件处理程序；通过为 <code>on&lt;event&gt;</code> 属性赋值 null 可以移除处理程序；当浏览器读取 HTML 特性（attribute）时，浏览器将会使用特性中的内容（函数调用或多个语句）创建一个处理程序；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js 中方法不加括号</span></span><br><span class="line">button.onclick = sayThanks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html 中方法要加括号</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;button&quot; id=&quot;button&quot; onclick=&quot;sayThanks()&quot;&gt;</span></span><br><span class="line"></span><br><span class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  sayThanks(); <span class="comment">// &lt;-- 特性（attribute）中的内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 处理程序中的 this 的值是对应的元素，就是处理程序所在的那个元素；</p>
</blockquote>
<blockquote>
<p>因为特性总是字符串的，函数变成了一个字符串，因此使用 setAttribute 设置处理程序会失效；</p>
</blockquote>
<p>使用特殊方法 addEventListener 和 removeEventListener 来分配管理多个处理程序；</p>
<p>element.addEventListener(event, handler[, options]) 参数分别为 event 事件名，handler 处理程序，options 附加可选对象；如果同一事件设置有多个事件处理程序，并通过 addEventListener 分配给了相同的元素，则它们的运行顺序与创建顺序相同；</p>
<p>options 具有以下属性：</p>
<ul>
<li>once：如果为 true，那么会在被触发后自动删除监听器；</li>
<li>capture：事件处理的阶段，true 为捕获阶段，false 为冒泡阶段（默认）；</li>
<li>passive：如果为 true，那么处理程序将不会调用 preventDefault()；</li>
</ul>
<blockquote>
<p>Note: 由于历史原因，options 也可以是 false/true，它与 {capture: false/true} 相同；</p>
</blockquote>
<blockquote>
<p>Note: <code>passive: true</code> 选项告诉浏览器（特别是移动端浏览器），处理程序不会取消默认行为，然后浏览器先处理所有处理程序，再执行执行默认行为以提供最大程度的流畅体验，并通过某种方式处理事件；</p>
</blockquote>
<p>element.removeEventListener(event, handler[, options]) 要移除处理程序，我们需要传入与分配的函数完全相同的函数，以及同一阶段；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elem.addEventListener( <span class="string">&quot;click&quot;</span> , <span class="function">() =&gt;</span> alert(<span class="string">&#x27;Thanks!&#x27;</span>));</span><br><span class="line"><span class="comment">// 无法移除两个不同的函数对象</span></span><br><span class="line">elem.removeEventListener( <span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> alert(<span class="string">&#x27;Thanks!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 对于某些事件，只能通过 <code>addEventListener</code> 设置处理程序，如 DOMContentLoaded 事件；</p>
</blockquote>
<p><strong>事件对象</strong></p>
<p>当事件发生时，浏览器会创建一个 event 对象，将详细信息放入其中，并将其作为参数传递给处理程序；</p>
<p>event 对象的一些属性：</p>
<ul>
<li>event.type 事件类型</li>
<li>event.currentTarget 处理事件的元素，同 this；</li>
</ul>
<blockquote>
<p>Tips: <code>event</code> 对象在 HTML 处理程序中也可用，<code>&lt;input type=&quot;button&quot; onclick=&quot;alert(event.type)&quot; value=&quot;Event type&quot;&gt;</code>；</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1a8a7e698447">window.onload 和 DOMContentLoaded 的区别</a></li>
</ul>
<h4 id="冒泡和捕获"><a href="#冒泡和捕获" class="headerlink" title="冒泡和捕获"></a>冒泡和捕获</h4><p>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序；</p>
<p>通过 event.target 属性，父元素上的处理程序始终可以获取事件实际发生位置的详细信息；event.target 与 event.currentTarget 有区别，event.target 是引发事件的“目标”元素，它在冒泡过程中不会发生变化，event.currentTarget 是“当前”元素，其中有一个当前正在运行的处理程序</p>
<p>冒泡事件从目标元素开始向上冒泡。通常，它会一直上升到 <code>&lt;html&gt;</code>，然后再到 document 对象，有些事件甚至会到达 window，它们会调用路径上所有的处理程序；但是任意处理程序都可以决定事件已经被完全处理，并通过调用 event.stopPropagation() 方法停止冒泡；</p>
<p>还有一个 event.stopImmediatePropagation() 方法，可以用于停止冒泡，并阻止当前元素上的处理程序运行，使用该方法之后，其他处理程序就不会被执行；</p>
<p>DOM 事件标准描述了事件传播的 3 个阶段：</p>
<ul>
<li>捕获阶段（Capturing phase）事件（从 Window）向下走近元素；</li>
<li>目标阶段（Target phase）事件到达目标元素；</li>
<li>冒泡阶段（Bubbling phase）事件从元素上开始冒泡；</li>
</ul>
<p>事件首先通过祖先链向下到达元素（捕获阶段），然后到达目标（目标阶段），最后上升（冒泡阶段），在途中调用处理程序；</p>
<blockquote>
<p>Tips: 通过属性 <code>event.eventPhase</code> 可以获得捕获事件的当前阶段（capturing=1，target=2，bubbling=3）；</p>
</blockquote>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>捕获和冒泡允许我们实现一种被称为事件委托的强大的事件处理模式；如果有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序，而是将单个处理程序放在它们的共同祖先上；</p>
<p>还可以使用事件委托将“行为（behavior）”以声明方式添加到具有特殊特性（attribute）和类的元素中，将自定义特性添加到描述其行为的元素，然后用文档范围级的处理程序追踪事件，如果事件发生在具有特定特性的元素上则执行行为（action）；</p>
<p>优点：</p>
<ul>
<li>简化初始化并节省内存：无需添加许多处理程序；</li>
<li>更少的代码：添加或移除元素时，无需添加/移除处理程序；</li>
<li>DOM 修改 ：我们可以使用 innerHTML 等，来批量添加/移除元素；</li>
</ul>
<p>缺点：</p>
<ul>
<li>事件必须冒泡，有些事件不会冒泡就无法使用事件委托；</li>
<li>委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应；</li>
</ul>
<h4 id="浏览器默认行为"><a href="#浏览器默认行为" class="headerlink" title="浏览器默认行为"></a>浏览器默认行为</h4><p>许多事件会自动触发浏览器执行某些行为，如链接点击，表单提交等；可以通过两种方式阻止浏览器默认行为：</p>
<ol>
<li>使用 event 对象的 event.preventDefault() 方法；</li>
<li>针对 <code>on&lt;event&gt;</code> 事件处理程序，返回 false 也同样有效；</li>
</ol>
<blockquote>
<p>Note: 事件处理程序返回的值通常会被忽略，唯一的例外是从使用 <code>on&lt;event&gt;</code> 分配的处理程序中返回的 <code>return false</code>；</p>
</blockquote>
<p>如果默认行为被阻止，那么 event.defaultPrevented 属性为 true，否则为 false；有时可以使用 event.defaultPrevented 来代替 event.stopPropagation()，来通知其他事件处理程序，该事件已经被处理；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Right-click for the document menu (added a check for event.defaultPrevented)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>Right-click for the button menu<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  elem.oncontextmenu = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line"><span class="javascript">    alert(<span class="string">&quot;Button context menu&quot;</span>);</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (event.defaultPrevented) <span class="keyword">return</span>;</span></span><br><span class="line"></span><br><span class="line">    event.preventDefault();</span><br><span class="line"><span class="javascript">    alert(<span class="string">&quot;Document context menu&quot;</span>);</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建自定义事件"><a href="#创建自定义事件" class="headerlink" title="创建自定义事件"></a>创建自定义事件</h4><p>内建事件类形成一个层次结构（hierarchy），类似于 DOM 元素类，根是内建的 Event 类；</p>
<p>通过 new Event(type[, options]) 创建一个事件对象，其中 type 是事件类型，自定义的字符串；options 是一个包含两个布尔值属性的对象：</p>
<ul>
<li>bubbles: true/false 如果为 true，那么事件会冒泡，默认 false；</li>
<li>cancelable: true/false 如果为 true，那么“默认行为”就会被阻止，默认 false；</li>
</ul>
<p>事件对象被创建后，使用 elem.dispatchEvent(event) 调用在元素上“运行”它；</p>
<blockquote>
<p>Tips: 对于来自真实用户操作的事件，<code>event.isTrusted</code> 属性为 <code>true</code>，对于脚本生成的事件，<code>event.isTrusted</code> 属性为 <code>false</code>；</p>
</blockquote>
<p>对于自己的全新事件类型，应该使用 new CustomEvent，从技术上讲，CustomEvent 和 Event 一样，除了第二个参数（对象）中，可以为想要与事件一起传递的任何自定义信息添加一个附加的属性 detail；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件附带给处理程序的其他详细信息</span></span><br><span class="line">elem.addEventListener(<span class="string">&quot;hello&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.detail.name);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">elem.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;hello&quot;</span>, &#123;</span><br><span class="line">  detail: &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>对于新的，自定义的事件，绝对没有默认的浏览器行为，但是分派（dispatch）此类事件的代码可能有自己的计划，触发该事件之后应该做什么，</p>
<p>通过调用 event.preventDefault()，事件处理程序可以发出一个信号，指出这些行为应该被取消；该事件必须具有 cancelable: true 标志，否则 event.preventDefault() 调用将会被忽略；</p>
<p>通常事件是在队列中处理的，但当一个事件是在另一个事件中发起的，例如使用 dispatchEvent，这类事件将会被立即处理，即在新的事件处理程序被调用之后，恢复到当前的事件处理程序；可以通过零延时 setTimeout 使原事件不受其它嵌套事件的影响，优先被处理完毕；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;menu&quot;</span>&gt;</span>Menu (click me)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  menu.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    alert(1);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    menu.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;menu-open&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">      bubbles: <span class="literal">true</span></span></span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    alert(2);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 在 1 和 2 之间触发</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;menu-open&#x27;</span>, <span class="function">() =&gt;</span> alert(<span class="string">&#x27;nested&#x27;</span>));</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 零延时 setTimeout</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;menu-open&#x27;</span>, <span class="function">() =&gt;</span> alert(<span class="string">&#x27;nested&#x27;</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>与点击相关的事件始终具有 button 属性，该属性允许获取确切的鼠标按钮；在 mousedown 和 mouseup 事件中则可能需要用到 event.button，因为这两个事件在任何按键上都会触发，所以我们可以使用 button 属性来区分是左键单击还是右键单击；</p>
<p>通常我们不在 click 和 contextmenu 事件中使用这一属性，因为前者只在单击鼠标左键时触发，后者只在单击鼠标右键时触发；</p>
<table>
<thead>
<tr>
<th align="left">鼠标按键状态</th>
<th align="left">event.button</th>
</tr>
</thead>
<tbody><tr>
<td align="left">左键 (主要按键)</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">中键 (辅助按键)</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">右键 (次要按键)</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">X1键 (后退按键)</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">X2键 (前进按键)</td>
<td align="left">4</td>
</tr>
</tbody></table>
<blockquote>
<p>Note: 一些老代码可能会使用 event.which 属性来获得按下的按键，这是一个古老的非标准的方式，左中右键的值分别为1、2、3；</p>
</blockquote>
<p>所有的鼠标事件都包含有关按下的组合键的信息：</p>
<ul>
<li>shiftKey：Shift；</li>
<li>altKey：Alt（或对于 Mac 是 Opt）；</li>
<li>ctrlKey：Ctrl；</li>
<li>metaKey：对于 Mac 是 Cmd；</li>
</ul>
<blockquote>
<p>Tips: 在 Mac 上我们通常使用 Cmd 代替 Ctrl，使用 <code>event.ctrlKey || event.metaKey</code> 判断；</p>
</blockquote>
<p>所有的鼠标事件都提供了两种形式的坐标：</p>
<ul>
<li>相对于窗口的坐标：clientX 和 clientY；</li>
<li>相对于文档的坐标：pageX 和 pageY；</li>
</ul>
<p>双击鼠标会有副作用，在某些界面中可能会出现干扰：它会选择文本；最合理的方式是防止浏览器对 mousedown 进行操作；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span> <span class="attr">ondblclick</span>=<span class="string">&quot;alert(&#x27;Click!&#x27;)&quot;</span> <span class="attr">onmousedown</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">  Double-click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想禁用选择以保护页面的内容不被复制粘贴，那么可以使用另一个事件：oncopy；</p>
<h4 id="移动鼠标：mouseover-out，mouseenter-leave"><a href="#移动鼠标：mouseover-out，mouseenter-leave" class="headerlink" title="移动鼠标：mouseover/out，mouseenter/leave"></a>移动鼠标：mouseover/out，mouseenter/leave</h4><p>当鼠标指针移到某个元素上时，mouseover 事件就会发生，而当鼠标离开该元素时，mouseout 事件就会发生；</p>
<p>在 mouseover 和 mouseout 事件中，有一个 relatedTarget 属性，表示鼠标来自的那个元素或是鼠标移动到的，当前指针位置下的元素；当鼠标从窗口外移入时，其值为 null；</p>
<p>在鼠标快速移动的情况下，中间元素可能会被忽略，但是我们可以肯定一件事：如果鼠标指针“正式地”进入了一个元素（生成了 mouseover 事件），那么一旦它离开，我们就会得到 mouseout；</p>
<p>从父元素转到子元素时，也会触发 mouseover/out 事件，浏览器假定鼠标一次只会位于一个元素上最深的那个；</p>
<p>事件 mouseenter/mouseleave 类似于 mouseover/mouseout，它们在鼠标指针进入/离开元素时触发；但元素内部与后代之间的转换不会产生影响，且事件 mouseenter/mouseleave 不会冒泡；</p>
<h4 id="鼠标拖放事件"><a href="#鼠标拖放事件" class="headerlink" title="鼠标拖放事件"></a>鼠标拖放事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 球体拖动</span></span><br><span class="line">ball.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> shiftX = event.clientX - ball.getBoundingClientRect().left;</span><br><span class="line">  <span class="keyword">let</span> shiftY = event.clientY - ball.getBoundingClientRect().top;</span><br><span class="line"></span><br><span class="line">  ball.style.position = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line">  ball.style.zIndex = <span class="number">1000</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.append(ball);</span><br><span class="line"></span><br><span class="line">  moveAt(event.pageX, event.pageY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动现在位于坐标 (pageX, pageY) 上的球</span></span><br><span class="line">  <span class="comment">// 将初始的偏移考虑在内</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">moveAt</span>(<span class="params">pageX, pageY</span>) </span>&#123;</span><br><span class="line">    ball.style.left = pageX - shiftX + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    ball.style.top = pageY - shiftY + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onMouseMove</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    moveAt(event.pageX, event.pageY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 mousemove 事件上移动球</span></span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, onMouseMove);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 放下球，并移除不需要的处理程序</span></span><br><span class="line">  ball.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, onMouseMove);</span><br><span class="line">    ball.onmouseup = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ball.ondragstart = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="指针事件"><a href="#指针事件" class="headerlink" title="指针事件"></a>指针事件</h4><p>指针事件（Pointer Events）是一种用于处理来自各种输入设备（例如鼠标、触控笔和触摸屏等）的输入信息的现代化解决方案；</p>
<blockquote>
<p>Note: 除非你写的代码需要兼容旧版本的浏览器，例如 IE 10 或 Safari 12 或更低的版本，否则无需继续使用鼠标事件或触摸事件我们可以使用指针事件；</p>
</blockquote>
<p><strong>指针事件类型</strong></p>
<table>
<thead>
<tr>
<th align="left">指针事件</th>
<th align="left">类似的鼠标事件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pointerdown</td>
<td align="left">mousedown</td>
</tr>
<tr>
<td align="left">pointerup</td>
<td align="left">mouseup</td>
</tr>
<tr>
<td align="left">pointermove</td>
<td align="left">mousemove</td>
</tr>
<tr>
<td align="left">pointerover</td>
<td align="left">mouseover</td>
</tr>
<tr>
<td align="left">pointerout</td>
<td align="left">mouseout</td>
</tr>
<tr>
<td align="left">pointerenter</td>
<td align="left">mouseenter</td>
</tr>
<tr>
<td align="left">pointerleave</td>
<td align="left">mouseleave</td>
</tr>
<tr>
<td align="left">pointercancel</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">gotpointercapture</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">lostpointercapture</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p><strong>指针事件属性</strong></p>
<p>指针事件具备和鼠标事件完全相同的属性，包括 clientX/Y 和 target 等，以及一些其他属性：</p>
<ul>
<li>pointerId 触发当前事件的指针唯一标识符，由浏览器生成的，使能够处理多指针的情况，如多点触控功能；</li>
<li>pointerType 指针的设备类型，必须为字符串，可以是：“mouse”、“pen” 或 “touch”；</li>
<li>isPrimary 当指针为首要指针（多点触控时按下的第一根手指）时为 true；</li>
</ul>
<p>有些指针设备会测量接触面积和点按压力（例如一根手指压在触屏上），对于这种情况可以使用以下属性：</p>
<ul>
<li>width 指针（例如手指）接触设备的区域的宽度，对于不支持的设备（如鼠标），这个值总是 1；</li>
<li>height 指针（例如手指）接触设备的区域的长度，对于不支持的设备，这个值总是 1；</li>
<li>pressure 触摸压力，是一个介于 0 到 1 之间的浮点数，对于不支持压力检测的设备，这个值总是 0.5（按下时）或 0；</li>
<li>tangentialPressure 归一化后的切向压力（tangential pressure）；</li>
<li>tiltX, tiltY, twist 针对触摸笔的几个属性，用于描述笔和屏幕表面的相对位置；</li>
</ul>
<p>pointercancel 事件将会在一个正处于活跃状态的指针交互由于某些原因被中断时触发；在这个事件之后，该指针就不会继续触发更多事件了；</p>
<p>导致指针中断的可能原因如下：</p>
<ul>
<li>指针设备硬件在物理层面上被禁用；</li>
<li>设备方向旋转（例如给平板转了个方向）；</li>
<li>浏览器打算自行处理这一交互，比如将其看作是一个专门的鼠标手势或缩放操作等；</li>
</ul>
<p>阻止原生的拖放操作发生：</p>
<ol>
<li>对于非触屏设备：在 JS 中 ondragstart 事件处理返回 false；或者 event.preventDefault()；</li>
<li>对于触屏设备：在 CSS 中设置 touch-action: none；</li>
</ol>
<p><strong>指针捕获</strong></p>
<p>指针捕获（Pointer capturing）是针对指针事件的一个特性；elem.setPointerCapture(pointerId) 方法将给定的 pointerId 绑定到 elem；在调用之后，所有具有相同 pointerId 的指针事件都将 elem 作为目标（就像事件发生在 elem 上一样），无论这些 elem 在文档中的实际位置是什么；</p>
<p>绑定会在以下情况下被移除：</p>
<ul>
<li>当 pointerup 或 pointercancel 事件出现时，绑定会被自动地移除；</li>
<li>当 elem 被从文档中移除后，绑定会被自动地移除；</li>
<li>当 elem.releasePointerCapture(pointerId) 被调用，绑定会被移除；</li>
</ul>
<p>gotpointercapture 会在一个元素使用 setPointerCapture 来启用捕获后触发；<br>lostpointercapture 会在捕获被释放后触发：其触发可能是由于 releasePointerCapture 的显式调用，或是 pointerup/pointercancel 事件触发后的自动调用；</p>
<h4 id="键盘：keydown-和-keyup"><a href="#键盘：keydown-和-keyup" class="headerlink" title="键盘：keydown 和 keyup"></a>键盘：keydown 和 keyup</h4><p>当一个按键被按下时，会触发 keydown 事件，而当按键被释放时，会触发 keyup 事件；</p>
<p>事件对象的 key 属性允许获取字符，而事件对象的 code 属性则允许获取“物理按键代码”；每个按键的代码都取决于该按键在键盘上的位置，UI 事件代码规范 中描述了按键代码：</p>
<ul>
<li>字符键的代码为 <code>Key&lt;letter&gt;</code>：KeyA，KeyB 等；</li>
<li>数字键的代码为：<code>Digit&lt;number&gt;</code>：Digit0，Digit1 等；</li>
<li>特殊按键的代码为按键的名字：Enter，Backspace，Tab 等；</li>
</ul>
<blockquote>
<p>Tips: 为了可靠地跟踪与受键盘布局影响的字符，使用 <code>event.key</code> 可能是一个更好的方式；但为了满足切换了语言的情况下，依赖于它的热键也能正常工作，则使用绑定到物理键位置的 <code>event.code</code>；</p>
</blockquote>
<blockquote>
<p>Note: 如果按下一个键足够长的时间，它就会开始“自动重复”：<code>keydown</code> 会被一次又一次地触发，对于由自动重复触发的事件，<code>event</code> 对象的 <code>event.repeat</code> 属性被设置为 <code>true</code>；</p>
</blockquote>
<p>过去曾经有一个 keypress 事件，还有事件对象的 keyCode、charCode 和 which 属性；大多数浏览器对它们都存在兼容性问题；</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/TR/uievents-code/#key-alphanumeric-section">字母数字按键代码W3C规范</a></li>
</ul>
<h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><p>scroll 事件在 window 和可滚动元素上都可以运行；不能通过在 onscroll 监听器中使用 event.preventDefault() 来阻止滚动，因为它会在滚动发生之后才触发；</p>
<p>但是我们可以在导致滚动的事件上，例如在 pageUp 和 pageDown 的 keydown 事件上，使用 event.preventDefault() 来阻止滚动；</p>
<p>滚动的两个重要特性：</p>
<ul>
<li>滚动是“弹性的”；在某些浏览器/设备中，我们可以在文档的顶端或末端稍微多滚动出一点（超出部分显示的是空白区域，然后文档将自动“弹回”到正常状态）；</li>
<li>滚动并不精确；当我们滚动到页面末端时，实际上我们可能距真实的文档末端约 0-50px；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否滚动到页面底部</span></span><br><span class="line"><span class="keyword">let</span> windowRelativeBottom = <span class="built_in">document</span>.documentElement.getBoundingClientRect().bottom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用户将页面滚动的距离不够远（文档末端距窗口底部 &gt;100px）</span></span><br><span class="line"><span class="keyword">if</span> (windowRelativeBottom &gt; <span class="built_in">document</span>.documentElement.clientHeight + <span class="number">100</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片懒加载</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests if the element is visible (within the visible part of the page)</span></span><br><span class="line"><span class="comment"> * It&#x27;s enough that the top or bottom edge of the element are visible</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isVisible</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo: your code</span></span><br><span class="line">  <span class="keyword">let</span> position = image.getBoundingClientRect();</span><br><span class="line">  <span class="keyword">return</span> position.top &lt; <span class="built_in">window</span>.pageYOffset + <span class="built_in">document</span>.documentElement.clientHeight + <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showVisible</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> img <span class="keyword">of</span> <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> realSrc = img.dataset.src;</span><br><span class="line">    <span class="keyword">if</span> (!realSrc) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isVisible(img)) &#123;</span><br><span class="line">      <span class="comment">// disable caching</span></span><br><span class="line">      <span class="comment">// this line should be removed in production code</span></span><br><span class="line">      realSrc += <span class="string">&#x27;?nocache=&#x27;</span> + <span class="built_in">Math</span>.random();</span><br><span class="line"></span><br><span class="line">      img.src = realSrc;</span><br><span class="line"></span><br><span class="line">      img.dataset.src = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, showVisible);</span><br><span class="line">showVisible();</span><br></pre></td></tr></table></figure>

<h4 id="表单属性和方法"><a href="#表单属性和方法" class="headerlink" title="表单属性和方法"></a>表单属性和方法</h4><p>文档中的表单是特殊集合 document.forms 的成员，既可以使用名字，也可以使用在文档中的编号来获取表单；在表单中，其中的任何元素都可以通过命名的集合 form.elements 来获取到；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;my&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;two&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取表单</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> form = <span class="built_in">document</span>.forms.my; <span class="comment">// &lt;form name=&quot;my&quot;&gt; 元素</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取表单中的元素</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> elem = form.elements.one; <span class="comment">// &lt;input name=&quot;one&quot;&gt; 元素</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// let elem = form.elements[&quot;one&quot;];</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// let elem = form.elements[0];</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  alert(elem.value); <span class="comment">// 1</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于相同 name 字段的 input 单选按钮，form.elements[name] 将会是一个集合；这些导航（navigation）属性并不依赖于标签的结构，所有的控件元素，无论它们在表单中有多深，都可以通过 form.elements 获取到；</p>
<p>一个表单内会有一个或多个 <code>&lt;fieldset&gt;</code> 元素，它们也具有 elements 属性，该属性列出了 <code>&lt;fieldset&gt;</code> 中的表单控件；</p>
<blockquote>
<p>Tips: <code>elements</code> 可以省略，可以通过 <code>form[index/name]</code> 来访问元素；</p>
</blockquote>
<p>对于任何元素，其对应的表单都可以通过 element.form 访问到；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// form -&gt; element</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> login = form.login;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// element -&gt; form</span></span></span><br><span class="line"><span class="javascript">  alert(login.form); <span class="comment">// HTMLFormElement</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>表单元素</strong></p>
<p>一个 <code>&lt;select&gt;</code> 元素有 3 个重要的属性：</p>
<ul>
<li>select.options <code>&lt;option&gt;</code> 的子元素的集合；</li>
<li>select.value 当前所选择的 <code>&lt;option&gt;</code> 的 value；</li>
<li>select.selectedIndex 当前所选择的 <code>&lt;option&gt;</code> 的编号；</li>
</ul>
<p>并提供了三种为 <code>&lt;select&gt;</code> 设置 value 的不同方式：</p>
<ul>
<li>找到对应的 <code>&lt;option&gt;</code> 元素，并将 option.selected 设置为 true；</li>
<li>将 select.value 设置为对应的 value；</li>
<li>将 select.selectedIndex 设置为对应 <code>&lt;option&gt;</code> 的编号；</li>
</ul>
<p>如果 <code>&lt;select&gt;</code> 具有 multiple 特性（attribute），则允许多选；</p>
<p>在规范中，有一个很好的简短语法可以创建 <code>&lt;option&gt;</code> 元素：<code>new Option(text, value, defaultSelected, selected)</code>；其中参数：</p>
<ul>
<li>text <code>&lt;option&gt;</code> 中的文本；</li>
<li>value <code>&lt;option&gt;</code> 的 value；</li>
<li>defaultSelected 如果为 true，那么 selected HTML-特性（attribute）就会被创建；</li>
<li>selected 如果为 true，那么这个 <code>&lt;option&gt;</code> 就会被选中；</li>
</ul>
<p><code>&lt;option&gt;</code> 元素具有以下属性：</p>
<ul>
<li>option.selected <code>&lt;option&gt;</code> 是否被选择；</li>
<li>option.index <code>&lt;option&gt;</code> 在其所属的 <code>&lt;select&gt;</code> 中的编号；</li>
<li>option.text <code>&lt;option&gt;</code> 的文本内容（可以被访问者看到）；</li>
</ul>
<h4 id="聚焦：focus-blur"><a href="#聚焦：focus-blur" class="headerlink" title="聚焦：focus/blur"></a>聚焦：focus/blur</h4><p>当用户点击某个元素或使用键盘上的 Tab 键选中时，该元素将会获得聚焦（focus），还有一个 HTML 特性（attribute）autofocus 可以让焦点在网页加载时默认落在一个元素上，此外还有其它途径可以获得焦点；</p>
<p>当元素聚焦时，会触发 focus 事件，当元素失去焦点时，会触发 blur 事件；elem.focus() 和 elem.blur() 方法可以设置和移除元素上的焦点；</p>
<p>无法通过在 onblur 事件处理程序中调用 event.preventDefault() 来“阻止失去焦点”，因为 onblur 事件处理程序是在元素失去焦点 之后 运行的；</p>
<blockquote>
<p>Note: <code>alert</code> 会将焦点移至自身，因此会导致元素失去焦点（触发 blur 事件），而当 <code>alert</code> 对话框被取消时，焦点又回重新回到原元素上（触发 focus 事件）；如果一个元素被从 DOM 中移除，那么也会导致焦点丢失，如果稍后它被重新插入到 DOM，焦点也不会回到它身上；</p>
</blockquote>
<p>任何具有 tabindex 特性的元素，都会变成可聚焦的，该特性的 value 是当使用 Tab（或类似的东西）在元素之间进行切换时，元素的顺序号；可以使用 elem.tabIndex 通过 JavaScript 来添加 tabindex；</p>
<p>特殊值：</p>
<ul>
<li>tabindex=”0” 会使该元素被与那些不具有 tabindex 的元素放在一起。也就是说，当我们切换元素时，具有 tabindex=”0” 的元素将排在那些具有 tabindex ≥ 1 的元素的后面；</li>
<li>tabindex=”-1” 只允许以编程的方式聚焦于元素。Tab 键会忽略这样的元素，但是 elem.focus() 有效；</li>
</ul>
<p>focus 和 blur 事件不会向上冒泡，但会在捕获阶段向下传播，因此可以在捕获阶段进行事件委托；也可以使用冒泡事件 focusin 和 focusout，但必须使用 elem.addEventListener 来分配它们；</p>
<h4 id="事件：change，input，cut，copy，paste"><a href="#事件：change，input，cut，copy，paste" class="headerlink" title="事件：change，input，cut，copy，paste"></a>事件：change，input，cut，copy，paste</h4><p>当元素更改完成时，将触发 change 事件，对于文本输入框，当其失去焦点时，就会触发 change 事件；</p>
<p>每当用户对输入值进行修改后，就会触发 input 事件；与键盘事件不同，只要值改变了，input 事件就会触发，即使那些不涉及键盘行为（action）的值的更改也是如此：使用鼠标粘贴，或者使用语音识别来输入文本；</p>
<p>ClipboardEvent 类，并提供了对剪切/拷贝/粘贴的数据的访问方法；</p>
<h4 id="表单：事件和方法提交"><a href="#表单：事件和方法提交" class="headerlink" title="表单：事件和方法提交"></a>表单：事件和方法提交</h4><p>提交表单时，会触发 submit 事件，它通常用于在将表单发送到服务器之前对表单进行校验，或者中止提交，并使用 JavaScript 来处理表单；form.submit() 方法允许从 JavaScript 启动表单发送，我们可以使用此方法动态地创建表单，并将其发送到服务器；</p>
<p>提交表单主要有两种方式：</p>
<ul>
<li>点击 <code>&lt;input type=&quot;submit&quot;&gt;</code> 或 <code>&lt;input type=&quot;image&quot;&gt;</code>；</li>
<li>在 input 字段中按下 Enter 键；</li>
</ul>
<blockquote>
<p>Note: 在输入框中使用 Enter 发送表单时，会在 <code>&lt;input type=&quot;submit&quot;&gt;</code>上触发一次 click 事件；</p>
</blockquote>
<h4 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h4><p><strong>DOMContentLoaded</strong></p>
<p>浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成；此时处理程序可以查找 DOM 节点，并初始化接口；</p>
<p>DOMContentLoaded 事件发生在 document 对象上，且必须使用 addEventListener 来捕获；</p>
<p>具有 async 特性（attribute）的脚本，以及使用 document.createElement(‘script’) 动态生成并添加到网页的脚本也不会阻塞 DOMContentLoaded；</p>
<p>外部样式表不会影响 DOM，因此 DOMContentLoaded 不会等待它们，但如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 在样式表加载完成之前，脚本都不会执行</span></span></span><br><span class="line"><span class="javascript">  alert(getComputedStyle(<span class="built_in">document</span>.body).marginTop);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Firefox，Chrome 和 Opera 都会在 DOMContentLoaded 中自动填充表单，如果 DOMContentLoaded 被需要加载很长时间的脚本延迟触发，那么自动填充也会等待；</p>
<p><strong>window.load</strong></p>
<p>当整个页面，包括样式、图片和其他资源被加载完成时，会触发 window 对象上的 load 事件；此时外部资源已加载完成，样式已被应用，图片大小也已知了；</p>
<p><strong>window.onbeforeunload</strong></p>
<p>如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，beforeunload 处理程序将要求进行更多确认；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在某些旧浏览器中返回非空字符串也被视为取消事件；</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>window.unload</strong></p>
<p>当访问者离开页面时，window 对象上的 unload 事件就会被触发，如果希望通过 unload 事件将数据保存到服务器上，可以使用 navigator.sendBeacon(url, data) 方法；该方法在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 sendBeacon；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> analyticsData = &#123; <span class="comment">/* 带有收集的数据的对象 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;unload&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 也可以发送表单以及其他格式的数据，数据大小限制在 64kb</span></span><br><span class="line">  navigator.sendBeacon(<span class="string">&quot;/analytics&quot;</span>, <span class="built_in">JSON</span>.stringify(analyticsData));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>readystatechange 和 document.readyState</strong></p>
<p>document.readyState 属性可以提供当前加载状态的信息，它有三个值：</p>
<ul>
<li>loading —— 文档正在被加载；</li>
<li>interactive —— 文档被全部读取；</li>
<li>complete —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成；</li>
</ul>
<p>readystatechange 事件是跟踪文档加载状态的另一种机制，它会在状态发生改变时触发；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  log(<span class="string">&#x27;readyState:&#x27;</span> + <span class="built_in">document</span>.readyState);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function">() =&gt;</span> log(<span class="string">&#x27;readyState:&#x27;</span> + <span class="built_in">document</span>.readyState));</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> log(<span class="string">&#x27;DOMContentLoaded&#x27;</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function">() =&gt;</span> log(<span class="string">&#x27;window onload&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;iframe.html&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;log(&#x27;iframe onload&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://en.js.cx/clipart/train.gif&quot;</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  img.onload = <span class="function">() =&gt;</span> log(<span class="string">&#x27;img onload&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>包含 <code>&lt;iframe&gt;</code>，<code>&lt;img&gt;</code> 和记录事件的处理程序的文档完整的事件流：</p>
<ol>
<li>readyState:loading</li>
<li>readyState:interactive</li>
<li>DOMContentLoaded</li>
<li>iframe onload</li>
<li>img onload</li>
<li>readyState:complete</li>
<li>window onload</li>
</ol>
<p>在 DOMContentLoaded 之前，document.readyState 会立即变成 interactive，它们的意义实际上是相同的；当所有资源（iframe 和 img）都加载完成后，document.readyState 变成 complete；转换到 complete 状态的意义与 window.onload 相同，区别在于 window.onload 始终在所有其他 load 处理程序之后运行；</p>
<p><strong>脚本：async，defer</strong></p>
<p>当浏览器加载 HTML 时遇到 <code>&lt;script&gt;</code> 标签，浏览器就不能继续构建 DOM，它必须立刻执行此脚本，对于外部脚本也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面；</p>
<p>通常把脚本放在页面底部，可以访问到页面上面的元素，并且不会阻塞页面显示内容；但是当遇到长的 HTML 文档时，则可能会造成明显的延迟；</p>
<p><strong>defer</strong></p>
<p>defer 特性告诉浏览器不要等待脚本，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行；</p>
<p>具有 defer 特性的脚本不会阻塞页面，总是要等到 DOM 解析完毕，但在 DOMContentLoaded 事件之前执行；</p>
<p>浏览器扫描页面寻找 defer 脚本，然后并行下载它们，以提高性能，且它们保持其相对顺序执行；</p>
<p><strong>async</strong></p>
<p>async 脚本就是一个会在加载完成时执行的完全独立的脚本，其他脚本不会等待 async 脚本加载完成，同样，async 脚本也不会等待其他脚本；浏览器也不会因 async 脚本而阻塞（与 defer 类似）；</p>
<p>DOMContentLoaded 和异步脚本不会彼此等待：</p>
<ul>
<li>如果异步脚本在页面完成后才加载完成，则 DOMContentLoaded 可能会发生在异步脚本之前；</li>
<li>如果异步脚本很短，或者是从 HTTP 缓存中加载的，则 DOMContentLoaded 也可能发生在异步脚本之后；</li>
</ul>
<p><strong>动态脚本</strong></p>
<p>可以使用 JavaScript 动态地创建一个脚本，并将其附加（append）到文档（document）中，当脚本被附加到文档时，脚本就会立即开始加载；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.src = <span class="string">&quot;/article/script-async-defer/long.js&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.append(script); <span class="comment">// 添加到文档</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，动态脚本的行为是“异步”的，即效果同 async；可以显式地设置 script.async=false，改变这个规则，使执行效果同 defer；</p>
<blockquote>
<p>Tips: 在实际开发中，<code>defer</code> 用于需要整个 DOM 的脚本，和/或脚本的相对执行顺序很重要的时候；<code>async</code> 用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要；</p>
</blockquote>
<h4 id="资源加载：onload，onerror"><a href="#资源加载：onload，onerror" class="headerlink" title="资源加载：onload，onerror"></a>资源加载：onload，onerror</h4><p>浏览器允许跟踪外部资源的加载，如脚本，iframe，图片等；readystatechange 事件也适用于资源，但很少被使用；</p>
<p>对于加载脚本 onload/onerror 事件仅跟踪加载本身；在脚本处理和执行期间可能发生的 error 超出了这些事件跟踪的范围；也就是说：如果脚本成功加载，则即使脚本中有编程 error，也会触发 onload 事件；</p>
<p>load 和 error 事件也适用于其他资源，基本上（basically）适用于具有外部 src 的任何资源；</p>
<p>大多数资源在被添加到文档中后，便开始加载，但是 <code>&lt;img&gt;</code> 是个例外，它要等到获得 src 后才开始加载；对于 <code>&lt;iframe&gt;</code> 来说，iframe 加载完成时会触发 iframe.onload 事件，无论是成功加载还是出现 error；</p>
<p>如果我们使用的是来自其他域的脚本，并且该脚本中存在 error，那么我们无法获取 error 的详细信息；</p>
<p>要允许跨源访问，<code>&lt;script&gt;</code> 标签需要具有 crossorigin 特性（attribute），并且远程服务器必须提供特殊的 header；这里有三个级别的跨源访问：</p>
<ul>
<li>无 crossorigin 特性 —— 禁止访问；</li>
<li>crossorigin=”anonymous” 如果服务器的响应带有包含 * 或我们的源（origin）的 header Access-Control-Allow-Origin，则允许访问，浏览器不会将授权信息和 cookie 发送到远程服务器；</li>
<li>crossorigin=”use-credentials” 如果服务器发送回带有我们的源的 header Access-Control-Allow-Origin 和 Access-Control-Allow-Credentials: true，则允许访问。浏览器会将授权信息和 cookie 发送到远程服务器；</li>
</ul>
<h4 id="DOM-变动观察器（Mutation-observer）"><a href="#DOM-变动观察器（Mutation-observer）" class="headerlink" title="DOM 变动观察器（Mutation observer）"></a>DOM 变动观察器（Mutation observer）</h4><p>MutationObserver 是一个内建对象，它观察 DOM 元素，并在检测到更改时触发回调；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个带有回调函数的观察器</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"><span class="comment">// 将其附加到一个 DOM 节点</span></span><br><span class="line">observer.observe(node, config);</span><br></pre></td></tr></table></figure>

<p>config 是一个具有布尔选项的对象，该布尔选项表示“将对哪些更改做出反应”：</p>
<ul>
<li>childList node 的直接子节点的更改；</li>
<li>subtree node 的所有后代的更改；</li>
<li>attributes node 的特性（attribute）；</li>
<li>attributeFilter 特性名称数组，只观察选定的特性；</li>
<li>characterData 是否观察 node.data（文本内容）；</li>
<li>attributeOldValue 如果为 true，则将特性的旧值和新值都传递给回调，否则只传新值（需要 attributes 选项）；</li>
<li>characterDataOldValue 如果为 true，则将 node.data 的旧值和新值都传递给回调，否则只传新值（需要 characterData 选项）；</li>
</ul>
<p>在发生任何更改后，将执行“回调”：更改被作为一个 MutationRecord 对象列表传入第一个参数，而观察器自身作为第二个参数，MutationRecord 对象具有以下属性：</p>
<ul>
<li>type 变动类型，以下类型之一：<ul>
<li>“attributes”：特性被修改了；</li>
<li>“characterData”：数据被修改了，用于文本节点；</li>
<li>“childList”：添加/删除了子元素；</li>
</ul>
</li>
<li>target 更改发生在何处：”attributes” 所在的元素，或 “characterData” 所在的文本节点，或 “childList” 变动所在的元素；</li>
<li>addedNodes/removedNodes 添加/删除的节点；</li>
<li>previousSibling/nextSibling 添加/删除的节点的上一个/下一个兄弟节点；</li>
<li>attributeName/attributeNamespace 被更改的特性的名称/命名空间（用于 XML）；</li>
<li>oldValue 之前的值，仅适用于特性或文本更改，如果设置了相应选项 attributeOldValue/characterDataOldValue</li>
</ul>
<p>方法 observer.disconnect() 可以停止观察，但这时观察器可能尚未处理某些更改；observer.takeRecords() 方法可以获取尚未处理的变动记录列表，表中记录的是已经发生，但回调暂未处理的变动；</p>
<blockquote>
<p>Note: 观察器在内部对节点使用弱引用，也就是说，如果一个节点被从 DOM 中移除了，并且该节点变得不可访问，那么它就可以被垃圾回收；</p>
</blockquote>
<h4 id="选择（Selection）和范围（Range）"><a href="#选择（Selection）和范围（Range）" class="headerlink" title="选择（Selection）和范围（Range）"></a>选择（Selection）和范围（Range）</h4><p>选择的基本概念是 Range：本质上是一对“边界点”：范围起点和范围终点；每个点都被表示为一个带有相对于起点的相对偏移（offset）的父 DOM 节点，如果父节点是元素节点，则偏移量是子节点的编号（子节点数），对于文本节点，则是文本中的位置（字符数）；</p>
<p>使用 new Range() 创建一个范围，Range 是一个无参的构造函数；使用 range.setStart(node, offset) 和 range.setEnd(node, offset) 来设置选择边界；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span>&gt;</span>Example: <span class="tag">&lt;<span class="name">i</span>&gt;</span>italic<span class="tag">&lt;/<span class="name">i</span>&gt;</span> and <span class="tag">&lt;<span class="name">b</span>&gt;</span>bold<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">From <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">value</span>=<span class="string">1</span>&gt;</span> – To <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;end&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">value</span>=<span class="string">4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Click to select<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  button.onclick = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> range = <span class="keyword">new</span> Range();</span></span><br><span class="line"></span><br><span class="line">    range.setStart(p, start.value);</span><br><span class="line">    range.setEnd(p, end.value);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 应用选择，后文有解释</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getSelection().removeAllRanges();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getSelection().addRange(range);</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 一个范围可能跨越许多不相关的节点，所以不必在 <code>setStart</code> 和 <code>setEnd</code> 中使用相同的节点，唯一要注意的是终点要在起点之后；</p>
</blockquote>
<p>range 对象具有以下属性：</p>
<ul>
<li>startContainer，startOffset 起始节点和偏移量；</li>
<li>endContainer，endOffset 结束节点和偏移量；</li>
<li>collapsed 布尔值，如果范围在同一点上开始和结束（所以范围内没有内容）则为 true；</li>
<li>commonAncestorContainer 在范围内的所有节点中最近的共同祖先节点；</li>
</ul>
<p>Range 方法：</p>
<ul>
<li><p>setStart(node, offset) 将起点设置在：node 中的位置 offset；</p>
</li>
<li><p>setStartBefore(node) 将起点设置在：node 前面；</p>
</li>
<li><p>setStartAfter(node) 将起点设置在：node 后面；</p>
</li>
<li><p>setEnd(node, offset) 将终点设置为：node 中的位置 offset；</p>
</li>
<li><p>setEndBefore(node) 将终点设置为：node 前面；</p>
</li>
<li><p>setEndAfter(node) 将终点设置为：node 后面；</p>
</li>
<li><p>selectNode(node) 设置范围以选择整个 node；</p>
</li>
<li><p>selectNodeContents(node) 设置范围以选择整个 node 的内容；</p>
</li>
<li><p>collapse(toStart) 如果 toStart=true 则设置 end=start，否则设置 start=end，从而折叠范围；</p>
</li>
<li><p>cloneRange() 创建一个具有相同起点/终点的新范围；</p>
</li>
<li><p>deleteContents() 从文档中删除范围内容；</p>
</li>
<li><p>extractContents() 从文档中删除范围内容，并将删除的内容作为 DocumentFragment 返回；</p>
</li>
<li><p>cloneContents() 复制范围内容，并将复制的内容作为 DocumentFragment 返回；</p>
</li>
<li><p>insertNode(node) 在范围的起始处将 node 插入文档；</p>
</li>
<li><p>surroundContents(node) 使用 node 将所选范围内容包裹起来，该范围必须包含其中所有元素的开始和结束标签；</p>
</li>
</ul>
<p>文档选择是由 Selection 对象表示的，可通过 window.getSelection() 或 document.getSelection() 来获取；Selection API 规范描述了一个选择可以包括零个或多个范围，但实际上，在除 Firefox 之外的所有浏览器中，范围最多是 1；</p>
<p>选择属性：</p>
<ul>
<li>anchorNode 选择的起始节点；</li>
<li>anchorOffset 选择开始的 anchorNode 中的偏移量；</li>
<li>focusNode 选择的结束节点；</li>
<li>focusOffset 选择开始处 focusNode 的偏移量；</li>
<li>isCollapsed 如果未选择任何内容（空范围）或不存在，则为 true ；</li>
<li>rangeCount 选择中的范围数，除 Firefox 外，其他浏览器最多为 1；</li>
</ul>
<blockquote>
<p>Tips: 可以通过 <code>elem.onselectstart</code> 跟踪当选择从 elem 上开始的事件，阻止默认行为会使选择无法开始；document.onselectionchange 当选择变动时触发；</p>
</blockquote>
<p>获取整个选择：</p>
<ul>
<li>作为文本：只需调用 document.getSelection().toString()；</li>
<li>作为 DOM 节点：获取底层的（underlying）范围，并调用它们的 cloneContents() 方法；</li>
</ul>
<p>选择方法：</p>
<ul>
<li><p>getRangeAt(i) 获取从 0 开始的第 i 个范围，在除 Firefox 之外的所有浏览器中，仅使用 0；</p>
</li>
<li><p>addRange(range) 将 range 添加到选择中，如果选择已有关联的范围，则除 Firefox 外的所有浏览器都将忽略该调用；</p>
</li>
<li><p>removeRange(range) 从选择中删除 range；</p>
</li>
<li><p>removeAllRanges() 删除所有范围；</p>
</li>
<li><p>empty() removeAllRanges 的别名；</p>
</li>
<li><p>collapse(node, offset) 用一个新的范围替换选定的范围，该新范围从给定的 node 处开始，到偏移 offset 处结束；</p>
</li>
<li><p>setPosition(node, offset) collapse 的别名；</p>
</li>
<li><p>collapseToStart() 折叠（替换为空范围）到选择起点；</p>
</li>
<li><p>collapseToEnd() 折叠到选择终点；</p>
</li>
<li><p>extend(node, offset) 将选择的焦点（focus）移到给定的 node，位置偏移 offset；</p>
</li>
<li><p>setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset) 用给定的起点 anchorNode/anchorOffset 和终点 focusNode/focusOffset 来替换选择范围，选中它们之间的所有内容；</p>
</li>
<li><p>selectAllChildren(node) 选择 node 的所有子节点；</p>
</li>
<li><p>deleteFromDocument() 从文档中删除所选择的内容；</p>
</li>
<li><p>containsNode(node, allowPartialContainment = false) 检查选择中是否包含 node（特别是如果第二个参数是 true 的话）；</p>
</li>
</ul>
<blockquote>
<p>Note: 如果选择已存在，需要先使用 <code>removeAllRanges()</code> 将其清空，然后添加范围；否则，除 Firefox 外的所有浏览器都将忽略新范围；</p>
</blockquote>
<p><strong>表单控件中的选择</strong></p>
<p>诸如 input 和 textarea 等表单元素提供了 专用的选择 API，没有 Selection 或 Range 对象；</p>
<ul>
<li>属性：<ul>
<li>input.selectionStart 选择的起始位置（可写）；</li>
<li>input.selectionEnd 选择的结束位置（可写）；</li>
<li>input.selectionDirection 选择方向，其中之一：“forward”，“backward” 或 “none”；</li>
</ul>
</li>
<li>事件：<ul>
<li>input.onselect 当某个东西被选择时触发；</li>
</ul>
</li>
<li>方法：<ul>
<li>input.select() 选择文本控件中的所有内容；</li>
<li>input.setSelectionRange(start, end, [direction]) 在给定方向上（可选），从 start 一直选择到 end；input.setRangeText(replacement, [start], [end], [selectionMode]) 用新文本替换范围中的文本；</li>
</ul>
</li>
</ul>
<p>input.setRangeText() 方法如果提供的话可选参数 start 和 end，则设置范围的起点和终点，否则使用用户的选择，最后一个可选参数 selectionMode 决定替换文本后如何设置选择，可能的值为：</p>
<ul>
<li>“select” 将选择新插入的文本；</li>
<li>“start” 选择范围将在插入的文本之前折叠（光标将在其之前）；</li>
<li>“end” 选择范围将在插入的文本之后折叠（光标将紧随其后）；</li>
<li>“preserve” 尝试保留选择，默认值；</li>
</ul>
<blockquote>
<p>Note: 根据规范，发表单控件内的选择不应该触发 <code>document.onselectionchange</code> 事件，因为它与 <code>document</code> 选择和范围不相关；</p>
</blockquote>
<blockquote>
<p>Tips: 一个重要的边界情况是 selectionStart 和 selectionEnd 彼此相等，也正是光标位置；通过将 selectionStart 和 selectionEnd 设置为相同的值，可以实现移动光标的效果；</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/* CSS 样式 */</span></span></span><br><span class="line">  #el &#123;</span><br><span class="line"><span class="css">    user-select: none;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;el&quot;</span>&gt;</span>Unselectable text.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 取消选择默认事件</span></span></span><br><span class="line"><span class="javascript">el.onselectstart = <span class="function">() =&gt;</span> <span class="literal">false</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 或者在选择发生后清除选择</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getSelection().empty() </span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="事件循环：微任务和宏任务"><a href="#事件循环：微任务和宏任务" class="headerlink" title="事件循环：微任务和宏任务"></a>事件循环：微任务和宏任务</h4><p>浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于事件循环的；事件循环是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环；</p>
<p>一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列；多个任务组成了一个队列，即所谓的“宏任务队列”（v8 术语）；例如以下宏任务：</p>
<ul>
<li>当外部脚本 <code>&lt;script src=&quot;...&quot;&gt;</code> 加载完成时，任务就是执行它</li>
<li>当用户移动鼠标时，任务就是派生出 mousemove 事件和执行处理程序；</li>
<li>当安排的（scheduled）setTimeout 时间到达时，任务就是执行其回调；</li>
</ul>
<p>引擎执行任务时永远不会进行渲染（render），如果任务执行需要很长一段时间也没关系，仅在任务完成后才会绘制对 DOM 的更改；如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，通常浏览器会抛出一个如“页面未响应”之类的警报；</p>
<p>当引擎忙于语法高亮时，它就无法处理其他 DOM 相关的工作，它甚至可能会导致浏览器“中断（hiccup）”甚至“挂起（hang）”一段时间；可以通过将大任务拆分成多个小任务来避免这个问题；对浏览器脚本中的过载型任务进行拆分的另一个好处是，可以显示进度指示；</p>
<blockquote>
<p>Tips: 在事件处理程序中，可能会推迟某些行为，直到事件冒泡并在所有级别上得到处理后；可以通过将该代码包装到零延迟的 <code>setTimeout</code> 中来做到这一点；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个具有被点击的菜单项的数据的自定义事件</span></span><br><span class="line">  <span class="keyword">let</span> customEvent = <span class="keyword">new</span> CustomEvent(<span class="string">&quot;menu-open&quot;</span>, &#123;</span><br><span class="line">    bubbles: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步分派（dispatch）自定义事件</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> menu.dispatchEvent(customEvent));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>微任务仅来自于我们的代码，它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务；微任务也被用于 await 的“幕后”，因为它是 promise 处理的另一种形式；</p>
<p>还有一个特殊的函数 queueMicrotask(func)，它对 func 进行排队，以在微任务队列中执行；</p>
<p>微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成；如果我们想要异步执行（在当前代码之后）一个函数，但是要在更改被渲染或新事件被处理之前执行，那么我们可以使用 queueMicrotask 来对其进行安排（schedule）；</p>
<p>简化的事件循环算法：</p>
<ol>
<li>从宏任务队列中出队（dequeue）并执行最早的任务；</li>
<li>执行所有微任务：当微任务队列非空时：出队（dequeue）并执行最早的微任务；</li>
<li>如果有变更，则将变更渲染出来；</li>
<li>如果宏任务队列为空，则休眠直到出现宏任务；</li>
<li>转到步骤 1；</li>
</ol>
<h4 id="弹窗和-window-的方法"><a href="#弹窗和-window-的方法" class="headerlink" title="弹窗和 window 的方法"></a>弹窗和 window 的方法</h4><p>如果弹窗是在用户触发的事件处理程序（如 onclick）之外调用的，大多数浏览器都会阻止此类弹窗；</p>
<p><strong>window.open</strong></p>
<p>打开一个弹窗的语法是 window.open(url, name, params)：</p>
<ul>
<li>url 要在新窗口中加载的 URL；</li>
<li>name 新窗口的名称，每个窗口都有一个 window.name，在这里我们可以指定哪个窗口用于弹窗，如果已经有一个这样名字的窗口，将在该窗口打开给定的 URL，否则会打开一个新窗口；</li>
<li>params 新窗口的配置字符串，用逗号分隔，参数之间不能有空格；</li>
</ul>
<p>params 的设置项：</p>
<ul>
<li>left/top屏幕上窗口的左上角的坐标；这有一个限制：不能将新窗口置于屏幕外；</li>
<li>width/height 新窗口的宽度和高度；宽度/高度的最小值是有限制的，因此不可能创建一个不可见的窗口；</li>
<li>menubar（yes/no）显示或隐藏新窗口的浏览器菜单；</li>
<li>toolbar（yes/no）显示或隐藏新窗口的浏览器导航栏（后退，前进，重新加载等）；</li>
<li>location（yes/no）显示或隐藏新窗口的 URL 字段。Firefox 和 IE 浏览器不允许默认隐藏它；</li>
<li>status（yes/no）显示或隐藏状态栏；大多数浏览器都会强制显示它；</li>
<li>resizable（yes/no）允许禁用新窗口大小调整，不建议使用；</li>
<li>scrollbars（yes/no）允许禁用新窗口的滚动条，不建议使用；</li>
</ul>
<p>设置中的省略规则：</p>
<ul>
<li>如果 open 调用中没有第三个参数，或者它是空的，则使用默认的窗口参数；</li>
<li>如果这里有一个参数字符串，但是某些 yes/no 功能被省略了，那么被省略的功能则被默认值为 no；</li>
<li>如果参数中没有 left/top，那么浏览器会尝试在最后打开的窗口附近打开一个新窗口；</li>
<li>如果没有 width/height，那么新窗口的大小将与上次打开的窗口大小相同；</li>
</ul>
<p>open 调用会返回对新窗口的引用，它可以用来操纵弹窗的属性，更改位置，甚至更多操作；弹窗也可以使用 window.opener 来访问 opener 窗口；除了弹窗之外，对其他所有窗口来说，window.opener 均为 null；</p>
<blockquote>
<p>Note: 只有在窗口是同源的时，窗口才能自由访问彼此的内容；</p>
</blockquote>
<p>通过 win.close() 方法关闭一个窗口，使用 win.closed 属性检查一个窗口是否被关闭；</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/popup-windows">JavaScript 现代教程-弹窗和 window 的方法</a></li>
</ul>
<h4 id="跨窗口通信"><a href="#跨窗口通信" class="headerlink" title="跨窗口通信"></a>跨窗口通信</h4><p>如果两个 URL 具有相同的协议，域和端口，则称它们是“同源”的；“同源（Same Origin）”策略限制了窗口（window）和 frame 之间的相互访问；非同源窗口引用只能更改其 location；</p>
<p><strong>iframe</strong></p>
<p>一个 <code>&lt;iframe&gt;</code> 标签承载了一个单独的嵌入的窗口，它具有自己的 document 和 window；</p>
<ul>
<li>iframe.contentWindow 来获取 <code>&lt;iframe&gt;</code> 中的 window；</li>
<li>iframe.contentDocument 来获取 <code>&lt;iframe&gt;</code> 中的 document，是 iframe.contentWindow.document 的简写形式；</li>
</ul>
<blockquote>
<p>Tips: 通过运行脚本设置拥有二级子域名子窗口的 <code>document.domain</code> 属性为主窗口的主域名，可以实现子窗口和主窗口无限制通信；</p>
</blockquote>
<p>获取 <code>&lt;iframe&gt;</code> 的 window 对象的另一个方式是从命名集合 window.frames 中获取：</p>
<ul>
<li>通过索引获取：window.frames[0] 文档中的第一个 iframe 的 window 对象；</li>
<li>通过名称获取：window.frames.iframeName 获取 name=”iframeName” 的 iframe 的 window 对象；</li>
</ul>
<p>多层嵌套 iframe：</p>
<ul>
<li>window.frames “子”窗口的集合（用于嵌套的 iframe）；</li>
<li>window.parent 对“父”（外部）窗口的引用；</li>
<li>window.top 对最顶级父窗口的引用；</li>
</ul>
<blockquote>
<p>Tips: 可以使用 <code>top</code> 属性来检查当前的文档是否是在 <code>iframe</code> 内打开的：<code>window == window.top</code>；</p>
</blockquote>
<p>sandbox 特性（attribute）允许在 <code>&lt;iframe&gt;</code> 中禁止某些特定行为，以防止其执行不被信任的代码；它通过将 iframe 视为非同源的，或者应用其他限制来实现 iframe 的“沙盒化”；</p>
<p>对于 <code>&lt;iframe sandbox src=&quot;...&quot;&gt;</code>，有一个应用于其上的默认的限制集，一个空的 “sandbox” 特性会施加最严格的限制，但是我们用一个以空格分隔的列表，列出要移除的限制；包括以下限制：</p>
<ul>
<li>allow-same-origin：默认情况下，”sandbox” 会为 iframe 强制实施“不同来源”的策略；</li>
<li>allow-top-navigation：允许 iframe 更改 parent.location；</li>
<li>allow-forms：允许在 iframe 中提交表单；</li>
<li>allow-scripts：允许在 iframe 中运行脚本；</li>
<li>allow-popups：允许在 iframe 中使用 window.open 打开弹窗；</li>
<li>allow-popups：允许在 iframe 中使用 window.open 打开弹窗；</li>
</ul>
<blockquote>
<p>Note: <code>sandbox</code> 特性的目的仅是添加更多限制，它无法移除这些限制；尤其是，如果 <code>iframe</code> 来自其他源，则无法放宽同源策略；</p>
</blockquote>
<p>postMessage 接口允许窗口之间相互通信，无论它们来自什么源；win.postMessage(data, targetOrigin) 方法，data 是要发送的数据，可以是任何对象，数据会被通过使用“结构化序列化算法（structured serialization algorithm）”进行克隆；targetOrigin 指定目标窗口的源，以便只有来自给定的源的窗口才能获得该消息；</p>
<p>targetOrigin 是一种安全措施，如果目标窗口是非同源的，我们无法在发送方窗口读取它的 location；如果不希望做这个检查，可以将 targetOrigin 设置为 *；</p>
<p>为了接收消息，目标窗口应该在 message 事件上有一个处理程序；当 postMessage 被调用时触发该事件（并且 targetOrigin 检查成功）；回调参数 event 对象具有特殊属性：</p>
<ul>
<li>data 从 postMessage 传递来的数据；</li>
<li>origin 发送方的源；</li>
<li>source 对发送方窗口的引用，可以通过 source.postMessage(…) 立即回复；</li>
</ul>
<blockquote>
<p>Note: <code>message</code> 事件只能通过 <code>addEventListener</code> 分配处理程序；</p>
</blockquote>
<h4 id="ArrayBuffer，二进制数组"><a href="#ArrayBuffer，二进制数组" class="headerlink" title="ArrayBuffer，二进制数组"></a>ArrayBuffer，二进制数组</h4><p>ArrayBuffer 是 JavaScript 中基本的二进制对象，是对固定长度的连续内存空间的引用；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个 16 字节的连续内存空间，并用 0 进行预填充</span></span><br><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>); </span><br></pre></td></tr></table></figure>

<p>如要操作 ArrayBuffer，需要使用“视图”对象；视图对象本身并不存储任何东西；它是一副“眼镜”，透过它来解释存储在 ArrayBuffer 中的字节；</p>
<ul>
<li>Uint8Array 将 ArrayBuffer 中的每个字节视为 0 到 255 之间的单个数字，这称为 “8 位无符号整数”；</li>
<li>Uint16Array 将每 2 个字节视为一个 0 到 65535 之间的整数，这称为 “16 位无符号整数”；</li>
<li>Uint32Array 将每 4 个字节视为一个 0 到 4294967295 之间的整数，这称为 “32 位无符号整数”；</li>
<li>Float64Array 将每 8 个字节视为一个 5.0x10^324 到 1.8x10^308 之间的浮点数；</li>
<li>Uint8ClampedArray 用于 8 位整数，在赋值时便“固定“其值；</li>
<li>Int8Array，Int16Array，Int32Array 用于有符号整数（可以为负数）；</li>
<li>Float32Array，Float64Array 用于 32 位和 64 位的有符号浮点数；</li>
</ul>
<p>所有这些视图（Uint8Array，Uint32Array 等）的通用术语是 TypedArray，它们都享有同一组方法和属性；构造方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果给定的是 ArrayBuffer 参数，则会在其上创建视图</span></span><br><span class="line"><span class="comment">// 给定起始位置 byteOffset（默认为 0）以及 length（默认至 buffer 的末尾），视图仅涵盖 buffer 的一段</span></span><br><span class="line"><span class="comment">// new TypedArray(buffer, [byteOffset], [length]);</span></span><br><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>); <span class="comment">// 创建一个长度为 16 的 buffer</span></span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(buffer); <span class="comment">// 将 buffer 视为一个 32 位整数的序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果给定的是 Array，或任何类数组对象，则会创建一个相同长度的类型化数组，并复制其内容</span></span><br><span class="line"><span class="comment">// new TypedArray(object);</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">alert( arr.length ); <span class="comment">// 4，创建了相同长度的二进制数组</span></span><br><span class="line">alert( arr[<span class="number">1</span>] ); <span class="comment">// 1，用给定值填充了 4 个字节（无符号 8 位整数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果给定的是另一个 TypedArray，也是如此：创建一个相同长度的类型化数组，并复制其内容；</span></span><br><span class="line"><span class="comment">// 如果需要的话，数据在此过程中会被转换为新的类型</span></span><br><span class="line"><span class="comment">// new TypedArray(typedArray);</span></span><br><span class="line"><span class="keyword">let</span> arr16 = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>([<span class="number">1</span>, <span class="number">1000</span>]);</span><br><span class="line"><span class="keyword">let</span> arr8 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(arr16);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于数字参数 length —— 创建类型化数组以包含这么多元素；</span></span><br><span class="line"><span class="comment">// 它的字节长度将是 length 乘以单个 TypedArray.BYTES_PER_ELEMENT 中的字节数</span></span><br><span class="line"><span class="comment">// new TypedArray(length);</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">4</span>); <span class="comment">// 为 4 个整数创建类型化数组</span></span><br><span class="line">alert( <span class="built_in">Uint16Array</span>.BYTES_PER_ELEMENT ); <span class="comment">// 每个整数 2 个字节</span></span><br><span class="line">alert( arr.byteLength ); <span class="comment">// 8（字节中的大小）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带参数的情况下，创建长度为零的类型化数组</span></span><br><span class="line"><span class="keyword">new</span> TypedArray();</span><br></pre></td></tr></table></figure>

<p>可以直接创建一个 TypedArray，而无需提及 ArrayBuffer，除第一种情况（已提供 ArrayBuffer）外，其他所有情况都会自动创建 ArrayBuffer；可以通过 buffer 属性，访问 ArrayBuffer，byteLength 属性获取 ArrayBuffer 的长度；</p>
<p>如果尝试将越界值写入类型化数组，多余的位被切除；Uint8ClampedArray 在这方面比较特殊，它的表现不太一样；对于大于 255 的任何数字，它将保存为 255，对于任何负数，它将保存为 0，此行为对于图像处理很有用；</p>
<p>TypedArray 具有常规的 Array 方法：</p>
<ul>
<li>可以遍历（iterate），map，slice，find 和 reduce 等；</li>
<li>没有 splice 和 concat；</li>
<li>arr.set(fromArr, [offset]) 从 offset（默认为 0）开始，将 fromArr 中的所有元素复制到 arr；</li>
<li>arr.subarray([begin, end]) 创建一个从 begin 到 end（不包括）相同类型的新视图，不复制任何内容；</li>
</ul>
<p>DataView 是在 ArrayBuffer 上的一种特殊的超灵活“未类型化”视图；它允许以任何格式访问任何偏移量（offset）的数据；</p>
<p>对于类型化的数组，构造器决定了其格式，整个数组应该是统一的，第 i 个数字是 arr[i]；通过 DataView，我们可以使用 .getUint8(i) 或 .getUint16(i) 之类的方法访问数据；可以在调用方法时选择格式，而不是在构造的时候；</p>
<p>通过调用 new DataView(buffer, [byteOffset], [byteLength]) 创建一个 dataView 视图；</p>
<ul>
<li>buffer 底层的 ArrayBuffer；与类型化数组不同，DataView 不会自行创建缓冲区（buffer）；</li>
<li>byteOffset 视图的起始字节位置（默认为 0）；</li>
<li>byteLength 视图的字节长度（默认至 buffer 的末尾）；</li>
</ul>
<blockquote>
<p>Note: 还有另外两个术语，用于对二进制数据进行操作的方法的描述：<code>ArrayBufferView</code> 是所有这些视图的总称，<code>BufferSource</code> 是 <code>ArrayBuffer</code> 和 <code>ArrayBufferView</code> 的总称；</p>
</blockquote>
<h4 id="TextDecoder-和-TextEncoder"><a href="#TextDecoder-和-TextEncoder" class="headerlink" title="TextDecoder 和 TextEncoder"></a>TextDecoder 和 TextEncoder</h4><p>内建的 TextDecoder 对象在给定缓冲区（buffer）和编码格式（encoding）的情况下，能够将值读取到实际的 JavaScript 字符串中；</p>
<p>decoder 通过 new TextDecoder([label], [options]) 创建：</p>
<ul>
<li>label 编码格式，默认为 utf-8，但同时也支持 big5，windows-1251 等许多其他编码格式；</li>
<li>options 可选对象；<ul>
<li>fatal 布尔值，如果为 true 则为无效（不可解码）字符抛出异常，否则（默认）用字符 \uFFFD 替换无效字符 ；</li>
<li>ignoreBOM 布尔值，如果为 true 则 BOM（可选的字节顺序 unicode 标记），很少需要使用；</li>
</ul>
</li>
</ul>
<p>通过 decoder.decode([input], [options]) 方法解码：</p>
<ul>
<li>input 要被解码的 BufferSource；</li>
<li>options 可选对象：<ul>
<li>stream 对于解码流，为 true，则将传入的数据块（chunk）作为参数重复调用 decoder；</li>
</ul>
</li>
</ul>
<p>stream 为 true 时，多字节的字符可能偶尔会在块与块之间被分割，这个选项告诉 TextDecoder 记住“未完成”的字符，并在下一个数据块来的时候进行解码；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uint8Array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>]);</span><br><span class="line"></span><br><span class="line">alert( <span class="keyword">new</span> TextDecoder().decode(uint8Array) ); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>TextEncoder 做相反的事情：将字符串转换为字节；通过 new TextEncoder() 创建；encoder 有两个方法：</p>
<ul>
<li>encode(str) 从字符串返回 Uint8Array；</li>
<li>encodeInto(str, destination) 将 str 编码到 destination 中，该目标必须为 Uint8Array；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> encoder = <span class="keyword">new</span> TextEncoder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uint8Array = encoder.encode(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">alert(uint8Array); <span class="comment">// 72,101,108,108,111</span></span><br></pre></td></tr></table></figure>

<h4 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h4><p>arrayBuffer 和视图（view）都是 ECMA 标准的一部分，是 JavaScript 的一部分；浏览器还有一个二进制类型大对象 Blob，Blob 对象表示一个不可变、原始数据的类文件对象，由可选的字符串 type（通常是 MIME 类型）和 blobParts 组成；</p>
<p>new Blob(blobParts, options) 创建一个 Blob；</p>
<ul>
<li>blobParts 是 Blob/BufferSource/String 类型的值的数组；</li>
<li>options 可选对象；<ul>
<li>type Blob 类型，通常是 MIME 类型；</li>
<li>endings 是否转换换行符，使 Blob 对应于当前操作系统的换行符（\r\n 或 \n）；默认为 “transparent”（不转换），或者 “native”（转换）；</li>
</ul>
</li>
</ul>
<p>可以用 blob.slice([byteStart], [byteEnd], [contentType]) 方法来提取 Blob 片段：</p>
<ul>
<li>byteStart 起始字节，默认为 0；</li>
<li>byteEnd 最后一个字节（专有，默认为最后）；</li>
<li>contentType 新 blob 的 type，默认与源 blob 相同；</li>
</ul>
<blockquote>
<p>Note: 无法直接在 <code>Blob</code> 中更改数据，但我们可以通过 <code>slice</code> 获得 <code>Blob</code> 的多个部分，从这些部分创建新的 <code>Blob</code> 对象，将它们组成新的 <code>Blob</code>；</p>
</blockquote>
<p><strong>Blob 作为 URL</strong></p>
<p>Blob 可以很容易用作 <code>&lt;a&gt;</code>、<code>&lt;img&gt;</code> 或其他标签的 URL，来显示它们的内容；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// download 特性（attribute）强制浏览器下载而不是导航</span></span><br><span class="line"><span class="comment">// &lt;a download=&quot;hello.txt&quot; href=&quot;blob:http://localhost:8000/c2d14ed6-c271-46be-9164-06042e419312&quot;&gt;hello.txt&lt;/a&gt;</span></span><br><span class="line"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([<span class="string">&quot;Hello, world!&quot;</span>], &#123; <span class="attr">type</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">link.download = <span class="string">&quot;hello.txt&quot;</span>;</span><br><span class="line">link.href = URL.createObjectURL(blob);</span><br><span class="line">link.innerHTML = <span class="string">&quot;hello.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到 DOM</span></span><br><span class="line"><span class="built_in">document</span>.body.append(link);</span><br><span class="line"><span class="comment">// 或者模拟点击，自动下载</span></span><br><span class="line">link.click();</span><br><span class="line"><span class="comment">// 从内部映射中移除引用</span></span><br><span class="line">URL.revokeObjectURL(link.href);</span><br></pre></td></tr></table></figure>

<p>URL.createObjectURL 取一个 Blob，并为其创建一个唯一的 URL，形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code>；浏览器内部为每个通过 URL.createObjectURL 生成的 URL 存储了一个 URL -&gt; Blob 映射，生成的 URL（即其链接）仅在当前文档打开的状态下才有效；</p>
<blockquote>
<p>Note: 如果我们创建一个 <code>URL</code>，那么即使我们不再需要该 <code>Blob</code> 了，它也会被挂在内存中；<code>URL.revokeObjectURL(url)</code> 从内部映射中移除引用，因此允许 <code>Blob</code> 被删除（如果没有其他引用的话），并释放内存；</p>
</blockquote>
<p><strong>Blob 转为 base64</strong></p>
<p>URL.createObjectURL 的一个替代方法是，将 Blob 转换为 base64-编码的字符串；这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读”；</p>
<p>可以在 “data-url” 中使用此编码，“data-url” 的形式为 <code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code>，并且可以在任何地方和“常规” url 一样使用这种 url；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([<span class="string">&#x27;Hello, world!&#x27;</span>], &#123;<span class="attr">type</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内建的 FileReader 对象可以将 Blob 转换为 base64；</span></span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">reader.readAsDataURL(blob); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 onload</span></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  link.href = reader.result; <span class="comment">// data url</span></span><br><span class="line">  link.click();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>Blob</code> 转换为 <code>data url</code>，当对大的 <code>Blob</code> 进行编码时，性能和内存会有损耗；</p>
</blockquote>
<p><strong>Image 转为 blob</strong></p>
<p>可以创建一个图像（image）的、图像的一部分、或者甚至创建一个页面截图的 Blob；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取任何图像</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成同尺寸的 &lt;canvas&gt;</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">canvas.width = img.clientWidth;</span><br><span class="line">canvas.height = img.clientHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> context = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向其中复制图像（此方法允许剪裁图像）</span></span><br><span class="line">context.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 我们 context.rotate()，并在 canvas 上做很多其他事情</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toBlob 是异步操作，结束后会调用 callback</span></span><br><span class="line"><span class="keyword">let</span> blob = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> canvasElem.toBlob(resolve, <span class="string">&#x27;image/png&#x27;</span>));</span><br><span class="line">  <span class="comment">// blob 创建完成，下载它</span></span><br><span class="line"><span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">link.download = <span class="string">&#x27;example.png&#x27;</span>;</span><br><span class="line"></span><br><span class="line">link.href = URL.createObjectURL(blob);</span><br><span class="line">link.click();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除内部 blob 引用，这样浏览器可以从内存中将其清除</span></span><br><span class="line">URL.revokeObjectURL(link.href);</span><br></pre></td></tr></table></figure>

<p><strong>Blob 转为 arrayBuffer</strong></p>
<p>Blob 构造器允许从几乎所有东西创建 blob，包括任何 BufferSource；如果需要执行低级别的操作的话，则可以使用 blob.arrayBuffer() 从 blob 中获取最低级别的 arrayBuffer；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 blob 获取 arrayBuffer</span></span><br><span class="line"><span class="keyword">const</span> bufferPromise = <span class="keyword">await</span> blob.arrayBuffer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">blob.arrayBuffer().then(<span class="function"><span class="params">buffer</span> =&gt;</span> <span class="comment">/* 处理 arrayBuffer */</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Blob 转为 stream</strong></p>
<p>当读取和写入超过 2 GB 的 blob 时，将其转换为 arrayBuffer 的使用对我们来说会更加占用内存；这种情况下，可以直接将 blob 转换为 stream 进行处理；stream 是一种特殊的对象，我们可以从它那里逐部分地读取（或写入）；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 blob 获取可读流（readableStream）</span></span><br><span class="line"><span class="keyword">const</span> readableStream = blob.stream();</span><br><span class="line"><span class="keyword">const</span> stream = readableStream.getReader();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 对于每次迭代：data 是下一个 blob 数据片段</span></span><br><span class="line">  <span class="keyword">let</span> &#123; done, data &#125; = <span class="keyword">await</span> stream.read();</span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="comment">// 读取完毕，stream 里已经没有数据了</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;all blob processed.&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对刚从 blob 中读取的数据片段做一些处理</span></span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File-和-FileReader"><a href="#File-和-FileReader" class="headerlink" title="File 和 FileReader"></a>File 和 FileReader</h4><p>File 对象继承自 Blob，并扩展了与文件系统相关的功能；</p>
<p>File 对象可以通古构造器创建 new File(fileParts, fileName, [options])；</p>
<ul>
<li>fileParts Blob/BufferSource/String 类型值的数组；</li>
<li>fileName 文件名字符串；</li>
<li>options 可选对象，<ul>
<li>lastModified 最后一次修改的时间戳（整数日期）；</li>
</ul>
</li>
</ul>
<p>或者通常从 <code>&lt;input type=&quot;file&quot;&gt;</code> 或拖放或其他浏览器接口来获取文件；在这种情况下，file 将从操作系统（OS）获得 this 信息；输入（input）可以选择多个文件，因此 input.files 是一个类数组对象；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> file = <span class="built_in">document</span>.createElement(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">file.type = <span class="string">&quot;file&quot;</span>;</span><br><span class="line">file.onchange = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.files[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.append(file);</span><br></pre></td></tr></table></figure>

<p>FileReader 是一个对象，其唯一目的是从 Blob（因此也从 File）对象中读取数据；但使用事件来传递数据，因为从磁盘读取数据可能比较费时间；</p>
<ul>
<li>创建：<ul>
<li>new FileReader() 一个无参构造函数；</li>
</ul>
</li>
<li>方法：<ul>
<li>readAsArrayBuffer(blob) 将数据读取为二进制格式的 ArrayBuffer；</li>
<li>readAsText(blob, [encoding]) 将数据读取为给定编码（默认为 utf-8 编码）的文本字符串；</li>
<li>readAsDataURL(blob) 读取二进制数据，并将其编码为 base64 的 data url；</li>
<li>abort() 取消操作；</li>
</ul>
</li>
<li>事件：<ul>
<li>loadstart 开始加载；</li>
<li>progress 在读取过程中出现；</li>
<li>load 读取完成，没有 error；</li>
<li>abort 调用了 abort()；</li>
<li>error 出现 error；</li>
<li>loadend 读取完成，无论成功还是失败；</li>
</ul>
</li>
<li>结果：<ul>
<li>reader.result 是结果（如果成功）；</li>
<li>reader.error 是 error（如果失败）；</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;readFile(this)&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">input</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> file = input.files[<span class="number">0</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"></span><br><span class="line">  reader.readAsText(file);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(reader.result);</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(reader.error);</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 对于 <code>Web Worker</code>，还有一种同步的 <code>FileReader</code> 变体，称为 <code>FileReaderSync</code>；读取方法 <code>read*</code> 不会生成事件，而是会像常规函数那样返回一个结果；</p>
</blockquote>
<h4 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h4><p>JavaScript 可以将网络请求发送到服务器，并在需要时加载新信息；fetch() 方法是一种现代通用的方法；</p>
<ul>
<li>语法：<ul>
<li>let promise = fetch(url, [options])</li>
</ul>
</li>
<li>参数：<ul>
<li>url 要访问的 URL；</li>
<li>options 可选参数：method，header 等；</li>
</ul>
</li>
<li>响应：<ul>
<li>status HTTP 状态码；</li>
<li>ok 布尔值，如果 HTTP 状态码为 200-299，则为 true；</li>
</ul>
</li>
<li>方法：<ul>
<li>response.text() 读取 response，并以文本形式返回 response；</li>
<li>response.json() 将 response 解析为 JSON；</li>
<li>response.formData() 以 FormData 对象的形式返回 response；</li>
<li>response.blob() 以 Blob（具有类型的二进制数据）形式返回 response；</li>
<li>response.arrayBuffer() 以 ArrayBuffer（低级别的二进制数据）形式返回 response；</li>
</ul>
</li>
</ul>
<p>没有 options fetch 就是一个简单的 GET 请求，下载 url 的内容；返回一个该调用代码应该用来获取结果的 promise；</p>
<p>获取响应分为两个阶段：第一阶段，当服务器发送了响应头（response header），fetch 返回的 promise 就使用内建的 Response class 对象来对响应头进行解析；第二阶段，需要使用其他的方法调用以获取 response body；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// await 调用</span></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url, options); <span class="comment">// 解析 response header</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> response.json(); <span class="comment">// 将 body 读取为 json</span></span><br><span class="line"><span class="comment">// 或者 promise</span></span><br><span class="line">fetch(url, options)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="comment">/* process result */</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例</span></span><br><span class="line">fetch(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.ok) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        res.text().then(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(text);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 如果已经使用了 <code>response</code> 读取方法来获取 <code>response</code>，那么如果再用另一种 <code>response</code> 方法，则不会生效，因为 <code>body</code> 内容已经被处理过了；</p>
</blockquote>
<p>Response header 位于 response.headers 中的一个类似于 Map 的 header 对象；但不是真正的 Map，只是具有类似的方法，可以按名称（name）获取各个 header，或迭代所有 header；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个 header</span></span><br><span class="line">alert(response.headers.get(<span class="string">&#x27;Content-Type&#x27;</span>)); <span class="comment">// application/json; charset=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代所有 header</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> response.headers) &#123;</span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 headers 选项在 fetch 中设置 request header，它有一个带有输出 header 的对象；但有一些无法设置的 header，参见 <a target="_blank" rel="noopener" href="https://fetch.spec.whatwg.org/#forbidden-header-name">forbidden HTTP headers</a>；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = fetch(protectedUrl, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Authentication: <span class="string">&#x27;secret&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过设置选项中 method 可以创建一个 POST 或者其他类型的请求；此外选项中 body 字段会作为请求体发送，需是以下内容之一：</p>
<ul>
<li>字符串；</li>
<li>FormData 对象，以 form/multipart 形式发送数据；</li>
<li>Blob/BufferSource 发送二进制数据；</li>
<li>URLSearchParams，以 x-www-form-urlencoded 编码形式发送数据，很少使用；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  surname: <span class="string">&#x27;Smith&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/fetch/post/user&#x27;</span>, &#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(user)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> response.json();</span><br><span class="line">alert(result.message);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 如果请求的 body 是字符串，则 Content-Type 会默认设置为 text/plain;charset=UTF-8；但要发送 JSON 时，会使用 headers 选项来发送 application/json，这是 JSON 编码的数据的正确的 Content-Type；</p>
</blockquote>
<h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p>FormData 的特殊之处在于网络方法（network methods），例如 fetch 可以接受一个 FormData 对象作为 body；它会被编码并发送出去，带有 Content-Type: multipart/form-data；</p>
<ul>
<li>创建：如果提供了 HTML form 元素，它会自动捕获 form 元素字段<br>let formData = new FormData([form])</li>
<li>方法：<ul>
<li>formData.append(name, value) 添加具有给定 name 和 value 的表单字段；</li>
<li>formData.append(name, blob, fileName) 添加一个文件字段，相当于 <code>&lt;input type=&quot;file&quot;&gt;</code>，第三个参数 fileName 设置文件名；</li>
<li>formData.delete(name) 移除带有给定 name 的字段；</li>
<li>formData.get(name) 获取带有给定 name 的字段值；</li>
<li>formData.has(name) 如果存在带有给定 name 的字段，则返回 true，否则返回 false；</li>
<li>formData.set(name, value) 类似于 append，但移除所有具有给定 name 的字段，然后附加一个新字段；</li>
<li>formData.set(name, blob, fileName) 类似 append，同名字段值会被新值覆盖；</li>
</ul>
</li>
</ul>
<p>从技术上来讲，一个表单可以包含多个具有相同 name 的字段，因此，多次调用 append 将会添加多个具有相同名称的字段；而 set 方法确保了只有一个具有这种 name 的字段；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;formElem&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;surname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Smith&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  formElem.onsubmit = <span class="keyword">async</span> (e) =&gt; &#123;</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/formdata/post/user&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">      method: <span class="string">&#x27;POST&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      body: <span class="keyword">new</span> FormData(formElem)</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> result = <span class="keyword">await</span> response.json();</span></span><br><span class="line"></span><br><span class="line">    alert(result.message);</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表单始终以 Content-Type: multipart/form-data 来发送数据，这个编码允许发送文件；</p>
<h4 id="Fetch：下载进度"><a href="#Fetch：下载进度" class="headerlink" title="Fetch：下载进度"></a>Fetch：下载进度</h4><p>fetch 方法允许去跟踪下载进度，但到目前为止，fetch 方法无法跟踪上传进度；</p>
<p>要跟踪下载进度，可以使用 response.body 属性，它是一个可以逐块（chunk）提供 body 的特殊的对象 ReadableStream；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代替 response.json() 以及其他方法</span></span><br><span class="line"><span class="keyword">const</span> reader = response.body.getReader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 body 下载时，一直为无限循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 当最后一块下载完成时，done 值为 true</span></span><br><span class="line">  <span class="comment">// value 是块字节的 Uint8Array</span></span><br><span class="line">  <span class="keyword">const</span> &#123;done, value&#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Received <span class="subst">$&#123;value.length&#125;</span> bytes`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 await reader.read() 调用的结果是一个具有两个属性的对象：</p>
<ul>
<li>done 当读取完成时为 true，否则为 false；</li>
<li>value 字节的类型化数组：Uint8Array；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 1：启动 fetch，并获得一个 reader</span></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reader = response.body.getReader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2：获得总长度（length）</span></span><br><span class="line"><span class="keyword">const</span> contentLength = +response.headers.get(<span class="string">&#x27;Content-Length&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3：读取数据</span></span><br><span class="line"><span class="keyword">let</span> receivedLength = <span class="number">0</span>; <span class="comment">// 当前接收到了这么多字节</span></span><br><span class="line"><span class="keyword">let</span> chunks = []; <span class="comment">// 接收到的二进制块的数组（包括 body）</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;done, value&#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  chunks.push(value);</span><br><span class="line">  receivedLength += value.length;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Received <span class="subst">$&#123;receivedLength&#125;</span> of <span class="subst">$&#123;contentLength&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4：将块连接到单个 Uint8Array</span></span><br><span class="line"><span class="keyword">let</span> chunksAll = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(receivedLength); <span class="comment">// (4.1)</span></span><br><span class="line"><span class="keyword">let</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> chunk <span class="keyword">of</span> chunks) &#123;</span><br><span class="line">  chunksAll.set(chunk, position); <span class="comment">// (4.2)</span></span><br><span class="line">  position += chunk.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 5：解码成字符串</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">new</span> TextDecoder(<span class="string">&quot;utf-8&quot;</span>).decode(chunksAll);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们完成啦！</span></span><br><span class="line"><span class="keyword">let</span> commits = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">alert(commits[<span class="number">0</span>].author.login);</span><br></pre></td></tr></table></figure>

<h4 id="Fetch：中止"><a href="#Fetch：中止" class="headerlink" title="Fetch：中止"></a>Fetch：中止</h4><p>有一个特殊的内建对象：AbortController；它不仅可以中止 fetch，还可以中止其他异步任务；</p>
<ul>
<li>创建：</li>
<li>let controller = new AbortController();</li>
<li>方法：</li>
<li>abort() 中止异步操作；</li>
<li>属性：</li>
<li>signal 可以在这个属性上设置事件监听器；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line"><span class="keyword">let</span> signal = controller.signal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可取消的操作这一部分</span></span><br><span class="line"><span class="comment">// 获取 &quot;signal&quot; 对象，</span></span><br><span class="line"><span class="comment">// 并将监听器设置为在 controller.abort() 被调用时触发</span></span><br><span class="line">signal.addEventListener(<span class="string">&#x27;abort&#x27;</span>, <span class="function">() =&gt;</span> alert(<span class="string">&quot;abort!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一部分，取消（在之后的任何时候）：</span></span><br><span class="line">controller.abort(); <span class="comment">// 中止！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件触发，signal.aborted 变为 true</span></span><br><span class="line">alert(signal.aborted); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>为了能够取消 fetch，请将 AbortController 的 signal 属性作为 fetch 的一个可选参数（option）进行传递；fetch 方法知道如何与 AbortController 一起工作，它会监听 signal 上的 abort 事件；当一个 fetch 被中止，它的 promise 就会以一个 error AbortError reject，因此我们应该对其进行处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 秒后中止</span></span><br><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> controller.abort(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/fetch-abort/demo/hang&#x27;</span>, &#123;</span><br><span class="line">    signal: controller.signal</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.name == <span class="string">&#x27;AbortError&#x27;</span>) &#123; <span class="comment">// handle abort()</span></span><br><span class="line">    alert(<span class="string">&quot;Aborted!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbortController 是可伸缩的，它允许一次取消多个 fetch；如果我们有自己的与 fetch 不同的异步任务，我们可以使用单个 AbortController 中止这些任务以及 fetch；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> urls = [...];</span><br><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ourJob = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// 我们的任务</span></span><br><span class="line">  ...</span><br><span class="line">  controller.signal.addEventListener(<span class="string">&#x27;abort&#x27;</span>, reject);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fetchJobs = urls.map(<span class="function"><span class="params">url</span> =&gt;</span> fetch(url, &#123; <span class="comment">// fetches</span></span><br><span class="line">  signal: controller.signal</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待完成我们的任务和所有 fetch</span></span><br><span class="line"><span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([...fetchJobs, ourJob]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 controller.abort() 被从其他地方调用，</span></span><br><span class="line"><span class="comment">// 它将中止所有 fetch 和 ourJob</span></span><br></pre></td></tr></table></figure>

<h4 id="Fetch：跨源请求"><a href="#Fetch：跨源请求" class="headerlink" title="Fetch：跨源请求"></a>Fetch：跨源请求</h4><p>可以使用 script 标签实现跨域，也成为 jsonp；</p>
<p>有两种类型的跨源请求：</p>
<ul>
<li>所有其他请求；</li>
<li>简单的请求：<ul>
<li>method 为 GET，POST 或 HEAD 类型；</li>
<li>仅允许自定义这些 header：Accept，Accept-Language，Content-Language，Content-Type 的值为 application/x-www-form-urlencoded，multipart/form-data 或 text/plain；</li>
</ul>
</li>
</ul>
<p>当尝试发送一个非简单请求时，浏览器会发送一个特殊的“预检（preflight）”请求到服务器，询问服务器，是否接受此类跨源请求，并且，除非服务器明确通过 header 进行确认，否则非简单请求不会被发送；</p>
<p>如果一个请求是跨源的，浏览器始终会向其添加 Origin header；服务器可以检查 Origin，如果同意接受这样的请求，就会在响应中添加一个特殊的 header Access-Control-Allow-Origin；</p>
<p>对于跨源请求，默认情况下，JavaScript 只能访问“简单” response header：Cache-Control，Content-Language，Content-Type，Expires，Last-Modified，Pragma；访问任何其他 response header 都将导致 error；</p>
<p>可能仍然存在有些 Web 服务将非标准方法视为一个信号：“这不是浏览器”；因此，为了避免误解，任何“非标准”请求，浏览器不会立即发出在过去无法完成的这类请求；即在它发送这类请求前，会先发送“预检（preflight）”请求来请求许可；预检请求发生在“幕后”，它对 JavaScript 不可见；</p>
<p>预检请求使用 OPTIONS 方法，它没有 body，但是有两个 header：</p>
<ul>
<li>Access-Control-Request-Method header 带有非简单请求的方法；</li>
<li>Access-Control-Request-Headers header 提供一个以逗号分隔的非简单 HTTP-header 列表；</li>
</ul>
<p>如果服务器同意处理请求，那么它会进行响应，此响应的状态码应该为 200，没有 body，具有 header：</p>
<ul>
<li>Access-Control-Allow-Origin 必须为 * 或进行请求的源才能允许此请求；</li>
<li>Access-Control-Allow-Methods 必须具有允许的方法；</li>
<li>Access-Control-Allow-Headers 必须具有一个允许的 header 列表；</li>
<li>header Access-Control-Max-Age 可以指定缓存此权限的秒数，因此，浏览器不是必须为满足给定权限的后续请求发送预检；</li>
</ul>
<blockquote>
<p>Note: 服务器不应该忘记在主响应中添加 <code>Access-Control-Allow-Origin</code>，成功的预检并不能免除此要求；</p>
</blockquote>
<p>默认情况下，由 JavaScript 代码发起的跨源请求不会带来任何凭据，cookies 或者 HTTP 认证（HTTP authentication）；这是因为具有凭据的请求比没有凭据的请求要强大得多，如果被允许，它会使用它们的凭据授予 JavaScript 代表用户行为和访问敏感信息的全部权力；</p>
<p>服务器必须显式地带有允许请求的凭据和附加 header，如果服务器同意接受 带有凭据 的请求，则除了 Access-Control-Allow-Origin 外，服务器还应该在响应中添加 header Access-Control-Allow-Credentials: true；对于具有凭据的请求，禁止 Access-Control-Allow-Origin 使用星号 *；</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/fetch-crossorigin">JavaScript 现代教程-Fetch：跨源请求</a></li>
</ul>
<h4 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = fetch(url, &#123;</span><br><span class="line">  method: <span class="string">&quot;GET&quot;</span>, <span class="comment">// POST，PUT，DELETE，等。</span></span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="comment">// 内容类型 header 值通常是自动设置的</span></span><br><span class="line">    <span class="comment">// 取决于 request body</span></span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain;charset=UTF-8&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="literal">undefined</span> <span class="comment">// string，FormData，Blob，BufferSource，或 URLSearchParams</span></span><br><span class="line">  referrer: <span class="string">&quot;about:client&quot;</span>, <span class="comment">// 或 &quot;&quot; 以不发送 Referer header，</span></span><br><span class="line">  <span class="comment">// 或者是当前源的 url</span></span><br><span class="line">  referrerPolicy: <span class="string">&quot;no-referrer-when-downgrade&quot;</span>, <span class="comment">// no-referrer，origin，same-origin...</span></span><br><span class="line">  mode: <span class="string">&quot;cors&quot;</span>, <span class="comment">// same-origin，no-cors</span></span><br><span class="line">  credentials: <span class="string">&quot;same-origin&quot;</span>, <span class="comment">// omit，include</span></span><br><span class="line">  cache: <span class="string">&quot;default&quot;</span>, <span class="comment">// no-store，reload，no-cache，force-cache，或 only-if-cached</span></span><br><span class="line">  redirect: <span class="string">&quot;follow&quot;</span>, <span class="comment">// manual，error</span></span><br><span class="line">  integrity: <span class="string">&quot;&quot;</span>, <span class="comment">// 一个 hash，像 &quot;sha256-abcdef1234567890&quot;</span></span><br><span class="line">  keepalive: <span class="literal">false</span>, <span class="comment">// true keepalive 选项表示该请求可能会在网页关闭后继续存在</span></span><br><span class="line">  signal: <span class="literal">undefined</span>, <span class="comment">// AbortController 来中止请求</span></span><br><span class="line">  <span class="built_in">window</span>: <span class="built_in">window</span> <span class="comment">// null</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/long-polling">JavaScript 现代教程-长轮询（Long polling）</a></li>
</ul>
<h4 id="URL-对象"><a href="#URL-对象" class="headerlink" title="URL 对象"></a>URL 对象</h4><p>内建的 URL 类提供了用于创建和解析 URL 的便捷接口；URL 对象立即允许我们访问其组件，因此这是一个解析 url 的好方法；</p>
<ul>
<li>创建 new URL(url, [base])：<ul>
<li>url 完整的 URL，或者仅路径（如果设置了 base）；</li>
<li>base 可选的 base URL：如果设置了此参数，且参数 url 只有路径，则会根据这个 base 生成 URL；</li>
</ul>
</li>
<li>组件：<ul>
<li>href 是完整的 URL，与 url.toString() 相同；</li>
<li>protocol 以冒号字符 : 结尾；</li>
<li>search 以问号 ? 开头的一串参数；</li>
<li>hash 以哈希字符 # 开头；</li>
</ul>
</li>
<li>方法：<ul>
<li>append(name, value) 按照 name 添加参数；</li>
<li>delete(name) 按照 name 移除参数；</li>
<li>get(name) 按照 name 获取参数；</li>
<li>getAll(name) 获取相同 name 的所有参数；</li>
<li>has(name) 按照 name 检查参数是否存在；</li>
<li>set(name, value) set/replace 参数；</li>
<li>sort() 按 name 对参数进行排序，很少使用；</li>
</ul>
</li>
</ul>
<blockquote>
<p>Tips: 可以在 <code>fetch</code> 或 <code>XMLHttpRequest</code> 中使用 <code>URL</code> 对象，几乎可以在任何需要 <code>URL</code> 字符串的地方都能使用 <code>URL</code> 对象，大多数方法都会执行字符串转换，这会将 <code>URL</code> 对象转换为具有完整 <code>URL</code> 的字符串；</p>
</blockquote>
<p>URL 对象会自动处理那些不被允许的字符必须被编码，用其 UTF-8 代码代替；</p>
<p>下面是用于编码/解码 URL 的内建函数：</p>
<ul>
<li>encodeURI 编码整个 URL；</li>
<li>decodeURI 解码为编码前的状态；</li>
<li>encodeURIComponent 编码 URL 组件，例如搜索参数，或者 hash，或者 pathname；</li>
<li>decodeURIComponent 解码为编码前的状态；</li>
</ul>
<blockquote>
<p>Note: <code>encodeURI</code> 仅编码 <code>URL</code> 中完全禁止的字符；<code>encodeURIComponent</code> 也编码这类字符，此外，还编码 <code># $ &amp; + , / : ; = ? @</code> 字符；因此对于一个 <code>URL</code> 整体，可以使用 <code>encodeURI</code>，对于 <code>URL</code> 参数，应该改用 <code>encodeURIComponent</code>；</p>
</blockquote>
<blockquote>
<p>Note: <code>encode*</code> 与 <code>URL</code> 在对 IPv6 地址的编码方式不同，<code>URL</code> 可以正确编码；</p>
</blockquote>
<h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><p>XMLHttpRequest 是一个内建的浏览器对象，它允许使用 JavaScript 发送 HTTP 请求；XMLHttpRequest 有两种执行模式：同步（synchronous）和异步（asynchronous）；</p>
<ul>
<li>创建：let xhr = new XMLHttpRequest();</li>
<li>初始化：xhr.open(method, URL, [async, user, password])<ul>
<li>method HTTP 方法，通常是 “GET” 或 “POST”；</li>
<li>URL 要请求的 URL，通常是一个字符串，也可以是 URL 对象；</li>
<li>async 如果显式地设置为 false，那么请求将会以同步的方式处理；</li>
<li>user，password HTTP 基本身份验证（如果需要的话）的登录名和密码；</li>
</ul>
</li>
<li>发送请求：xhr.send([body])；</li>
<li>监听响应：<ul>
<li>load 当请求完成，并且响应已完全下载；</li>
<li>error 当无法发出请求，例如网络中断或者无效的 URL；</li>
<li>progress 在下载响应期间定期触发，报告已经下载了多少；</li>
</ul>
</li>
<li>响应：<ul>
<li>status HTTP 状态码（一个数字）：如果出现非 HTTP 错误，则为 0；</li>
<li>statusText HTTP 状态消息（一个字符串）；</li>
<li>response（旧脚本可能是 responseText）：服务器 response body；</li>
</ul>
</li>
<li>xhr 属性：<ul>
<li>timeout 超时时间，在给定时间内请求没有成功执行，请求就会被取消，并且触发 timeout 事件；</li>
<li>responseType 响应类型，<ul>
<li>“” 响应格式为字符串（默认）；</li>
<li>“text” 响应格式为字符串；</li>
<li>“arraybuffer” 响应格式为 ArrayBuffer；</li>
<li>“blob” 响应格式为 Blob；</li>
<li>“document” 响应格式为 XML document；</li>
<li>“json” 响应格式为 JSON（自动解析）；</li>
</ul>
</li>
<li>readyState 请求处理状态，XMLHttpRequest 的状态会随着它的处理进度变化而变化；<ul>
<li>0 UNSENT 初始状态；</li>
<li>1 OPENED open 被调用；</li>
<li>2 HEADERS_RECEIVED 接收到 response header；</li>
<li>3 LOADING 响应正在被加载，每接收到一个数据包会重复一次该状态；</li>
<li>4 DONE 请求完成；</li>
</ul>
</li>
<li>withCredentials true，将 cookie 和 HTTP 授权发送到其他域，默认 false；</li>
<li>abort() 方法，终止请求；会触发 abort 事件，且 xhr.status 变为 0；</li>
<li>setRequestHeader(name, value) 使用给定的 name 和 value 设置 request header；</li>
<li>getResponseHeader(name) 获取具有给定 name 的 header（Set-Cookie 和 Set-Cookie2 除外）；</li>
<li>getAllResponseHeaders() 返回除 Set-Cookie 和 Set-Cookie2 外的所有 response header；</li>
</ul>
</li>
<li>xhr 事件：上传需要专门用于跟踪上传事件的 xhr.upload 对象上监听；<ul>
<li>readystatechange 事件，跟踪请求处理状态变化；</li>
<li>loadstart 请求开始；</li>
<li>progress 一个响应数据包到达，此时整个 response body 都在 response 中；</li>
<li>abort 调用 xhr.abort() 取消了请求；</li>
<li>error 发生连接错误，例如，域错误。不会发生诸如 404 这类的 HTTP 错误；</li>
<li>load 请求成功完成；</li>
<li>timeout 由于请求超时而取消了该请求（仅发生在设置了 timeout 的情况下）；</li>
<li>loadend 在 load，error，timeout 或 abort 之后触发；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 new XMLHttpRequest 对象</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置它：从 URL /article/.../load GET-request</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/article/xmlhttprequest/example/load&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过网络发送请求</span></span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 当接收到响应后，将调用此函数</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.status != <span class="number">200</span>) &#123; <span class="comment">// 分析响应的 HTTP 状态</span></span><br><span class="line">    alert(<span class="string">`Error <span class="subst">$&#123;xhr.status&#125;</span>: <span class="subst">$&#123;xhr.statusText&#125;</span>`</span>); <span class="comment">// 例如 404: Not Found</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 显示结果</span></span><br><span class="line">    alert(<span class="string">`Done, got <span class="subst">$&#123;xhr.response.length&#125;</span> bytes`</span>); <span class="comment">// response 是服务器响应</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">    alert(<span class="string">`Received <span class="subst">$&#123;event.loaded&#125;</span> of <span class="subst">$&#123;event.total&#125;</span> bytes`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">`Received <span class="subst">$&#123;event.loaded&#125;</span> bytes`</span>); <span class="comment">// 没有 Content-Length</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Request failed&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧代码中会使用 onreadystatechange 事件监听器</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 加载中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// 请求完成</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果在 open 方法中将第三个参数 async 设置为 false，那么请求就会以同步的方式进行；JavaScript 执行在 send() 处暂停，并在收到响应后恢复执行；</p>
<blockquote>
<p>Note: <code>XMLHttpRequest</code> 的另一个特点是不能撤销 <code>setRequestHeader</code>；一旦设置了 <code>header</code>，就无法撤销了。其他调用会向 <code>header</code> 中添加信息，但不会覆盖它；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带有进度指示的文件上传</span></span><br><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> onchange=<span class="string">&quot;upload(this.files[0])&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跟踪上传进度</span></span><br><span class="line">  xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Uploaded <span class="subst">$&#123;event.loaded&#125;</span> of <span class="subst">$&#123;event.total&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跟踪完成：无论成功与否</span></span><br><span class="line">  xhr.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;error &quot;</span> + <span class="built_in">this</span>.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.open(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/article/xmlhttprequest/post/upload&quot;</span>);</span><br><span class="line">  xhr.send(file);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/resume-upload">JavaScript 现代教程-可恢复的文件上传</a></li>
</ul>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket 协议提供了一种在浏览器和服务器之间建立持久连接来交换数据的方法，数据可以作为“数据包”在两个方向上传递，而不会断开连接和其他 HTTP 请求；</p>
<ul>
<li>创建：let socket = new WebSocket(“ws://javascript.info”, [“soap”, “wamp”]);<ul>
<li>第一个参数为服务器地址；</li>
<li>第二个参数可选的子协议数组；</li>
</ul>
</li>
<li>事件：<ul>
<li>open 连接已建立；</li>
<li>message 接收到数据；</li>
<li>error WebSocket 错误；</li>
<li>close 连接已关闭；</li>
</ul>
</li>
<li>请求头：<ul>
<li>Origin 客户端页面的源，允许服务器决定是否使用 WebSocket 与该网站通信；</li>
<li>Connection: Upgrade 表示客户端想要更改协议；</li>
<li>Upgrade: websocket 请求的协议是 “websocket”；</li>
<li>Sec-WebSocket-Key 浏览器随机生成的安全密钥；</li>
<li>Sec-WebSocket-Version WebSocket 协议版本；</li>
</ul>
</li>
<li>数据传输：WebSocket 通信由 frames（即数据片段）组成，可以从任何一方发送，并且有以下几种类型；<ul>
<li>text frames 包含各方发送给彼此的文本数据；</li>
<li>binary data frames 包含各方发送给彼此的二进制数据；</li>
<li>ping/pong frames 被用于检查从服务器发送的连接，浏览器会自动响应它们；</li>
<li>connection close frame 以及其他服务 frames；</li>
</ul>
</li>
<li>方法：<ul>
<li>send(data) 可以发送文本或二进制数据；</li>
<li>socket.close([code], [reason]) 可以发送一个带有数字码（numeric code）和文本形式的原因的 “connection close frame”；</li>
</ul>
</li>
<li>数字码；<ul>
<li>1000 默认，正常关闭，如果没有指明 code 时使用它；</li>
<li>1006 没有办法手动设定这个数字码，表示连接丢失（没有 close frame）；</li>
<li>1001 一方正在离开，例如服务器正在关闭，或者浏览器离开了该页面；</li>
<li>1009 消息太大，无法处理；</li>
<li>1011 服务器上发生意外错误；</li>
</ul>
</li>
<li>连接状态：可以通过带有值的 socket.readyState 属性获取；<ul>
<li>0 CONNECTING：连接还未建立；</li>
<li>1 OPEN：通信中；</li>
<li>2 CLOSING：连接关闭中；</li>
<li>3 CLOSED：连接已关闭；</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: <code>wss://</code> 是基于 TLS 的 WebSocket，类似于 HTTPS 是基于 TLS 的 HTTP，传输安全层在发送方对数据进行了加密，在接收方进行解密；因此，数据包是通过代理加密传输的，它们看不到传输的里面的内容，且会让这些数据通过；</p>
</blockquote>
<blockquote>
<p>Note: WebSocket 对象是原生支持跨源的，没有特殊的 header 或其他限制；旧的服务器无法处理 WebSocket，因此不存在兼容性问题；如果服务器同意切换为 WebSocket 协议，服务器应该返回响应码 <code>101</code>；</p>
</blockquote>
<p>在浏览器里，仅直接使用文本或二进制 frames；socket.send(body) 调用允许 body 是字符串或二进制格式，包括 Blob，ArrayBuffer 等；当我们收到数据时，文本总是以字符串形式呈现，对于二进制数据默认为 “blob”，因此二进制数据通常以 Blob 对象呈现，可以通过 socket.binaryType 属性设置；</p>
<blockquote>
<p>Note: 在网速受限的情况下，反复地调用 <code>socket.send(data)</code> 时，数据将会缓冲（储存）在内存中，并且只能在网速允许的情况下尽快将数据发送出去；<code>socket.bufferedAmount</code> 属性储存目前已缓冲的字节数，等待通过网络发送；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的服务器端 WebSocket</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    WebSocketServer,</span><br><span class="line">    WebSocket</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;ws&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123;</span><br><span class="line">    port: <span class="number">8081</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">data, isBinary</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;received: %s&#x27;</span>, data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="string">&quot;online&quot;</span>) &#123;</span><br><span class="line">            ws.send(wss.clients.size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wss.clients.forEach(<span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123;</span><br><span class="line">                  client.send(data, &#123; <span class="attr">binary</span>: isBinary &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.send(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Server-Sent-Events"><a href="#Server-Sent-Events" class="headerlink" title="Server-Sent Events"></a>Server-Sent Events</h4><p>Server-Sent Events 规范描述了一个内建的类 EventSource，它能保持与服务器的连接，并允许从中接收事件，与 WebSocket 类似，其连接是持久的；</p>
<table>
<thead>
<tr>
<th align="left">WebSocket</th>
<th align="left">EventSource</th>
</tr>
</thead>
<tbody><tr>
<td align="left">双向：客户端和服务端都能交换消息</td>
<td align="left">单向：仅服务端能发送消息</td>
</tr>
<tr>
<td align="left">二进制和文本数据</td>
<td align="left">仅文本数据</td>
</tr>
<tr>
<td align="left">WebSocket 协议</td>
<td align="left">常规 HTTP 协议</td>
</tr>
</tbody></table>
<ul>
<li>创建：let source = new EventSource(url, [credentials]);<ul>
<li>第二个参数只有一个可选项 { withCredentials: true }，它允许发送跨源凭证；</li>
</ul>
</li>
<li>事件：默认情况下 EventSource 对象生成三个事件：<ul>
<li>message 收到消息，可以用 event.data 访问；</li>
<li>open 连接已打开；</li>
<li>error 无法建立连接，例如，服务器返回 HTTP 500 状态码；</li>
</ul>
</li>
<li>属性：<ul>
<li>lastEventId 最后接收到的 id；重新连接后，浏览器在 header Last-Event-ID 中发送此 id；</li>
<li>readyState 连接状态<ul>
<li>0 EventSource.CONNECTING 表示连接中或者重连中</li>
<li>1 EventSource.OPEN 表示已连接</li>
<li>2 EventSource.CLOSED 表示连接已关闭</li>
</ul>
</li>
</ul>
</li>
<li>响应：服务器发送由 \n\n 分隔的消息，一条消息可以按任何顺序包含一个或多个字段，但是 id: 通常排在最后；<ul>
<li>data: 消息体（body），一系列多个 data 被解释为单个消息，各个部分之间由 \n 分隔；</li>
<li>id: 更新 lastEventId，重连时以 Last-Event-ID 发送此 id；</li>
<li>retry: 建议重连的延迟，以 ms 为单位。无法通过 JavaScript 进行设置；</li>
<li>event: 事件名，必须在 data: 之前；</li>
</ul>
</li>
</ul>
<p>服务器响应状态码应该为 200，header 为 Content-Type: text/event-stream，然后保持此连接并以一种特殊的格式写入消息；复杂的消息通常是用 JSON 编码后发送；</p>
<p>EventSource 支持跨源请求，就像 fetch 任何其他网络方法，可以使用任何 URL；远程服务器将会获取到 Origin header，并且必须以 Access-Control-Allow-Origin 响应来处理；</p>
<p><strong>重新连接</strong></p>
<p>如果与创建连接的服务器，连接断开则会自动重新连接，每次重新连接之间有一点小的延迟，默认为几秒钟；服务器可以使用 retry: 来设置需要的延迟响应时间（以毫秒为单位）；retry: 既可以与某些数据一起出现，也可以作为独立的消息出现；</p>
<p>如果服务器想要浏览器停止重新连接，那么它应该使用 HTTP 状态码 204 进行响应，如果浏览器想要关闭连接，则应该调用 eventSource.close()；当连接最终被关闭时，就无法“重新打开”它；如果想要再次连接，只需要创建一个新的 EventSource；</p>
<p>如果响应具有不正确的 Content-Type 或者其 HTTP 状态码不是 301，307，200 和 204，则不会进行重新连接；在这种情况下，将会发出 “error” 事件，并且浏览器不会重新连接；</p>
<p><strong>事件</strong></p>
<p>服务器可以在事件开始时使用 event: … 指定另一种类型事件，此外还可以通过 addEventListener 监听自定义事件；</p>
<h4 id="Cookie，document-cookie"><a href="#Cookie，document-cookie" class="headerlink" title="Cookie，document.cookie"></a>Cookie，document.cookie</h4><p>Cookie 是直接存储在浏览器中的一小串数据，它们是 HTTP 协议的一部分，Cookie 通常是由 Web 服务器使用响应 Set-Cookie HTTP-header 设置的，然后浏览器使用 Cookie HTTP-header 将它们自动添加到（几乎）每个对相同域的请求中；</p>
<p>document.cookie 的值由 name=value 对组成，以 ; 分隔，每一个都是独立的 cookie；对 document.cookie 的写入操作只会更新其中提到的 cookie，而不会涉及其他 cookie；</p>
<blockquote>
<p>Note: 从技术上讲，<code>cookie</code> 的名称和值可以是任何字符，为了保持有效的格式，它们应该使用内建的 <code>encodeURIComponent</code> 函数对其进行转义；</p>
</blockquote>
<blockquote>
<p>Note: 一个 cookie 最大为 4KB，每个域的 <code>cookie</code> 总数不得超过 <code>20+</code> 左右，具体限制取决于浏览器；</p>
</blockquote>
<p>cookie 的其他选项：</p>
<ul>
<li>path url 路径前缀，该路径下的页面可以访问该 cookie，必须是绝对路径，默认为当前路径；</li>
<li>domain 可访问 cookie 的域，无法使 cookie 可以被从另一个二级域访问，但其子域名可以访问；</li>
<li>expire cookie 的到期日期，那时浏览器会自动删除它，日期必须完全采用 GMT 时区的这种格式；如果将 expires 设置为过去的时间，则 cookie 会被删除；</li>
<li>max-age expires 的替代选项，具指明 cookie 的过期时间距离当前时间的秒数，如果为 0 或负数，则 cookie 会被删除；</li>
<li>secure Cookie 应只能被通过 HTTPS 传输，默认情况下，cookie 是基于域的，不区分协议；</li>
<li>samesite 用于防止 XSRF（跨网站请求伪造）攻击，samesite=strict 或 samesite 采用严格模式，samesite=lax 宽松模式；</li>
<li>httpOnly 服务器端可以设置该选项禁止任何 JavaScript 访问 cookie；那么 document.cookie 看不到 cookie；</li>
</ul>
<p>默认情况下，如果一个 cookie 没有设置 expire、max-age 这两个参数中的任何一个，那么在关闭浏览器之后，它就会消失，此类 cookie 被称为 “session cookie”</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回具有给定 name 的 cookie，</span></span><br><span class="line"><span class="comment">// 如果没找到，则返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> matches = <span class="built_in">document</span>.cookie.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(</span><br><span class="line">    <span class="string">&quot;(?:^|; )&quot;</span> + name.replace(<span class="regexp">/([\.$?*|&#123;&#125;\(\)\[\]\\\/\+^])/g</span>, <span class="string">&#x27;\\$1&#x27;</span>) + <span class="string">&quot;=([^;]*)&quot;</span></span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> matches ? <span class="built_in">decodeURIComponent</span>(matches[<span class="number">1</span>]) : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  options = &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果需要，可以在这里添加其他默认值</span></span><br><span class="line">    ...options</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    options.expires = options.expires.toUTCString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updatedCookie = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&quot;=&quot;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> optionKey <span class="keyword">in</span> options) &#123;</span><br><span class="line">    updatedCookie += <span class="string">&quot;; &quot;</span> + optionKey;</span><br><span class="line">    <span class="keyword">let</span> optionValue = options[optionKey];</span><br><span class="line">    <span class="keyword">if</span> (optionValue !== <span class="literal">true</span>) &#123;</span><br><span class="line">      updatedCookie += <span class="string">&quot;=&quot;</span> + optionValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.cookie = updatedCookie;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  setCookie(name, <span class="string">&quot;&quot;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;max-age&#x27;</span>: -<span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用范例：</span></span><br><span class="line">setCookie(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, &#123;<span class="attr">secure</span>: <span class="literal">true</span>, <span class="string">&#x27;max-age&#x27;</span>: <span class="number">3600</span>&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 如果一个脚本设置了一个 <code>cookie</code>，那么无论脚本来自何处这个 <code>cookie</code> 都属于当前网页的域；</p>
</blockquote>
<blockquote>
<p>Note: 如果 <code>cookie</code> 是由用户所访问的页面的域以外的域放置的，则称其为第三方 <code>cookie</code>，通常用于跟踪和广告服务；</p>
</blockquote>
<h4 id="LocalStorage，sessionStorage"><a href="#LocalStorage，sessionStorage" class="headerlink" title="LocalStorage，sessionStorage"></a>LocalStorage，sessionStorage</h4><p>Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器上保存键/值对；</p>
<p>两个存储对象都提供相同的方法和属性：</p>
<ul>
<li>setItem(key, value) 存储键/值对；</li>
<li>getItem(key) 按照键获取值；</li>
<li>removeItem(key) 删除键及其对应的值；</li>
<li>clear() 删除所有数据；</li>
<li>key(index) 获取该索引下的键名；</li>
<li>length 存储的内容的长度，只读；</li>
</ul>
<p>localStorage 最主要的特点是：</p>
<ul>
<li>在同源的所有标签页和窗口之间共享数据；</li>
<li>数据不会过期，它在浏览器重启甚至系统重启后仍然存在；</li>
<li>可以像使用一个普通对象那样，读取/设置键，且存储对象是不可迭代的；</li>
<li>键和值都必须是字符串；如果是任何其他类型，会被自动转换为字符串；</li>
</ul>
<p>sessionStorage 特点：</p>
<ul>
<li>sessionStorage 的数据只存在于当前浏览器标签页，具有相同页面的另一个标签页中将会有不同的存储；但在同一标签页下的同源 iframe 之间是共享的；数据在页面刷- 新后仍然保留，但在关闭/重新打开浏览器标签页后不会被保留</li>
</ul>
<blockquote>
<p>Note: 存储对象是不可迭代的；可以通过 Object.keys() 或者 for..in （需要 hasOwnProperty 检查）遍历；</p>
</blockquote>
<p>当 localStorage 或 sessionStorage 中的数据更新后，storage 事件就会触发，但以类对象方式访问时，不会触发该事件；</p>
<ul>
<li>key 发生更改的数据的 key（如果调用的是 .clear() 方法，则为 null）；</li>
<li>oldValue 旧值（如果是新增数据，则为 null）；</li>
<li>newValue 新值（如果是删除数据，则为 null）；</li>
<li>url 发生数据更新的文档的 url；</li>
<li>storageArea 发生数据更新的 localStorage 或 sessionStorage 对象；</li>
</ul>
<p>该事件会在所有可访问到存储对象的 window 对象上触发，导致当前数据改变的 window 对象除外；如果两个窗口都在监听 window.onstorage 事件，那么每个窗口都会对另一个窗口中发生的更新作出反应；</p>
<h4 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h4><p>IndexedDB 是一个浏览器内建的数据库：</p>
<ul>
<li>通过支持多种类型的键，来存储几乎可以是任何类型的值；</li>
<li>支撑事务的可靠性；</li>
<li>支持键范围查询、索引；</li>
<li>和 localStorage 相比，它可以存储更大的数据量；</li>
</ul>
<p>对于传统的客户端-服务器应用，这些功能通常是没有必要的；IndexedDB 适用于离线应用，可与 ServiceWorkers 和其他技术相结合使用；</p>
<p>创建连接：let openRequest = indexedDB.open(name, version);</p>
<ul>
<li>name 字符串，即数据库名称；</li>
<li>version 一个正整数版本，默认为 1；</li>
</ul>
<p>其他用法：</p>
<ul>
<li><p>获取一个 promise 包装器，比如 idb；</p>
</li>
<li><p>打开一个数据库：idb.openDb(name, version, onupgradeneeded)</p>
<ul>
<li>在 onupgradeneeded 处理程序中创建对象存储和索引，或者根据需要执行版本更新；</li>
</ul>
</li>
<li><p>对于请求：</p>
<ul>
<li>创建事务 db.transaction(‘books’)（如果需要的话，设置 readwrite）；</li>
<li>获取对象存储 transaction.objectStore(‘books’)；</li>
</ul>
</li>
<li><p>按键搜索，可以直接调用对象库上的方法，要按对象字段搜索，需要创建索引；</p>
</li>
<li><p>如果内存中容纳不下数据，可以使用光标；</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.javascript.info/indexeddb">JavaScript 现代教程-IndexedDB</a></p>
</li>
</ul>
<h4 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h4><p>CSS 动画可以在不借助 Javascript 的情况下做出一些简单的动画效果；</p>
<p>CSS 提供了四个属性来描述一个过渡：</p>
<ul>
<li>transition-property 列举要设置动画的所有属性，all 表示应用在所有属性上，但不是所有的 CSS 属性都可以使用过渡动画；</li>
<li>transition-duration 允许我们指定动画持续的时间，单位为s 或者 ms；</li>
<li>transition-timing-function 时间函数描述了动画进程在时间上的分布，如果没有指定时间函数，那么将使用 ease 作为默认值；</li>
<li>transition-delay 允许设定动画开始前的延迟时间；还可以提供一个负值，使动画从整个过渡的中间时刻开始渲染；</li>
</ul>
<p>也可以在 transition 中以 property duration timing-function delay 的顺序一次性定义它们，并且可以同时为多个属性设置过渡动画；</p>
<p><strong>贝塞尔曲线</strong></p>
<p>时间函数可以用贝塞尔曲线描述，通过设置四个满足以下条件的控制点：</p>
<ul>
<li>第一个应为：(0,0)。</li>
<li>最后一个应为：(1,1)。</li>
<li>对于中间值，x 必须位于 0..1 之间，y 可以为任意值</li>
</ul>
<p>CSS 中设置一贝塞尔曲线的语法为：cubic-bezier(x2, y2, x3, y3)，只需要设置第二个和第三个值，因为第一个点固定为 (0,0)，第四个点固定为 (1,1)；</p>
<p>CSS 提供几条内建的曲线：</p>
<ul>
<li>linear cubic-bezier(0, 0, 1, 1)</li>
<li>ease cubic-bezier(0.25, 0.1, 0.25, 1.0)</li>
<li>ease-in cubic-bezier(0.42, 0, 1.0, 1.0)</li>
<li>ease-out cubic-bezier(0, 0, 0.58, 1.0)</li>
<li>ease-in-out cubic-bezier(0.42, 0, 0.58, 1.0)</li>
</ul>
<p>贝塞尔曲线可以使动画超出其原本的范围；曲线上的控制点的 y 值可以使任意的：不管是负值还是一个很大的值；</p>
<p><strong>阶跃函数</strong></p>
<p>时间函数 steps(number of steps[, start/end]) 允许你让动画分段进行，number of steps 表示需要拆分为多少段</p>
<p>start 表示在动画开始时，我们需要立即开始第一段的动画，另一个值 end 表示：改变不应该在最开始的时候发生，而是发生在每一段的最后时刻；</p>
<p>CSS 动画完成后，会触发 transitionend 事件，该事件对象有几个特定的属性：</p>
<ul>
<li>event.propertyName ：当前完成动画的属性，这在同时为多个属性加上动画时会很有用；</li>
<li>event.elapsedTime ：动画完成的时间（按秒计算），不包括 transition-delay；</li>
</ul>
<p>此外还可以通过 CSS 提供的 @keyframes 规则整合多个简单的动画；</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://cubic-bezier.com/">贝塞尔曲线在线制作工具</a></li>
</ul>
<h4 id="JavaScript-动画"><a href="#JavaScript-动画" class="headerlink" title="JavaScript 动画"></a>JavaScript 动画</h4><p>标准动画时序提供了 requestAnimationFrame 函数；当页面在后台时，根本没有重绘，因此回调将不会运行：动画将被暂停并且不会消耗资源；</p>
<ul>
<li>创建方式： let requestId = requestAnimationFrame(callback)；</li>
<li>取消回调：cancelAnimationFrame(requestId)；</li>
</ul>
<p>这是一个设置大多数动画的 helper 函数 animate：</p>
<ul>
<li>duration 动画运行的总毫秒数；</li>
<li>timing 计算动画进度的函数；获取从 0 到 1 的小数时间，返回动画进度，通常也是从 0 到 1；</li>
<li>draw 绘制动画的函数；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">&#123;timing, draw, duration&#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = performance.now();</span><br><span class="line"></span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// timeFraction 从 0 增加到 1</span></span><br><span class="line">    <span class="keyword">let</span> timeFraction = (time - start) / duration;</span><br><span class="line">    <span class="keyword">if</span> (timeFraction &gt; <span class="number">1</span>) timeFraction = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前动画状态</span></span><br><span class="line">    <span class="keyword">let</span> progress = timing(timeFraction);</span><br><span class="line"></span><br><span class="line">    draw(progress); <span class="comment">// 绘制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeFraction &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      requestAnimationFrame(animate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/js-animation">JavaScript 现代教程-JS 动画</a></li>
</ul>
<h4 id="Custom-elements"><a href="#Custom-elements" class="headerlink" title="Custom elements"></a>Custom elements</h4><p>Custom elements 有两种：自主自定义标签和自定义内建元素；Custom element 在各浏览器中的兼容性已经非常好了，Edge 支持地相对较差，可以使用 <a target="_blank" rel="noopener" href="https://github.com/webcomponents/webcomponentsjs">polyfill</a>；</p>
<p><strong>Autonomous custom elements</strong> </p>
<p>自主自定义标签 “全新的” 元素, 继承自 HTMLElement 抽象类；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// 元素在这里创建</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在元素被添加到文档之后，浏览器会调用这个方法</span></span><br><span class="line">    <span class="comment">//（如果一个元素被反复添加到文档／移除文档，那么这个方法会被多次调用）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">disconnectedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在元素从文档移除的时候，浏览器会调用这个方法</span></span><br><span class="line">    <span class="comment">// （如果一个元素被反复添加到文档／移除文档，那么这个方法会被多次调用）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> <span class="title">observedAttributes</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="comment">/* 属性数组，这些属性的变化会被监视 */</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">attributeChangedCallback</span>(<span class="params">name, oldValue, newValue</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 当上面数组中的属性发生变化的时候，这个方法会被调用</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">adoptedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在元素被移动到新的文档的时候，这个方法会被调用</span></span><br><span class="line">    <span class="comment">// （document.adoptNode 会用到, 非常少见）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 还可以添加更多的元素方法和属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让浏览器知道我们新定义的类是为 &lt;my-element&gt; 服务的</span></span><br><span class="line">customElements.define(<span class="string">&quot;my-element&quot;</span>, MyElement);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 为了确保 <code>custom element</code> 和内建 HTML 元素之间不会发生命名冲突，<code>Custom element</code> 名称必须包括一个短横线 <code>-</code>；</p>
</blockquote>
<p>如果浏览器在 customElements.define 之前的任何地方见到了 custom element 元素，并不会报错，但会把这个元素当作未知元素，就像任何非标准标签一样；:not(:defined) CSS 选择器可以对这样未定义的元素加上样式；</p>
<p>customElements.get(name) 返回指定 custom element name 的类；<br>customElements.whenDefined(name) 返回一个 promise，将会在这个具有给定 name 的 custom element 变为已定义状态的时候 resolve（不带值）；</p>
<p>在 HTML 解析器构建 DOM 的时候，会按照先后顺序处理元素，先处理父级元素再处理子元素；</p>
<p><strong>Customized built-in elements</strong></p>
<p>自定义内建元素继承内建的 HTML 元素，比如自定义 HTMLButtonElement 等；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 类继承自 HTMLButtonElement</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 这个按钮在被点击的时候说 &quot;hello&quot;</span></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">HelloButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">super</span>();</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> alert(<span class="string">&quot;Hello!&quot;</span>));</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 给 customElements.define 提供定义标签的第三个参数</span></span></span><br><span class="line"><span class="javascript">  customElements.define(<span class="string">&#x27;hello-button&#x27;</span>, HelloButton, &#123;<span class="attr">extends</span>: <span class="string">&#x27;button&#x27;</span>&#125;);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 插入一个普通的 &lt;button&gt; 标签，但添加 is=&quot;hello-button&quot; 到这个元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">&quot;hello-button&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">&quot;hello-button&quot;</span> <span class="attr">disabled</span>&gt;</span>Disabled<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="影子-DOM"><a href="#影子-DOM" class="headerlink" title="影子 DOM"></a>影子 DOM</h4><p>浏览器在内部使用 DOM/CSS 来绘制它们，这个 DOM 结构一般来说对我们是隐藏的，但可以在开发者工具里面看见它，在 #shadow-root 下看到的就是被称为「shadow DOM」的东西；</p>
<p>一个 DOM 元素可以有以下两类 DOM 子树：</p>
<ul>
<li>Light tree（光明树）一个常规 DOM 子树，由 HTML 子元素组成；</li>
<li>Shadow tree（影子树）一个隐藏的 DOM 子树，不在 HTML 中反映，无法被察觉；</li>
</ul>
<p>如果一个元素同时有以上两种子树，那么浏览器只渲染 shadow tree；影子树可以在自定义元素中被使用，其作用是隐藏组件内部结构和添加只在组件内有效的样式；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">customElements.define(<span class="string">&#x27;show-hello&#x27;</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> shadow = <span class="built_in">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;);</span></span><br><span class="line"><span class="handlebars"><span class="xml">    shadow.innerHTML = `<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">      Hello, $&#123;<span class="built_in">this</span>.getAttribute(<span class="string">&#x27;name&#x27;</span>)&#125;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span>`;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">show-hello</span> <span class="attr">name</span>=<span class="string">&quot;John&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">show-hello</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>调用 elem.attachShadow({mode: …}) 可以创建一个 shadow tree：</p>
<ul>
<li>mode 选项可以设定封装层级，他必须是以下两个值之一<ul>
<li>open：shadow root 可以通过 elem.shadowRoot 访问；</li>
<li>closed：elem.shadowRoot 永远是 null；</li>
</ul>
</li>
</ul>
<p>浏览器原生的 shadow tree，是封闭的，没有任何方法可以访问它们；</p>
<p>Shadow DOM 元素对于 light DOM 中的 querySelector 不可见；实际上，Shadow DOM 中的元素可能与 light DOM 中某些元素的 id 冲突，这些元素必须在 shadow tree 中独一无二；Shadow DOM 有自己的样式，外部样式规则在 shadow DOM 中不产生作用；</p>
<h4 id="模板元素"><a href="#模板元素" class="headerlink" title="模板元素"></a>模板元素</h4><p>内建的 <code>&lt;template&gt;</code> 元素用来存储 HTML 模板。浏览器将忽略它的内容，仅检查语法的有效性，但是我们可以在 JavaScript 中访问和使用它来创建其他元素；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;temp&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, world.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold; &#125;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&quot;Hello&quot;</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// Clone the template content to reuse it multiple times</span></span></span><br><span class="line"><span class="javascript">  elem.append(temp.content.cloneNode(<span class="literal">true</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.append(elem);</span></span><br><span class="line"><span class="javascript">  <span class="comment">// Now the script from &lt;template&gt; runs</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器认为 <code>&lt;template&gt;</code> 的内容“不在文档中”：样式不会被应用，脚本也不会被执行；当内容插入文档时，该内容将变为活动状态（应用样式，运行脚本等）；</p>
<p>模板的 content 属性可看作 DocumentFragment，将它插入时，会被插入的则是其子节点；</p>
<h4 id="Shadow-DOM-插槽，组成"><a href="#Shadow-DOM-插槽，组成" class="headerlink" title="Shadow DOM 插槽，组成"></a>Shadow DOM 插槽，组成</h4><p>为了渲染 shadow DOM 中的每一个 <code>&lt;slot name=&quot;...&quot;&gt;</code> 元素，浏览器在 light DOM 中寻找相同名字的 slot=”…”，这些元素在插槽内被渲染；最后得到一个扁平化（flattened）DOM；</p>
<p>扁平化 DOM 是通过插入插槽从 shadow DOM 派生出来的，浏览器渲染它并且用于样式继承、事件传播；但是 JavaScript 在扁平前仍按原样看到文档；slot=”…” 属性仅仅对 shadow host 的直接子代有效，对于嵌套元素它将被忽略；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">customElements.define(<span class="string">&#x27;user-card&#x27;</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;);</span><br><span class="line">    <span class="built_in">this</span>.shadowRoot.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div&gt;Name:</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;Birthday:</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;user-card&gt;</span><br><span class="line">  &lt;span slot=<span class="string">&quot;username&quot;</span>&gt;John Smith&lt;/span&gt;</span><br><span class="line">  &lt;span slot=<span class="string">&quot;birthday&quot;</span>&gt;<span class="number">01</span><span class="number">.01</span><span class="number">.2001</span>&lt;/span&gt;</span><br><span class="line">&lt;/user-card&gt;</span><br></pre></td></tr></table></figure>

<p>shadow DOM 中第一个没有名字的 <code>&lt;slot&gt;</code> 是一个默认插槽，它从 light DOM 中获取没有放置在其他位置的所有节点；</p>
<p>如果添加/删除了插槽元素，浏览器将监视插槽并更新渲染，触发 slotchange 事件；</p>
<h4 id="Shadow-DOM-样式"><a href="#Shadow-DOM-样式" class="headerlink" title="Shadow DOM 样式"></a>Shadow DOM 样式</h4><p>:host 选择器允许选择 shadow 宿主（包含 shadow 树的元素）；:host(selector) 还可以添加选择器；</p>
<p>shadow 宿主驻留在 light DOM 中，因此它受到文档 CSS 规则的影响；如果在局部的 :host 和文档中都给一个属性设置样式，那么文档样式优先；</p>
<p>使用 ::slotted(selector) 伪类可以给插槽添加样式，但 ::slotted 选择器不能用于任何插槽中更深层的内容，且只能在 CSS 中使用，不能在 querySelector 中使用；</p>
<p>自定义 CSS 属性存在于所有层次，包括 light DOM 和 shadow DOM；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 在外部文档中声明此属性 */</span></span></span><br><span class="line">  user-card &#123;</span><br><span class="line"><span class="css">    --user-card-field-<span class="attribute">color</span>: green;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;tmpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .field &#123;</span><br><span class="line"><span class="css">      <span class="comment">/* 如果 --user-card-field-color 没有被声明过，则取值为 black */</span></span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: <span class="built_in">var</span>(--user-card-field-color, black);</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span>Birthday: <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">customElements.define(<span class="string">&#x27;user-card&#x27;</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.shadowRoot.append(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;tmpl&#x27;</span>).content.cloneNode(<span class="literal">true</span>));</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user-card</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;username&quot;</span>&gt;</span>John Smith<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span>01.01.2001<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Shadow-DOM-和事件"><a href="#Shadow-DOM-和事件" class="headerlink" title="Shadow DOM 和事件"></a>Shadow DOM 和事件</h4><p>当事件在组件外部捕获时，shadow DOM 中发生的事件将会以 host 元素作为目标，这就是事件重定向；但如果事件发生在 slotted 元素上，实际存在于 light DOM 上，则不会发生重定向；</p>
<p>事件仅仅是在它们的 composed 标志设置为 true 的时候才能通过 shadow DOM 边界；这些事件仅能在同一 DOM 中的元素上捕获：mouseenter，mouseleave（也不冒泡），load，unload，abort，error，select，slotchange；</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>在 JavaScript 中，正则表达式通过内建的“RegExp”类的对象来实现，并与字符串集成；</p>
<p>正则表达式包含模式和可选的修饰符，使用 RegExp 对象或 // 字面量创建；new RegExp 允许从字符串中动态地构造模式；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;pattern&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line">regexp = <span class="regexp">/pattern/</span>; <span class="comment">// 没有修饰符</span></span><br><span class="line">regexp = <span class="regexp">/pattern/gmi</span>;</span><br></pre></td></tr></table></figure>

<p>字符串 str.search 方法，可以搜索一个正则表达式，并返回第一个索引；</p>
<p>在 JavaScript 中，有 6 个修饰符：</p>
<ul>
<li>i 使用此修饰符后，搜索时不区分大小写；</li>
<li>g 使用此修饰符后，搜索时会查找所有的匹配项，而不只是第一个；</li>
<li>m 多行模式；</li>
<li>s 启用 dotall 模式，允许点 . 匹配换行符 \n；</li>
<li>u 开启完整的 unicode 支持。该修饰符能够修正对于代理对的处理；</li>
<li>y 粘滞模式；</li>
</ul>
<p><strong>字符类</strong></p>
<p>字符类（Character classes） 是一个特殊的符号，匹配特定集中的任何符号；</p>
<ul>
<li>\d 表示数字 digit：从 0 到 9 的字符；</li>
<li>\s 空格符号 space：包括空格，制表符 \t，换行符 \n 和其他少数稀有字符，例如 \v，\f 和 \r；</li>
<li>\w 单字字符 word：拉丁字母或数字或下划线 _；</li>
<li>\D 非数字：除 \d 以外的任何字符；</li>
<li>\S 非空格符号：除 \s 以外的任何字符；</li>
<li>\W 非单字字符：除 \w 以外的任何字符；</li>
<li>. 点是一种特殊字符类，它与 “除换行符之外的任何字符” 匹配，带 s 标志时，匹配包括换行符在内的任何字符；</li>
<li>\p{Letter} 或 \p{L} 表示任何语言中的一个字母，需要带 u 标志；</li>
</ul>
<p><strong>Unicode</strong></p>
<p>Unicode 全称 Unicode Translation Format，又叫做统一码、万国码、单一码，Unicode 的实现方式（也就是编码方式）有很多种，常见的是 UTF-8、UTF-16、UTF-32 和 USC-2；UTF-8 是使用最广泛的 Unicode 编码方式，它是一种可变长的编码方式，可以是 1—4 个字节不等，它可以完全兼容 ASCII 码的 128 个字符；</p>
<p>默认情况下，正则表达式同样把一个 4 个字节的“长字符”当成一对 2 个字节长的字符；</p>
<p>主要的字符类别和它们对应的子类别：</p>
<ul>
<li>字母（Letter） L:<ul>
<li>小写（lowercase） Ll</li>
<li>修饰（modifier） Lm</li>
<li>首字母大写（titlecase） Lt</li>
<li>大写（uppercase） Lu</li>
<li>其它（other） Lo</li>
</ul>
</li>
<li>数字（Number） N:<ul>
<li>十进制数字（decimal digit） Nd</li>
<li>十六进制 </li>
<li>字母数字（letter number） Nl</li>
<li>其它（other） No</li>
</ul>
</li>
<li>标点符号（Punctuation） P:<ul>
<li>链接符（connector） Pc</li>
<li>横杠（dash） Pd</li>
<li>起始引用号（initial quote） Pi</li>
<li>结束引用号（final quote） Pf</li>
<li>开（open） Ps</li>
<li>闭（close） Pe</li>
<li>其它（other） Po</li>
</ul>
</li>
<li>标记（Mark） M (accents etc):<ul>
<li>间隔合并（spacing combining） Mc</li>
<li>封闭（enclosing） Me</li>
<li>非间隔（non-spacing） Mn</li>
</ul>
</li>
<li>符号（Symbol） S:<ul>
<li>货币（currency） Currency_Symbol/Sc</li>
<li>修饰（modifier） Sk</li>
<li>数学（math） Sm</li>
<li>其它（other） So</li>
</ul>
</li>
<li>分隔符（Separator） Z:<ul>
<li>行（line） Zl</li>
<li>段落（paragraph） Zp</li>
<li>空格（space） Zs</li>
</ul>
</li>
<li>其它（Other） C:<ul>
<li>控制符（control） Cc</li>
<li>格式（format） Cf</li>
<li>未分配（not assigned） Cn</li>
<li>私有（private use） Co</li>
<li>代理伪字符（surrogate） Cs</li>
</ul>
</li>
<li>书写系统：Script/sc<ul>
<li>中文 Han</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配标点</span></span><br><span class="line"><span class="string">&quot;。&quot;</span>.search(<span class="regexp">/\p&#123;P&#125;/u</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="string">&quot;number: xAF&quot;</span>.search(<span class="regexp">/x\p&#123;Hex_Digit&#125;\p&#123;Hex_Digit&#125;/u</span>); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;你好&quot;</span>.search(<span class="regexp">/\p&#123;sc=Han&#125;/u</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: Edge 和 Firefox 尚未实现 Unicode 属性 <code>p&#123;…&#125;</code>，可以使用库 <a target="_blank" rel="noopener" href="http://xregexp.com/">XRegExp</a>；</p>
</blockquote>
<p><strong>锚点</strong></p>
<p>插入符号 ^ 匹配文本开头，而美元符号 $ － 则匹配文本末尾，统称为“锚点”；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> goodInput = <span class="string">&quot;12:34&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> badInput = <span class="string">&quot;12:345&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/^\d\d:\d\d$/</span>;</span><br><span class="line">alert( regexp.test(goodInput) ); <span class="comment">// true</span></span><br><span class="line">alert( regexp.test(badInput) ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>对于空字符串 “”，正则表达式引擎将会首先匹配模式 ^（输入开始），匹配成功之后，会紧跟着检查模式 $，也匹配成功，所以空字符串是匹配 ^$ 的；</p>
<p><strong>多行模式</strong></p>
<p>通过 flag /…/m 可以开启多行模式；默认情况下，锚符 ^ 仅仅匹配文本的开头，在多行模式下，它匹配行的开头；锚符 $ 也可在多行模式下匹配行的结尾；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`1st place: Winnie</span></span><br><span class="line"><span class="string">2nd place: Piglet</span></span><br><span class="line"><span class="string">33rd place: Eeyore`</span>;</span><br><span class="line"></span><br><span class="line">alert( str.match(<span class="regexp">/^\d+/gm</span>) ); <span class="comment">// 1, 2, 33</span></span><br><span class="line">alert( str.match(<span class="regexp">/\w+\n/gim</span>) ); <span class="comment">// Winnie\n,Piglet\n</span></span><br></pre></td></tr></table></figure>

<p><strong>词边界</strong></p>
<p>当正则表达式引擎遇到 \b 时，它会检查字符串中的位置是否是词边界：</p>
<ul>
<li>在字符串开头，如果第一个字符是单词字符 \w；</li>
<li>在字符串中的两个字符之间，其中一个是单词字符 \w，另一个不是；</li>
<li>在字符串末尾，如果最后一个字符是单词字符 \w；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello, Java!&quot;</span>.match(<span class="regexp">/\b\w+\b/g</span>); <span class="comment">// [&#x27;Hello&#x27;, &#x27;Java&#x27;]</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">&quot;1 23 456 78&quot;</span>.match(<span class="regexp">/\b\d\d\b/g</span>) ); <span class="comment">// 23,78</span></span><br><span class="line">alert( <span class="string">&quot;12,34,56&quot;</span>.match(<span class="regexp">/\b\d\d\b/g</span>) ); <span class="comment">// 12,34,56</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: <code>\b</code> 既可以用于单词，也可以用于数字，词边界 <code>\b</code> 不适用于非拉丁字母；</p>
</blockquote>
<p><strong>转义字符</strong></p>
<p><code>[ \ ^ $ . | ? * + ( )</code>，这些字符在正则表达式中有特殊的含义；如果要把特殊字符作为常规字符来使用，只需要在它前面加个反斜杠，这个过程叫转义；</p>
<p>斜杠符号 ‘/‘ 并不是一个特殊符号，但是它被用于在 Javascript 中开启和关闭正则匹配：/…pattern…/，所以我们也应该转义它；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="string">&quot;Chapter 5.1&quot;</span>.match(<span class="regexp">/\d\.\d/</span>) ); <span class="comment">// 5.1</span></span><br><span class="line">alert( <span class="string">&quot;1\\2&quot;</span>.match(<span class="regexp">/\\/</span>) ); <span class="comment">// &#x27;\&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 斜杠 /</span></span><br><span class="line">alert( <span class="string">&quot;/&quot;</span>.match(<span class="regexp">/\//</span>) ); <span class="comment">// &#x27;/&#x27;</span></span><br><span class="line">alert( <span class="string">&quot;/&quot;</span>.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;/&quot;</span>)) ); <span class="comment">// &#x27;/&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在字符串中的反斜杠表示转义或者类似 \n 这种只能在字符串中使用的特殊字符；其它有些并没有特殊的含义，就像 \d 或者 \z，碰到这种情况的话会把反斜杠移除；所以传递一个字符串（参数）给 new RegExp 时，需要双反斜杠 \，因为字符串引号会消费其中的一个；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;\d\.\d&quot;</span>); <span class="comment">// d.d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regStr = <span class="string">&quot;\\d\\.\\d&quot;</span>;</span><br><span class="line">alert(regStr); <span class="comment">// \d\.\d (correct now)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr);</span><br><span class="line"></span><br><span class="line">alert( <span class="string">&quot;Chapter 5.1&quot;</span>.match(regexp) ); <span class="comment">// 5.1</span></span><br></pre></td></tr></table></figure>

<p><strong>集合和范围</strong></p>
<p>在方括号 […] 中的几个字符或者字符类意味着“搜索给定的字符中的任意一个”；集合可以在正则表达式中和其它常规字符一起使用，方括号也可以包含字符范围；[a-z] 会匹配从 a 到 z 范围内的字母；</p>
<p>字符类是某些字符集的简写：</p>
<ul>
<li>\d 和 [0-9] 相同；</li>
<li>\w 和 [a-zA-Z0-9_] 相同；</li>
<li>\s 和 [\t\n\v\f\r ] 外加少量罕见的 unicode 空格字符相同；</li>
</ul>
<p>除了普通的范围匹配，还有类似 [^…] 的“排除”范围匹配；通过在匹配查询的开头添加插入符号 ^ 来表示，它会匹配所有除了给定的字符之外的任意字符；且在方括号中的特殊字符不需要转义；</p>
<p>破折号 ‘-‘ 在方括号中有特殊含义，但这个含义只有当它位于其它字符之间而不是开头或结尾时才会发生作用，所以我们并不需要转义它；需要匹配 <code>^</code> 时，建议转义；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并不需要转义</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/[-().^+]/g</span>;</span><br><span class="line">alert( <span class="string">&quot;1 + 2 - 3&quot;</span>.match(reg) ); <span class="comment">// 匹配 +，-</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">&#x27;𝒳&#x27;</span>.match(<span class="regexp">/[𝒳𝒴]/u</span>) ); <span class="comment">// 𝒳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d\d[-:]\d\d/g</span>;</span><br><span class="line">alert( <span class="string">&quot;Breakfast at 09:00. Dinner at 21-30&quot;</span>.match(reg) ); <span class="comment">// 09:00, 21-30</span></span><br></pre></td></tr></table></figure>

<p>如果集合中有代理对（surrogate pairs），则需要标志 u 以使其正常工作；</p>
<p><strong>量词</strong></p>
<p>最明显的量词便是一对引号间的数字：{n, m}；在一个字符（或一个字符类等等）后跟着一个量词，用来指出我们具体需要的数量；</p>
<ul>
<li>{n} 表示确切的位数；</li>
<li>{n, m} 表示 n 到 m  之间的位数；</li>
<li>{n,} 省略上限，表示查找位数大于或等于 n 的位数；</li>
</ul>
<p>大多数常用的量词都可以有缩写：</p>
<ul>
<li><code>+</code> 代表“一个或多个”，相当于 {1,}；</li>
<li>? 代表“零个或一个”，相当于 {0,1}；使得符号变得可选；</li>
<li><ul>
<li>代表着“零个或多个”，相当于 {0,}，表示这个字符可以多次出现或不出现；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Should I write color or colour?&quot;</span>;</span><br><span class="line">alert( str.match(<span class="regexp">/colou?r/g</span>) ); <span class="comment">// color, colour</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">&quot;100 10 1&quot;</span>.match(<span class="regexp">/\d0+/g</span>) ); <span class="comment">// 100, 10</span></span><br><span class="line">alert( <span class="string">&quot;100 10 1&quot;</span>.match(<span class="regexp">/\d0*/g</span>) ); <span class="comment">// 100, 10, 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则表达式“浮点数”（带浮点的数字）：\d+\.\d+</span></span><br><span class="line"><span class="comment">// 正则表达式“打开没有属性的 HTML 标记”，比如 &lt;span&gt; 或 &lt;p&gt;：/&lt;[a-z]+&gt;/i</span></span><br><span class="line"><span class="comment">// 正则表达式“打开没有属性的HTML标记”（改进版）：/&lt;[a-z][a-z0-9]*&gt;/i</span></span><br><span class="line"><span class="comment">// 正则表达式“打开没有属性的HTML标记”：/&lt;\/?[a-z][a-z0-9]*&gt;/i</span></span><br></pre></td></tr></table></figure>

<p><strong>贪婪量词和惰性量词</strong></p>
<p>在贪婪模式下（默认情况下），量词都会尽可能地重复多次；正则表达式引擎尝试用 .+ 去获取尽可能多的字符，然后再一步步地筛选它们</p>
<p>通过在量词之后添加一个问号 ‘?’ 来启用懒惰模式，所以匹配模式变为 *? 或 +?，甚至将 ‘?’ 变为 ??；懒惰模式只能够通过带 ? 的量词启用，其它的量词依旧保持贪婪模式；</p>
<p>有时需要运用集合和反向集合来解决懒惰模式下的一些问题；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;...&lt;a href=&quot;link1&quot; class=&quot;wrong&quot;&gt;... &lt;p style=&quot;&quot; class=&quot;doc&quot;&gt;...&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;...&lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;... &lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;...&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;a href=&quot;[^&quot;]*&quot; class=&quot;doc&quot;&gt;/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Works!</span></span><br><span class="line">alert( str1.match(reg) ); <span class="comment">// 没有匹配项，是正确的</span></span><br><span class="line">alert( str2.match(reg) ); <span class="comment">// &lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;, &lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配注释</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;!--[\s\S]*?--&gt;/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`... &lt;!-- My -- comment</span></span><br><span class="line"><span class="string"> test --&gt; ..  &lt;!----&gt; ..</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">alert( str.match(reg) ); <span class="comment">// &#x27;&lt;!-- My -- comment \n test --&gt;&#x27;, &#x27;&lt;!----&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配标签 </span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;[^&lt;&gt;]+&gt;/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&lt;&gt; &lt;a href=&quot;/&quot;&gt; &lt;input type=&quot;radio&quot; checked&gt; &lt;b&gt;&#x27;</span>;</span><br><span class="line">alert( str.match(reg) ); <span class="comment">// &#x27;&lt;a href=&quot;/&quot;&gt;&#x27;, &#x27;&lt;input type=&quot;radio&quot; checked&gt;&#x27;, &#x27;&lt;b&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://zh.javascript.info/regexp-greedy-and-lazy">JavaScript 现代教程-贪婪量词和惰性量词</a></li>
</ul>
<p><strong>捕获组</strong></p>
<p>模式的一部分可以用括号括起来 (…)，这称为“捕获组（capturing group）”；这允许将匹配的一部分作为结果数组中的单独项，如果我们将量词放在括号后，则它将括号视为一个整体；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配域名</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/([\w-]+\.)+\w+/g</span>;</span><br><span class="line">alert( <span class="string">&quot;site.com my.site.com&quot;</span>.match(regexp) ); <span class="comment">// site.com,my.site.com</span></span><br></pre></td></tr></table></figure>

<p>方法 str.match(regexp)，如果 regexp 没有 g 标志，将查找第一个匹配并将它作为一个数组返回；</p>
<ul>
<li>在索引 0 处：完全匹配；</li>
<li>在索引 1 处：第一个括号的内容；</li>
<li>在索引 2 处：第二个括号的内容；</li>
<li>…</li>
</ul>
<p>括号可以嵌套；在这种情况下，编号也从左到右，零索引始终保持完全匹配；即使组是可选的并且在匹配项中不存在，也存在相应的 result 数组项，并且等于 undefined；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&lt;h1&gt;Hello, world!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> tag = str.match(<span class="regexp">/&lt;(.*?)&gt;/</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tag); <span class="comment">//  [&#x27;&lt;h1&gt;&#x27;, &#x27;h1&#x27;, index: 0, input: &#x27;&lt;h1&gt;Hello, world!&lt;/h1&gt;&#x27;, groups: undefined]</span></span><br><span class="line">alert( tag[<span class="number">0</span>] ); <span class="comment">// &lt;h1&gt;</span></span><br><span class="line">alert( tag[<span class="number">1</span>] ); <span class="comment">// h1</span></span><br></pre></td></tr></table></figure>

<p>当搜索所有匹配项（标志 g）时，match 方法不会返回组的内容，结果是一个匹配数组，但没有每个匹配项的详细信息；使用方法 str.matchAll(regexp) 进行搜索并获取捕获组的内容；</p>
<p>matchAll 和 match 有三个区别：</p>
<ul>
<li>它返回的不是数组，而是一个可迭代的对象；</li>
<li>当标志 g 存在时，它将每个匹配组作为一个数组返回；</li>
<li>如果没有匹配项，则不返回 null，而是返回一个空的可迭代对象；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results = <span class="string">&#x27;&lt;h1&gt; &lt;h2&gt;&#x27;</span>.matchAll(<span class="regexp">/&lt;(.*?)&gt;/gi</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// results - is not an array, but an iterable object</span></span><br><span class="line">alert(results); <span class="comment">// [object RegExp String Iterator]</span></span><br><span class="line"></span><br><span class="line">alert(results[<span class="number">0</span>]); <span class="comment">// undefined (*)</span></span><br><span class="line"></span><br><span class="line">results = <span class="built_in">Array</span>.from(results); <span class="comment">// let&#x27;s turn it into array</span></span><br><span class="line"></span><br><span class="line">alert(results[<span class="number">0</span>]); <span class="comment">// &lt;h1&gt;,h1 (1st tag)</span></span><br><span class="line">alert(results[<span class="number">1</span>]); <span class="comment">// &lt;h2&gt;,h2 (2nd tag)</span></span><br></pre></td></tr></table></figure>

<p>命名组是通过在开始括号之后立即放置 <code>?&lt;name&gt;</code> 来完成的；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dateRegexp = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;2019-10-30 2020-01-01&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> results = str.matchAll(dateRegexp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> result <span class="keyword">of</span> results) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;year, month, day&#125; = result.groups;</span><br><span class="line"></span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;day&#125;</span>.<span class="subst">$&#123;month&#125;</span>.<span class="subst">$&#123;year&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// 第一个 alert：30.10.2019</span></span><br><span class="line">  <span class="comment">// 第二个：01.01.2020</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 str.replace(regexp, replacement) 用 replacement 替换 str 中匹配 regexp 的所有捕获组；使用 $n 或者名称 <code>$&lt;name&gt;</code>；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;John Bull&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(\w+) (\w+)/</span>;</span><br><span class="line">alert( str.replace(regexp, <span class="string">&#x27;$2, $1&#x27;</span>) ); <span class="comment">// Bull, John</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;2019-10-30, 2020-01-01&quot;</span>;</span><br><span class="line">alert( str.replace(regexp, <span class="string">&#x27;$&lt;day&gt;.$&lt;month&gt;.$&lt;year&gt;&#x27;</span>) );</span><br><span class="line"><span class="comment">// 30.10.2019, 01.01.2020</span></span><br></pre></td></tr></table></figure>

<p>可以通过在开头添加 ?: 来排除组；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Gogogo John!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?: 从捕获组中排除 &#x27;go&#x27;</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(?:go)+ (\w+)/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = str.match(regexp);</span><br><span class="line"></span><br><span class="line">alert( result[<span class="number">0</span>] ); <span class="comment">// Gogogo John（完全匹配）</span></span><br><span class="line">alert( result[<span class="number">1</span>] ); <span class="comment">// John</span></span><br><span class="line">alert( result.length ); <span class="comment">// 2（数组中没有更多项）</span></span><br></pre></td></tr></table></figure>

<p><strong>模式中的反向引用</strong></p>
<p>我们不仅可以在结果或替换字符串中使用捕获组 (…) 的内容，还可以在模式本身中使用它们；</p>
<p>可以使用 \N 在模式中引用一个组，其中 N 是组号；\1 在模式中进一步的含义是“查找与第一（捕获）分组相同的文本”；</p>
<p>如果正则表达式中有很多括号对（注：捕获组），给它们起个名字方便引用；要引用命名组，我们可以使用：<code>\k&lt;name&gt;</code>；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`He said: &quot;She&#x27;s the one!&quot;.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(?&lt;quote&gt;[&#x27;&quot;])(.*?)\k&lt;quote&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">alert( str.match(regexp) ); <span class="comment">// &quot;She&#x27;s the one!&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>选择（OR）|</strong></p>
<p>通常用圆括号把模式中的选择部分括起来，像这样 before(XXX|YYY)after；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/([01]\d|2[0-3]):[0-5]\d/g</span>;</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&quot;00:00 10:10 23:59 25:99 1:2&quot;</span>.match(reg)); <span class="comment">// 00:00,10:10,23:59</span></span><br></pre></td></tr></table></figure>

<p><strong>环视断言</strong></p>
<p>一般来说，环视断言括号中（前瞻和后瞻的通用名称）的内容不会成为匹配到的一部分结果，如果想要捕捉整个环视表达式或其中的一部分，只需要将其包裹在另加的括号中；</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">类型</th>
<th align="left">匹配</th>
</tr>
</thead>
<tbody><tr>
<td align="left">x(?=y)</td>
<td align="left">前瞻肯定断言</td>
<td align="left">x ，仅当后面跟着 y</td>
</tr>
<tr>
<td align="left">x(?!y)</td>
<td align="left">前瞻否定断言</td>
<td align="left">x ，仅当后面不跟 y</td>
</tr>
<tr>
<td align="left">(?&lt;=y)x</td>
<td align="left">后瞻肯定断言</td>
<td align="left">x ，仅当跟在 y 后面</td>
</tr>
<tr>
<td align="left">(?&lt;!y)x</td>
<td align="left">后瞻否定断言</td>
<td align="left">x ，仅当不跟在 y 后面</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1 turkey costs 30€&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+(?=(€|kr))/</span>; <span class="comment">// €|kr 两边有额外的括号</span></span><br><span class="line">alert( str.match(reg) ); <span class="comment">// 30, €</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1 turkey costs $30&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?&lt;=(\$|£))\d+/</span>;</span><br><span class="line">alert( str.match(reg) ); <span class="comment">// 30, $</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配非负数</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(?&lt;![-\d])\d+/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;0 12 -5 123 -18&quot;</span>;</span><br><span class="line">alert( str.match(regexp) ); <span class="comment">// 0, 12, 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 body 后插入，在替换字符串中，$&amp; 表示匹配本身</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;...&lt;body style=&quot;...&quot;&gt;...&#x27;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/(?&lt;=&lt;body.*?&gt;)/</span>, <span class="string">`&lt;h1&gt;Hello&lt;/h1&gt;`</span>);</span><br><span class="line">str = str.replace(<span class="regexp">/&lt;body.*?&gt;/</span>, <span class="string">&#x27;$&amp;&lt;h1&gt;Hello&lt;/h1&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>灾难性回溯</strong></p>
<p>解决方式：</p>
<ul>
<li>第一种重写正则表达式，尽可能减少其中排列组合的数量；</li>
<li>另一种使用前瞻断言禁止量词的回溯；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="string">&quot;JavaScript&quot;</span>.match(<span class="regexp">/\w+Script/</span>)); <span class="comment">// JavaScript</span></span><br><span class="line">alert( <span class="string">&quot;JavaScript&quot;</span>.match(<span class="regexp">/(?=(\w+))\1Script/</span>)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 括号被命名为 ?&lt;word&gt;，使用 \k&lt;word&gt; 来引用</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/^((?=(?&lt;word&gt;\w+))\k&lt;word&gt;\s?)*$/</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;An input string that takes a long time or even makes this regex to hang!&quot;</span>;</span><br><span class="line"></span><br><span class="line">alert( regexp.test(str) ); <span class="comment">// false</span></span><br><span class="line">alert( regexp.test(<span class="string">&quot;A correct string&quot;</span>) ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>粘性标志 “y”</strong></p>
<p>y 标志允许在源字符串中的指定位置执行搜索；</p>
<p>方法 regexp.exec(str)：</p>
<ul>
<li>如果 regexp 没有标志 g 或 y，那么这个方法就可以寻找字符串 str 中的第一个匹配，就像 str.match(regexp) 一样；</li>
<li>如果有标志 g，那么它就会在字符串 str 中执行搜索，从存储在 regexp.lastIndex 属性中的位置开始，如果发现匹配，则将 regexp.lastIndex 设置为匹配后的索引；</li>
<li>如果正则表达式带有标记 y，则搜索将精确地在 regexp.lastIndex 位置执行，不会再继续了；</li>
</ul>
<p><strong>正则表达式（RegExp）和字符串（String）的方法</strong></p>
<ul>
<li><p>str.match(regexp) 方法在字符串 str 中找到匹配 regexp 的字符；</p>
<ul>
<li>如果 regexp 不带有 g 标记，则以数组的形式返回第一个匹配项，其中包含分组和属性 index（匹配项的位置）、input（输入字符串，等于 str）；</li>
<li>如果 regexp 带有 g 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息；</li>
<li>如果没有匹配项，则无论是否带有标记 g ，都将返回 null；</li>
</ul>
</li>
<li><p>str.matchAll(regexp) 方法 str.matchAll(regexp) 是 str.match “新改进的”变体；</p>
<ul>
<li>它返回包含匹配项的可迭代对象，而不是数组。可以用 Array.from 从中得到一个常规数组；</li>
<li>每个匹配项均以包含分组的数组形式返回（返回格式与不带 g 标记的 str.match 相同）；</li>
<li>如果没有结果，则返回的不是 null，而是一个空的可迭代对象；</li>
</ul>
</li>
<li><p>str.split(regexp|substr, limit) 可以使用正则表达式（或子字符串）作为分隔符来分割字符串；</p>
</li>
<li><p>str.search(regexp) 方法返回第一个匹配项的位置，如果未找到，则返回 -1；</p>
</li>
<li><p>str.replace(str|regexp, str|func) 用于搜索和替换的通用方法；</p>
<ul>
<li>当第一个参数是字符串时，它仅替换第一个匹配项；</li>
<li>第二个参数是一个替代字符串，可以在其中使用特殊字符：<ul>
<li>$&amp;    插入整个匹配项；</li>
<li>$`    在匹配项之前插入字符串的一部分；</li>
<li>$’    在匹配项之后插入字符串的一部分；</li>
<li>$n    插入第 n 个分组的内容；</li>
<li><code>$&lt;name&gt;</code>    插入带有给定 name 的括号内的内容；</li>
<li><code>$$</code>    插入字符 $；</li>
</ul>
</li>
<li>第二个参数可以是一个函数：</li>
<li>func(match, p1, p2, …, pn, offset, input, groups) 带参数调用：<ul>
<li>match 匹配项；</li>
<li>p1, p2, …, pn 分组的内容（如有）；</li>
<li>offset 匹配项的位置；</li>
<li>input 源字符串；</li>
<li>groups 所指定分组的对象；</li>
</ul>
</li>
<li>如果正则表达式中没有括号，则只有 3 个参数：func(str, offset, input)</li>
</ul>
</li>
<li><p>regexp.exec(str) 方法返回字符串 str 中的 regexp 匹配项；</p>
</li>
<li><p>regexp.test(str) 方法查找匹配项，然后返回 true/false 表示是否存在；</p>
<ul>
<li>如果正则表达式带有标记 g，则 regexp.test 从 regexp.lastIndex 属性中查找，并更新此属性，就像 regexp.exec 一样；</li>
<li>如果我们在不同的源字符串上应用相同的全局表达式，可能会出现错误的结果，因为 regexp.test 的调用会增加 regexp.lastIndex 属性值，因此在另一个字符串中的搜索可能是从非 0 位置开始的</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.javascript.info/regexp-methods">JavaScript 现代教程-正则表达式（RegExp）和字符串（String）的方法</a></p>
</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Coley Brooks
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://blog.coley48.cn/2022/03/01/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="JavaScript 学习笔记">http://blog.coley48.cn/2022/03/01/JavaScript-学习笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/notes/" rel="tag"># notes</a>
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/10/%E5%B0%8F%E7%99%BD%E8%A3%85%E6%9C%BA%E6%8C%87%E5%8D%97/" rel="prev" title="小白装机指南">
      <i class="fa fa-chevron-left"></i> 小白装机指南
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/10/%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/" rel="next" title="HTML 小技巧汇总">
      HTML 小技巧汇总 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA"><span class="nav-number">1.1.</span> <span class="nav-text">项目搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">JavaScript 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E9%97%AD%E5%8C%85"><span class="nav-number">1.2.1.</span> <span class="nav-text">变量作用域，闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A7%E6%97%B6%E7%9A%84-var"><span class="nav-number">1.2.2.</span> <span class="nav-text">旧时的 var</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.3.</span> <span class="nav-text">全局对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%8CNFE"><span class="nav-number">1.2.4.</span> <span class="nav-text">函数对象，NFE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-Function-%E8%AF%AD%E6%B3%95"><span class="nav-number">1.2.5.</span> <span class="nav-text">new Function 语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%EF%BC%9AsetTimeout-%E5%92%8C-setInterval"><span class="nav-number">1.2.6.</span> <span class="nav-text">调度：setTimeout 和 setInterval</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%BD%AC%E5%8F%91%EF%BC%8Ccall-apply"><span class="nav-number">1.2.7.</span> <span class="nav-text">装饰器模式和转发，call&#x2F;apply</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-number">1.2.8.</span> <span class="nav-text">函数绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.9.</span> <span class="nav-text">深入理解箭头函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E6%A0%87%E5%BF%97%E5%92%8C%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.2.10.</span> <span class="nav-text">属性标志和属性描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84-getter-%E5%92%8C-setter"><span class="nav-number">1.2.11.</span> <span class="nav-text">属性的 getter 和 setter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.12.</span> <span class="nav-text">原型继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#F-prototype"><span class="nav-number">1.2.13.</span> <span class="nav-text">F.prototype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="nav-number">1.2.14.</span> <span class="nav-text">原生的原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E6%B2%A1%E6%9C%89-proto-%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.15.</span> <span class="nav-text">原型方法，没有 __proto__ 的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">1.2.16.</span> <span class="nav-text">Class 基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.17.</span> <span class="nav-text">类继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.18.</span> <span class="nav-text">静态属性和静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E7%9A%84%E5%92%8C%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.19.</span> <span class="nav-text">私有的和受保护的属性和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%86%85%E5%BB%BA%E7%B1%BB"><span class="nav-number">1.2.20.</span> <span class="nav-text">扩展内建类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A3%80%E6%9F%A5%EF%BC%9Ainstanceof"><span class="nav-number">1.2.21.</span> <span class="nav-text">类检查：instanceof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mixin-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.22.</span> <span class="nav-text">Mixin 模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%8Ctry%E2%80%A6catch"><span class="nav-number">1.2.23.</span> <span class="nav-text">错误处理，try…catch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Error%EF%BC%8C%E6%89%A9%E5%B1%95-Error"><span class="nav-number">1.2.24.</span> <span class="nav-text">自定义 Error，扩展 Error</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.25.</span> <span class="nav-text">回调简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise"><span class="nav-number">1.2.26.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-%E9%93%BE"><span class="nav-number">1.2.27.</span> <span class="nav-text">Promise 链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-promise-%E8%BF%9B%E8%A1%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.2.28.</span> <span class="nav-text">使用 promise 进行错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-API"><span class="nav-number">1.2.29.</span> <span class="nav-text">Promise API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promisification"><span class="nav-number">1.2.30.</span> <span class="nav-text">Promisification</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%88Microtask%EF%BC%89"><span class="nav-number">1.2.31.</span> <span class="nav-text">微任务（Microtask）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#async-await"><span class="nav-number">1.2.32.</span> <span class="nav-text">async&#x2F;await</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator"><span class="nav-number">1.2.33.</span> <span class="nav-text">Generator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3%E5%92%8C-generator"><span class="nav-number">1.2.34.</span> <span class="nav-text">异步迭代和 generator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97-Module"><span class="nav-number">1.2.35.</span> <span class="nav-text">模块 Module</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5"><span class="nav-number">1.2.36.</span> <span class="nav-text">导出和导入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Proxy-%E5%92%8C-Reflect"><span class="nav-number">1.2.37.</span> <span class="nav-text">Proxy 和 Reflect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eval"><span class="nav-number">1.2.38.</span> <span class="nav-text">eval</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96%EF%BC%88Currying%EF%BC%89"><span class="nav-number">1.2.39.</span> <span class="nav-text">柯里化（Currying）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reference-Type"><span class="nav-number">1.2.40.</span> <span class="nav-text">Reference Type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BigInt"><span class="nav-number">1.2.41.</span> <span class="nav-text">BigInt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%EF%BC%8C%E8%A7%84%E6%A0%BC"><span class="nav-number">1.2.42.</span> <span class="nav-text">浏览器环境，规格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM-%E6%A0%91"><span class="nav-number">1.2.43.</span> <span class="nav-text">DOM 树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-DOM"><span class="nav-number">1.2.44.</span> <span class="nav-text">遍历 DOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%EF%BC%9AgetElement%EF%BC%8CquerySelector"><span class="nav-number">1.2.45.</span> <span class="nav-text">搜索：getElement，querySelector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7%EF%BC%9Atype%EF%BC%8Ctag-%E5%92%8C-content"><span class="nav-number">1.2.46.</span> <span class="nav-text">节点属性：type，tag 和 content</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%EF%BC%88Attributes-and-properties%EF%BC%89"><span class="nav-number">1.2.47.</span> <span class="nav-text">特性和属性（Attributes and properties）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E6%A1%A3%EF%BC%88document%EF%BC%89"><span class="nav-number">1.2.48.</span> <span class="nav-text">修改文档（document）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E5%BC%8F%E5%92%8C%E7%B1%BB"><span class="nav-number">1.2.49.</span> <span class="nav-text">样式和类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%A0%B7%E5%BC%8F%EF%BC%9AgetComputedStyle"><span class="nav-number">1.2.50.</span> <span class="nav-text">计算样式：getComputedStyle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%BB%9A%E5%8A%A8"><span class="nav-number">1.2.51.</span> <span class="nav-text">元素大小和滚动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Window-%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%BB%9A%E5%8A%A8"><span class="nav-number">1.2.52.</span> <span class="nav-text">Window 大小和滚动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%90%E6%A0%87"><span class="nav-number">1.2.53.</span> <span class="nav-text">坐标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.54.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7"><span class="nav-number">1.2.55.</span> <span class="nav-text">冒泡和捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="nav-number">1.2.56.</span> <span class="nav-text">事件委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.2.57.</span> <span class="nav-text">浏览器默认行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.58.</span> <span class="nav-text">创建自定义事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.59.</span> <span class="nav-text">鼠标事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E9%BC%A0%E6%A0%87%EF%BC%9Amouseover-out%EF%BC%8Cmouseenter-leave"><span class="nav-number">1.2.60.</span> <span class="nav-text">移动鼠标：mouseover&#x2F;out，mouseenter&#x2F;leave</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87%E6%8B%96%E6%94%BE%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.61.</span> <span class="nav-text">鼠标拖放事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.62.</span> <span class="nav-text">指针事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%AE%E7%9B%98%EF%BC%9Akeydown-%E5%92%8C-keyup"><span class="nav-number">1.2.63.</span> <span class="nav-text">键盘：keydown 和 keyup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8"><span class="nav-number">1.2.64.</span> <span class="nav-text">滚动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.65.</span> <span class="nav-text">表单属性和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E7%84%A6%EF%BC%9Afocus-blur"><span class="nav-number">1.2.66.</span> <span class="nav-text">聚焦：focus&#x2F;blur</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%EF%BC%9Achange%EF%BC%8Cinput%EF%BC%8Ccut%EF%BC%8Ccopy%EF%BC%8Cpaste"><span class="nav-number">1.2.67.</span> <span class="nav-text">事件：change，input，cut，copy，paste</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%92%8C%E6%96%B9%E6%B3%95%E6%8F%90%E4%BA%A4"><span class="nav-number">1.2.68.</span> <span class="nav-text">表单：事件和方法提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.2.69.</span> <span class="nav-text">页面生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%EF%BC%9Aonload%EF%BC%8Conerror"><span class="nav-number">1.2.70.</span> <span class="nav-text">资源加载：onload，onerror</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM-%E5%8F%98%E5%8A%A8%E8%A7%82%E5%AF%9F%E5%99%A8%EF%BC%88Mutation-observer%EF%BC%89"><span class="nav-number">1.2.71.</span> <span class="nav-text">DOM 变动观察器（Mutation observer）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%EF%BC%88Selection%EF%BC%89%E5%92%8C%E8%8C%83%E5%9B%B4%EF%BC%88Range%EF%BC%89"><span class="nav-number">1.2.72.</span> <span class="nav-text">选择（Selection）和范围（Range）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9A%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.2.73.</span> <span class="nav-text">事件循环：微任务和宏任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%B9%E7%AA%97%E5%92%8C-window-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.74.</span> <span class="nav-text">弹窗和 window 的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%A8%E7%AA%97%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="nav-number">1.2.75.</span> <span class="nav-text">跨窗口通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayBuffer%EF%BC%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.76.</span> <span class="nav-text">ArrayBuffer，二进制数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TextDecoder-%E5%92%8C-TextEncoder"><span class="nav-number">1.2.77.</span> <span class="nav-text">TextDecoder 和 TextEncoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Blob"><span class="nav-number">1.2.78.</span> <span class="nav-text">Blob</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-%E5%92%8C-FileReader"><span class="nav-number">1.2.79.</span> <span class="nav-text">File 和 FileReader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fetch"><span class="nav-number">1.2.80.</span> <span class="nav-text">Fetch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FormData"><span class="nav-number">1.2.81.</span> <span class="nav-text">FormData</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fetch%EF%BC%9A%E4%B8%8B%E8%BD%BD%E8%BF%9B%E5%BA%A6"><span class="nav-number">1.2.82.</span> <span class="nav-text">Fetch：下载进度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fetch%EF%BC%9A%E4%B8%AD%E6%AD%A2"><span class="nav-number">1.2.83.</span> <span class="nav-text">Fetch：中止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fetch%EF%BC%9A%E8%B7%A8%E6%BA%90%E8%AF%B7%E6%B1%82"><span class="nav-number">1.2.84.</span> <span class="nav-text">Fetch：跨源请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fetch-API"><span class="nav-number">1.2.85.</span> <span class="nav-text">Fetch API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URL-%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.86.</span> <span class="nav-text">URL 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XMLHttpRequest"><span class="nav-number">1.2.87.</span> <span class="nav-text">XMLHttpRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebSocket"><span class="nav-number">1.2.88.</span> <span class="nav-text">WebSocket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Server-Sent-Events"><span class="nav-number">1.2.89.</span> <span class="nav-text">Server-Sent Events</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie%EF%BC%8Cdocument-cookie"><span class="nav-number">1.2.90.</span> <span class="nav-text">Cookie，document.cookie</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LocalStorage%EF%BC%8CsessionStorage"><span class="nav-number">1.2.91.</span> <span class="nav-text">LocalStorage，sessionStorage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IndexedDB"><span class="nav-number">1.2.92.</span> <span class="nav-text">IndexedDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSS-%E5%8A%A8%E7%94%BB"><span class="nav-number">1.2.93.</span> <span class="nav-text">CSS 动画</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-%E5%8A%A8%E7%94%BB"><span class="nav-number">1.2.94.</span> <span class="nav-text">JavaScript 动画</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Custom-elements"><span class="nav-number">1.2.95.</span> <span class="nav-text">Custom elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%B1%E5%AD%90-DOM"><span class="nav-number">1.2.96.</span> <span class="nav-text">影子 DOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E7%B4%A0"><span class="nav-number">1.2.97.</span> <span class="nav-text">模板元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shadow-DOM-%E6%8F%92%E6%A7%BD%EF%BC%8C%E7%BB%84%E6%88%90"><span class="nav-number">1.2.98.</span> <span class="nav-text">Shadow DOM 插槽，组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shadow-DOM-%E6%A0%B7%E5%BC%8F"><span class="nav-number">1.2.99.</span> <span class="nav-text">Shadow DOM 样式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shadow-DOM-%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.100.</span> <span class="nav-text">Shadow DOM 和事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.2.101.</span> <span class="nav-text">正则表达式</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Coley Brooks"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">Coley Brooks</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Coley48" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Coley48" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:coley48@qq.com" title="E-Mail → mailto:coley48@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hush</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacity":0.95,"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
