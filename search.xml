<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 学习笔记</title>
    <url>/2021/04/28/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a>关于版本控制</h3><blockquote>
<p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 在本书所展示的例子中，我们对保存着软件源代码的文件作版本控制，但实际上，你可以对任何类型的文件进行版本控制。Git 是基于差异（delta-based）的版本控制工具。<br>在 Git中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 会为每个版本都创建一个快照。</p>
</blockquote>
<span id="more"></span>

<h3 id="Git-工作方式"><a href="#Git-工作方式" class="headerlink" title="Git 工作方式"></a>Git 工作方式</h3><p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作区中修改文件。</li>
<li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li>
<li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li>
</ol>
<p>文件的三种状态：已提交（committed）、已修改（modified） 和 已暂存（staged）。</p>
<ul>
<li>已修改表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交表示数据已经安全地保存在本地数据库中。</li>
</ul>
<p>结合文件的三种状态，与之对应的有三个位置：工作区（workspace）、暂存区（index）、Git仓库（repository）；</p>
<ul>
<li>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</li>
<li>Git仓库是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</li>
</ul>
<p>Git 工作三个阶段:</p>
<img src="/2021/04/28/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5.png" class="">

<p>Git 文件状态变更:</p>
<img src="/2021/04/28/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E5%8F%98%E6%9B%B4.png" class="">

<h3 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h3><p>Windows 上安装：</p>
<ol>
<li>从官网下载，<a href="https://git-scm.com/downloads">地址</a>；</li>
<li>执行安装程序，不更改默认选项，一路确认完成安装；</li>
<li>安装完成后查看 Git 版本，<code>git --version</code> ；</li>
</ol>
<p><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">Linux、Mac 安装</a></p>
<h3 id="Git-使用"><a href="#Git-使用" class="headerlink" title="Git 使用"></a>Git 使用</h3><h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p><code>git config</code>命令用于查看或更改配置信息。安装完 Git 之后，要做的第一件事就是设置用户名和邮件地址。这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改。该配置项会被写入用户文件夹下的.gitconfig 文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;username&quot;</span> <span class="comment"># 设置用户名</span></span><br><span class="line">$ git config --global user.email username@example.com <span class="comment"># 设置邮箱地址</span></span><br><span class="line">$ git config &lt;key&gt; <span class="comment"># 显示指定配置项</span></span><br><span class="line">$ git config --list <span class="comment"># 显示所有配置信息</span></span><br><span class="line">$ git config --list --show-origin <span class="comment"># 显示配置信息及配置文件路径</span></span><br><span class="line">$ git config --global core.editor <span class="string">&quot;path/to/editor&quot;</span> <span class="comment"># 配置默认的编辑器</span></span><br><span class="line">$ git config --global core.editor notepad <span class="comment"># 设置默认编辑器未notepad</span></span><br></pre></td></tr></table></figure>

<h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>Git 创建仓库一般分为两种方式：</p>
<ol>
<li>在本地创建</li>
</ol>
<p><code>git init</code>命令将创建一个名为 .git 的子目录（隐藏文件夹），这个子目录包括初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/myProject <span class="comment"># 进入到项目文件夹下</span></span><br><span class="line">$ git init <span class="comment"># 在本地创建 Git 仓库，将尚未进行版本控制的本地目录转换为 Git 仓库；</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从远程克隆</li>
</ol>
<p><code>git clone</code>命令将从远程 Git 服务器上将项目下载到本地，形成一个本地的克隆仓库，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。命令会自动将其添加为远程仓库并默认以 “origin” 为简写。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/User/Project.git <span class="comment"># 使用http协议在当前文件夹下下载Project项目</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:User/Project.git <span class="comment"># 使用Git协议在当前文件夹下下载Project项目</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/User/Project.git newName <span class="comment"># 下载Project项目到newName文件夹中，也可以跟路径，下载到指定位置</span></span><br><span class="line">$ git <span class="built_in">clone</span> -b &lt;branchName&gt; https://github.com/User/Project.git <span class="comment"># 下载项目指定分支，并且绑定获取和推送地址为该分支；</span></span><br><span class="line"><span class="comment"># 下载链接后的 .git 可以不加；</span></span><br></pre></td></tr></table></figure>

<h4 id="修改提交"><a href="#修改提交" class="headerlink" title="修改提交"></a>修改提交</h4><p><code>git status</code>命令用于查看项目中文件状态，待提交、已修改、未跟踪等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status <span class="comment"># 查看文件状态</span></span><br><span class="line">$ git status -s/--short <span class="comment"># 查看文件状态的简略信息，其中文件名前会显示两列标志，左栏表示暂存区的状态，右栏表示工作区的状态，?表示未跟踪，A表示新增，M表示修改过</span></span><br></pre></td></tr></table></figure>

<p><code>git add</code>命令用于添加文件到缓冲区并跟踪文件，即监视文件变动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add &lt;file&gt; <span class="comment"># 添加跟踪文件到暂存区</span></span><br><span class="line">$ git add *.c <span class="comment"># 添加所有.c文件</span></span><br><span class="line">$ git add . <span class="comment"># 添加所有文件</span></span><br></pre></td></tr></table></figure>

<p><code>git diff</code>命令用于查看文件更改前后之间的差异。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff &lt;file&gt; <span class="comment"># 比较工作目录中当前文件和暂存区域快照之间的差异；</span></span><br><span class="line">$ git diff --staged <span class="comment"># 比对已暂存文件与最后一次提交的文件差异;</span></span><br></pre></td></tr></table></figure>

<p><code>git commit</code>命令用于将缓冲区中的文件提交到本地仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit <span class="comment"># 提交代码到本地仓库，默认使用 nano 编辑器，建议更改默认编辑器</span></span><br><span class="line">$ git commit -m <span class="string">&quot;comments&quot;</span> <span class="comment"># 提交代码并添加注释</span></span><br><span class="line">$ git commit -a <span class="comment"># 跳过 git add 添加到缓冲区操作，直接提交已跟踪的更改文件</span></span><br><span class="line">$ git commit -am <span class="string">&quot;comments&quot;</span> <span class="comment"># 直接提交更改文件，同时添加注释</span></span><br><span class="line">$ git commit --amend <span class="comment"># 重新提交，可以补充提交暂存区中的文件，也可以重写注释</span></span><br></pre></td></tr></table></figure>

<p><code>git mv</code>命令用于重命名已跟踪的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm &lt;fileA&gt; &lt;fileB&gt; <span class="comment"># 将文件fileA重命名为fileB</span></span><br></pre></td></tr></table></figure>

<p><code>git merge</code>命令用于合并分支，待补充。</p>
<h4 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h4><p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。<br><code>git remote</code>命令用于查看、配置远程信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="comment"># 用于显示远程配置信息，列出你指定的每一个远程服务器的简写，克隆仓库会显示origin，这是默认远程仓库的名称\</span></span><br><span class="line">$ git remote -v <span class="comment"># 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</span></span><br><span class="line">$ git remote add &lt;remoteName&gt; &lt;url&gt; <span class="comment"># 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写</span></span><br><span class="line">$ git remote show &lt;remoteName&gt; <span class="comment"># 显示指定远程仓库的信息</span></span><br></pre></td></tr></table></figure>

<p><code>git fetch</code>命令用于从远程仓库获取数据，该命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作，后续需要手动合并代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch &lt;remote&gt; <span class="comment"># 抓取指定远程仓库的代码，省略则抓取默认的 origin 远程仓库</span></span><br></pre></td></tr></table></figure>

<p><code>git push</code>命令用于将本地仓库的代码推送到远程仓库。需要有写入权限，并且本地代码已经更新到和远程仓库同步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push [remote] [branch] <span class="comment"># 将代码推送到指定远程仓库的指定分支下，一般默认 origin 下的 master/main 主分支；</span></span><br><span class="line">$ git push [remote] HEAD:&lt;branch&gt; <span class="comment"># 使用该命令推送到指定的远程分支；</span></span><br><span class="line">$ git push --set-upstream origin &lt;newBranch&gt; <span class="comment"># 将本地分支推送到远程服务器，并创建对应的分支 </span></span><br><span class="line">$ git push origin --delete &lt;BranchName&gt; <span class="comment"># 删除远程分支</span></span><br></pre></td></tr></table></figure>

<p><code>git pull</code>操作用于从服务器拉取更新代码，并自动合并到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull <span class="comment"># 相当于 git fetch + git merge 结合的操作</span></span><br><span class="line">$ git pull [remote] [branch] <span class="comment"># 下载指定分支代码，并快速合并</span></span><br></pre></td></tr></table></figure>

<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p><code>git branch</code>命令用于查看、创建分支等操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch <span class="comment"># 查看工作区下的分支，并显示当前分支</span></span><br><span class="line">$ git branch -a <span class="comment"># 显示所有本地分支和远程分支</span></span><br><span class="line">$ git branch -v <span class="comment"># 显示分支的哈希码以及上次提交注释信息</span></span><br><span class="line">$ git branch &lt;branchName&gt; <span class="comment"># 创建新的本地分支</span></span><br><span class="line">$ git branch -d &lt;branchName&gt; <span class="comment"># 删除本地分支</span></span><br></pre></td></tr></table></figure>

<p><code>git checkout</code>命令用于切换分支，切换分支体现在.git/HEAD文件中的指向；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment"># 显示工作区、暂存区和远程仓库之间的差异</span></span><br><span class="line">$ git checkout [branchName | hashValue] <span class="comment"># 切换到分支，可以切换到本地没有的分支，可以是历史提交的版本，或者远程分支，进入分离头模式（detached HEAD），在分离头模式中也可以创建新的分支；</span></span><br><span class="line">$ git checkout -b &lt;branchName&gt; <span class="comment"># 创建并切换分支</span></span><br><span class="line">$ git checkout --orphan &lt;branch-name&gt; <span class="comment"># 创建单独分支</span></span><br></pre></td></tr></table></figure>

<h4 id="撤销删除"><a href="#撤销删除" class="headerlink" title="撤销删除"></a>撤销删除</h4><p><code>git reset</code>用于撤销操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt; <span class="comment"># 用于从暂存区取消暂存文件</span></span><br></pre></td></tr></table></figure>

<p><code>git rm</code>命令用于删除 Git 项目中的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm &lt;file&gt; <span class="comment"># 从暂存区中删除文件，同时永久删除文件，不能删除未提交到仓库中的文件</span></span><br><span class="line">$ git rm --cached &lt;file&gt; <span class="comment"># 只从缓冲区中删除文件，取消跟踪</span></span><br><span class="line">$ git rm -f &lt;file&gt; <span class="comment"># 强制删除文件，包括未提交到仓库中的文件</span></span><br><span class="line">$ git rm -rf . <span class="comment"># 强制移除项目中所有文件</span></span><br><span class="line">$ git rm -r --cached . <span class="comment"># 删除本地缓存，有时更新.gitignore文件不会立即生效，可以执行该命令</span></span><br></pre></td></tr></table></figure>

<p><code>git restore</code>命令用于丢弃更改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git restore &lt;file&gt; <span class="comment"># 忽略该文件的更改，退回到上次提交时的状态</span></span><br></pre></td></tr></table></figure>

<h4 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h4><p><code>git log</code>命令用于查看提交历史。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment"># 查看提交历史，包括哈希值、作者、日期、注释等信息；</span></span><br><span class="line">$ git <span class="built_in">log</span> -p/--patch <span class="comment"># 补丁格式显示，显示更改内容；</span></span><br><span class="line">$ git <span class="built_in">log</span> [-2] <span class="comment"># 指定显示最后提交记录的条数；</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span> <span class="comment"># 显示提交记录的同时，显示每次提交的简略统计信息；</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline <span class="comment"># 指定显示格式，参数有 online | short | full | fuller，默认 full；</span></span><br><span class="line">$ git <span class="built_in">log</span> --abbrev-commit <span class="comment"># 只显示哈希码的前几位，一般7位</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline <span class="comment"># --pretty=oneline 和 --abbrev-commit 组合的缩写</span></span><br></pre></td></tr></table></figure>

<h4 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h4><p><code>git tag</code>命令用于为不同版本提交设置标签，待补充。</p>
<h4 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h4><p>以下命令可以查看 Git 指令的描述，以及详细用法；打开的是本地的英文网页文档；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">help</span> &lt;action&gt;</span><br><span class="line">$ git &lt;action&gt; --<span class="built_in">help</span></span><br><span class="line">$ git &lt;action&gt; -h <span class="comment"># 命令缩写</span></span><br></pre></td></tr></table></figure>

<h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>当项目中有一些缓存文件、日志文件、临时文件、测试文件等不需要跟踪的文件时，可以在项目根目录下新建一个<code>.gitignore</code>文件，将不需要跟踪的文件添加进去，Git 会忽略到这些文件。</p>
<p><code>.gitignore</code>文件格式规范：</p>
<ul>
<li>所有空行或者以 # 开头的行都会被 Git 忽略，注释。</li>
<li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li>
<li>匹配模式可以以（/）开头防止递归。</li>
<li>匹配模式可以以（/）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</li>
</ul>
<p>其中 glob 模式是指 shell 所使用的简化了的正则表达式。</p>
<ul>
<li>星号（*）匹配零个或多个任意字符；</li>
<li>[abc] 匹配任何一个列在方括号中的字符；</li>
<li>问号（?）只匹配一个任意字符；</li>
<li>如果在方括号中使用短划线分隔两个字符，表示匹配这两个字符范围内的字符；</li>
<li>使用两个星号（**）表示匹配任意中间目录；</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://git-scm.com/">Git 官网</a></li>
<li><a href="https://git-scm.com/book/zh/v2">progit 在线文档</a></li>
<li><a href="https://github.com/progit/progit2-zh/releases/download/2.1.55/progit_v2.1.55.pdf">progit PDF电子书</a></li>
<li><a href="https://www.jianshu.com/p/46ffff059092">Git 命令大全</a></li>
<li><a href="https://github.com/521xueweihan/git-tips">Git 奇淫技巧</a></li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>notes</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Gogs-学习笔记</title>
    <url>/2021/09/05/Gogs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="什么是-Gogs"><a href="#什么是-Gogs" class="headerlink" title="什么是 Gogs?"></a>什么是 Gogs?</h3><p>Gogs 是一款极易搭建的自助 Git 服务。可以根据操作系统平台下载二进制运行，或者通过 Docker 或 Vagrant，以及包管理安装。Gogs 是用 Go 语言开发，因此任何 Go 语言支持的平台都可以运行 Gogs，包括 Windows、Mac、Linux 以及 ARM。一个廉价的树莓派的配置足以满足 Gogs 的最低系统硬件要求。甚至还可以将 Gogs 运行在 NAS 设备上。</p>
<p>Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台。</p>
<span id="more"></span>

<h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><p>数据库（选择以下一项）：</p>
<ul>
<li>MySQL：版本 &gt;= 5.7</li>
<li>PostgreSQL</li>
<li>TiDB（实验性支持，使用 MySQL 协议连接）</li>
<li>或者什么都不安装，直接使用 SQLite3</li>
</ul>
<p>Git（bash）：</p>
<ul>
<li>服务端和客户端均需版本 &gt;= 1.8.3</li>
<li>Windows 系统建议使用最新版</li>
</ul>
<p>SSH 服务器：</p>
<ul>
<li>如果您只使用 HTTP/HTTPS 的话请忽略此项</li>
<li>如果您选择在 Windows 系统使用内置 SSH 服务器，请确保添加<code>ssh-keygen</code>到您的<code>%PATH%</code>环境变量中</li>
<li>推荐 Windows 系统使用 Cygwin OpenSSH 或 Copssh</li>
<li>Windows 系统 请确保 Bash 是默认的 Shell 程序，而不是 PowerShell</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>安装好 Git，MySQL，NSSM；</li>
<li>新增 git 系统用户，并修改其权限，具体可以参考<a href="https://o-r.github.io/2018/05/12/Gogs%E5%9C%A8windows%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">这篇</a>；</li>
</ol>
<p>版本信息：</p>
<ul>
<li>Git：<code>2.29.2</code>；</li>
<li>MySQL：<code>15.1</code>；</li>
<li>NSSM：<code>2.24</code>；</li>
</ul>
<p>其中数据库我用的是 <a href="https://mariadb.org/">MariaDB</a>；</p>
<h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p>Gogs 有多种安装方式，一般使用源码安装和二进制安装。但是源码安装相对麻烦一点，需要在本地有 Go 语言环境，然后将源码下到本地，再进行编译，期间可能还会遇到其他一些问题。</p>
<p>通常直接进行二进制安装，下载最新版本的 Gogs，在 Windows 环境下有两种安装方式；</p>
<h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>下载 Gogs mws（Minimal Windows Service）版，即提供内置 Windows 服务支持版本；</p>
<p>下载完成之后依次执行以下步骤：</p>
<ol>
<li>解压压缩包；</li>
<li>使用命令 cd 进入到刚刚创建的目录；</li>
<li>执行命令 <code>./gogs web</code>；</li>
<li>访问<code>/install</code>以进行初始配置，默认在<code>3000</code>端口启动 HTTP 服务；</li>
<li>配置服务器访问端口；</li>
</ol>
<p>初次运行</p>
<img src="/2021/09/05/Gogs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Gogs%E8%BF%90%E8%A1%8C.png" class="">

<p>配置界面</p>
<img src="/2021/09/05/Gogs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Gogs%E9%85%8D%E7%BD%AE.png" class="">

<p>在本地测试的时候发现手动命令行启动 Gogs 时需要通过 Bash 开启服务，否则会出现无法克隆仓库的问题，后面才发现是环境变量不完整；</p>
<h4 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h4><p>而更推荐的做法是下载非 mws 版，这样可以使用 NSSM 将 Gogs 注册成 Windows 服务在后台运行；</p>
<p>然后通过 NSSM 注册服务并开启后，同样会出现无法克隆仓库的问题；<br>最后发现环境变量中要有 ssh-keygen 的路径，可以是 git 下的路径（<code>e.g. C:\Program Files\Git\usr\bin</code>）<br>当然也可以在 NSSM 注册服务时，通过 Environment 栏添加包含 ssh-keygen 的路径；</p>
<p>其中在使用 NSSM 注册服务时，可以按照<a href="https://gogs.io/docs/installation/run_as_windows_service">官方教程</a>进行手动配置；<br>而更简单的做法是，使用 Gogs 中自带的脚本进行自动注册；</p>
<ol>
<li>找到<code>C:\gogs\scripts\windows</code>下的<code>install-as-service.bat</code>文件；</li>
<li>右键以管理员身份打开；</li>
<li>然后看到注册成功的提示信息则说明服务已经注册并开启；</li>
<li>直接访问<code>localhost:3000</code>，进入初始配置页面进行配置；</li>
</ol>
<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><p>通常在初始安装后的初始配置时完成各项配置，后续需要更新配置时可以在根目录下的<code>custom/conf/app.ini</code>。详细的配置解释和默认值请参考官方文档，其中关键的配置是下面这些，详细配置放在<a href="/2021/09/25/Gogs-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%89%8B%E5%86%8C/" title="Gogs-配置文件手册">Gogs-配置文件手册</a>中。</p>
<table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RUN_USER</td>
<td align="left">默认是 git，指定 Gogs 以哪个用户运行</td>
</tr>
<tr>
<td align="left">ROOT</td>
<td align="left">所有仓库的存储根路径</td>
</tr>
<tr>
<td align="left">PROTOCOL</td>
<td align="left">如果你使用 nginx 反代的话请使用 http，如果直接裸跑对外服务的话随意</td>
</tr>
<tr>
<td align="left">DOMAIN</td>
<td align="left">域名，会影响 SSH clone 地址</td>
</tr>
<tr>
<td align="left">ROOT_URL</td>
<td align="left">完整的根路径，会影响访问时页面上链接的指向，以及 HTTP clone 的地址</td>
</tr>
<tr>
<td align="left">HTTP_ADDR</td>
<td align="left">监听地址，使用 nginx 的话建议 127.0.0.1，否则 0.0.0.0 也可以</td>
</tr>
<tr>
<td align="left">HTTP_PORT</td>
<td align="left">监听端口，默认 3000</td>
</tr>
<tr>
<td align="left">INSTALL_LOCK</td>
<td align="left">锁定安装页面</td>
</tr>
<tr>
<td align="left">Mailer</td>
<td align="left">相关的选项，可以使用 Mailgun 的免费邮件发送服务，将 Mailgun 的 SMTP 配置填入到配置中</td>
</tr>
</tbody></table>
<p>此外除了基础配置外，还可以通过自定义模板更改默认的页面主题外观或新增一些额外的自定义功能；注意：所有针对自定义模板的修改都需要重启 Gogs 实例。</p>
<ul>
<li>重载 HTML 模板：通过在<code>custom/templates/</code>目录下创建一个自定义版本的副本实现 HTML 模板重载（包括邮件模板）</li>
<li>重载静态文件：通过在<code>custom/public/</code>目录下创建一个自定义版本的副本实现静态文件重载（CSS、JS、图片等等）</li>
<li>注入自定义内容到模板中：通过在<code>custom/templates/inject/head.tmpl</code>或<code>custom/templates/inject/footer.tmpl</code>文件中分别添加自定义头部 meta 信息和引入自定义静态资源（如 CSS）或自定义 JS 和分析代码；</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://gogs.io/docs">官方文档</a></li>
<li><a href="https://github.com/gogs/gogs/releases">历史版本</a></li>
<li><a href="https://blog.mynook.info/post/host-your-own-git-server-using-gogs/">使用 Gogs 搭建自己的 Git 服务器</a></li>
<li><a href="https://discuss.gogs.io/t/how-to-inject-custom-head-and-footer/943">注入自定义头部和尾部</a></li>
<li><a href="https://o-r.github.io/2018/05/12/Gogs%E5%9C%A8windows%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">Gogs在windows上的安装和配置</a></li>
<li><a href="https://dashdream.github.io/p/7dd2a61d.html">gogs配置详解</a></li>
<li><a href="https://www.cxyzjd.com/article/e891377/109302884">win10操作系统Gogs配置解决ssh方式git免密下载上传问题</a></li>
<li><a href="https://www.itfanr.cc/2017/03/24/docker-ubuntu-gogs-problems/">Docker-Ubuntu-Gogs部署及配置时遇到的问题</a></li>
<li><a href="https://www.jianshu.com/p/b78b385cf168">Windows下安装Gogs</a></li>
<li><a href="https://www.cnblogs.com/configure/p/7878501.html">Git服务器Gogs简易安装-Windows环境</a></li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>学习笔记</tag>
        <tag>Gogs</tag>
      </tags>
  </entry>
  <entry>
    <title>Gogs-配置文件手册</title>
    <url>/2021/09/25/Gogs-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>该配置文件手册是有关 Gogs 配置文件选项的详尽描述，主要为了方便使用 Gogs 时查相关配置项。<br>注：Gogs 任何修改都是发生在<code>custom/conf/app.ini</code>自定义配置文件中，该文件的具体位置与您的设置有关。<br>完整的默认设置可以通过<code>app.ini</code>文件查看。如果看到类似<code>%(X)s</code>字符，这是由 ini 提供的递归取值的特性。</p>
<span id="more"></span>

<p><strong>概览</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">APP_NAME</td>
<td align="left">应用名称，可以改成您的组织或公司名称</td>
</tr>
<tr>
<td align="left">RUN_USER</td>
<td align="left">运行应用的用户名称，我们建议您使用 git，但如果您在个人计算机上运行 Gogs，请修改为您的系统用户名称。如果没有正确设置这个值，很可能导致您的应用崩溃</td>
</tr>
<tr>
<td align="left">RUN_MODE</td>
<td align="left">鉴于性能和其它考虑，建议在部署环境下修改为 prod 模式。在您完成安装操作时，该值也会被设置为 prod</td>
</tr>
</tbody></table>
<p><strong>服务器 (server)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PROTOCOL</td>
<td align="left">http 或 https</td>
</tr>
<tr>
<td align="left">DOMAIN</td>
<td align="left">服务器域名</td>
</tr>
<tr>
<td align="left">ROOT_URL</td>
<td align="left">公开的完整 URL 路径</td>
</tr>
<tr>
<td align="left">HTTP_ADDR</td>
<td align="left">应用 HTTP 监听地址</td>
</tr>
<tr>
<td align="left">HTTP_PORT</td>
<td align="left">应用 HTTP 监听端口号</td>
</tr>
<tr>
<td align="left">UNIX_SOCKET_PERMISSION</td>
<td align="left">Unix 套接字文件的权限</td>
</tr>
<tr>
<td align="left">LOCAL_ROOT_URL</td>
<td align="left">用于 Gogs 工作进程（如：SSH）回访应用的本地（DMZ）URL，一般情况下请保持默认值，除非您的 SSH 服务器节点与 HTTP 并不是同一个节点入口</td>
</tr>
<tr>
<td align="left">DISABLE_SSH</td>
<td align="left">当 SSH 功能不可用时可以禁用</td>
</tr>
<tr>
<td align="left">START_SSH_SERVER</td>
<td align="left">启用该选项来启动内置 SSH 服务器</td>
</tr>
<tr>
<td align="left">SSH_DOMAIN</td>
<td align="left">允许公用网络访问 SSH 的域名</td>
</tr>
<tr>
<td align="left">SSH_PORT</td>
<td align="left">SSH 端口号，如果不为 22 的话可以在此修改</td>
</tr>
<tr>
<td align="left">SSH_LISTEN_HOST</td>
<td align="left">内置 SSH 服务器监听的地址</td>
</tr>
<tr>
<td align="left">SSH_LISTEN_PORT</td>
<td align="left">内置 SSH 服务器监听的端口</td>
</tr>
<tr>
<td align="left">SSH_ROOT_PATH</td>
<td align="left">SSH 根目录，一般为 ~/.ssh，但必须填写为 /home/git/.ssh</td>
</tr>
<tr>
<td align="left">REWRITE_AUTHORIZED_KEYS_AT_START</td>
<td align="left">激活该选项以在应用启动时自动重写 authorized_keys 文件，该选项在使用内置 SSH 服务器时将会被自动禁用</td>
</tr>
<tr>
<td align="left">SSH_KEY_TEST_PATH</td>
<td align="left">用于测试 SSH 公钥的临时目录</td>
</tr>
<tr>
<td align="left">SSH_KEYGEN_PATH</td>
<td align="left">ssh-keygen 程序的路径，默认为 ssh-keygen 即通过系统路径查找</td>
</tr>
<tr>
<td align="left">MINIMUM_KEY_SIZE_CHECK</td>
<td align="left">指定不同类型的公钥的最小密钥大小</td>
</tr>
<tr>
<td align="left">OFFLINE_MODE</td>
<td align="left">激活该选项来禁止从 CDN 获取静态资源，同时 Gravatar 服务也将被自动禁用</td>
</tr>
<tr>
<td align="left">DISABLE_ROUTER_LOG</td>
<td align="left">激活该选项来禁止打印路由日志</td>
</tr>
<tr>
<td align="left">CERT_FILE</td>
<td align="left">HTTPS 授权文件路径</td>
</tr>
<tr>
<td align="left">KEY_FILE</td>
<td align="left">HTTPS 的密钥文件路径</td>
</tr>
<tr>
<td align="left">STATIC_ROOT_PATH</td>
<td align="left">模板文件和静态文件的上级目录，默认为应用二进制所在的位置</td>
</tr>
<tr>
<td align="left">APP_DATA_PATH</td>
<td align="left">应用内部数据的存放目录</td>
</tr>
<tr>
<td align="left">ENABLE_GZIP</td>
<td align="left">激活该选项来启用应用级别 GZIP 支持</td>
</tr>
<tr>
<td align="left">LANDING_PAGE</td>
<td align="left">未登录用户的默认首页，可以是 home 或 explore（探索页）</td>
</tr>
</tbody></table>
<p><strong>仓库 (repository)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ROOT</td>
<td align="left">用户仓库存储根目录，必须为绝对路径，默认为 ~/<user name>/gogs-repositories</td>
</tr>
<tr>
<td align="left">SCRIPT_TYPE</td>
<td align="left">系统脚本类型，一般情况下均为 bash，但有些用户反应只能使用 sh</td>
</tr>
<tr>
<td align="left">ANSI_CHARSET</td>
<td align="left">当遇到无法识别的字符集时使用的默认字符集</td>
</tr>
<tr>
<td align="left">FORCE_PRIVATE</td>
<td align="left">强制要求所有新建的仓库都是私有的</td>
</tr>
<tr>
<td align="left">MAX_CREATION_LIMIT</td>
<td align="left">全局默认的每个用户可创建创建仓库上限，-1 表示无限制</td>
</tr>
<tr>
<td align="left">PREFERRED_LICENSES</td>
<td align="left">建议用户首选的授权类型</td>
</tr>
<tr>
<td align="left">DISABLE_HTTP_GIT</td>
<td align="left">激活该选项来禁止用户通过 HTTP 对 Git 仓库进行交互操作，即用户只能通过 SSH 操作</td>
</tr>
<tr>
<td align="left">ENABLE_LOCAL_PATH_MIGRATION</td>
<td align="left">激活该选项来启用本地路径迁移仓库功能。启动后默认只有管理员可以使用，普通用户必须经由管理员授权</td>
</tr>
<tr>
<td align="left">ENABLE_RAW_FILE_RENDER_MODE</td>
<td align="left">激活该选项来启用在查看原始数据时对页面进行真实渲染，例如渲染实际的 HTML 页面，有潜在安全隐患</td>
</tr>
</tbody></table>
<p><strong>仓库 - 编辑器 (repository.editor)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LINE_WRAP_EXTENSIONS</td>
<td align="left">需要显示为行包装的文件名后缀，通过逗号分隔。如果是无后缀名的文件，则单独放置一个逗号，例如：.txt,</td>
</tr>
</tbody></table>
<p><strong>仓库 - 文件上传 (repository.upload)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ENABLED</td>
<td align="left">激活该选项来启用仓库文件上传功能</td>
</tr>
<tr>
<td align="left">TEMP_PATH</td>
<td align="left">文件上传的临时存放目录</td>
</tr>
<tr>
<td align="left">ALLOWED_TYPES</td>
<td align="left">允许上传的文件类型（例如：”image/jpeg|image/png”），留空表示允许上传任意类型的文件</td>
</tr>
<tr>
<td align="left">FILE_MAX_SIZE</td>
<td align="left">单个上传的文件的最大体积，以 MB 为单位</td>
</tr>
<tr>
<td align="left">MAX_FILES</td>
<td align="left">单次同时上传的最多文件个数</td>
</tr>
</tbody></table>
<p><strong>版本发布 - 附件 (release.attachment)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ENABLED</td>
<td align="left">激活该选项来启用版本发布附件功能</td>
</tr>
<tr>
<td align="left">PATH</td>
<td align="left">存放附件的路径</td>
</tr>
<tr>
<td align="left">ALLOWED_TYPES</td>
<td align="left">允许上传的 MIME 类型，例如 “image/jpeg</td>
</tr>
<tr>
<td align="left">MAX_SIZE</td>
<td align="left">最大允许上传的附件体积，单位为 MB，例如 32</td>
</tr>
<tr>
<td align="left">MAX_FILES</td>
<td align="left">最大允许一次性上传的附件个数，例如 10</td>
</tr>
</tbody></table>
<p><strong>Markdown (markdown)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ENABLE_HARD_LINE_BREAK</td>
<td align="left">指示是否启用硬性换行扩展</td>
</tr>
<tr>
<td align="left">CUSTOM_URL_SCHEMES</td>
<td align="left">允许被解析为链接的自定义 URL 方案，例如 git（用于 git://）和magnet（用于 magnet://）</td>
</tr>
<tr>
<td align="left">FILE_EXTENSIONS</td>
<td align="left">需要被渲染为 Markdown 格式的文件名后缀，通过逗号分隔。如果是无后缀名的文件，则单独放置一个逗号，例如：.markdown,</td>
</tr>
</tbody></table>
<p><strong>Smartypants (smartypants)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ENABLED</td>
<td align="left">指示是否启用 Smartypants 扩展</td>
</tr>
</tbody></table>
<p><strong>HTTP (http)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ACCESS_CONTROL_ALLOW_ORIGIN</td>
<td align="left">头信息 Access-Control-Allow-Origin 的自定义值，默认为空，即不响应此头信息</td>
</tr>
</tbody></table>
<p><strong>数据库 (database)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DB_TYPE</td>
<td align="left">数据库类型，可以是 mysql、postgres、mssql 或 sqlite3</td>
</tr>
<tr>
<td align="left">HOST</td>
<td align="left">数据库主机地址与端口</td>
</tr>
<tr>
<td align="left">NAME</td>
<td align="left">数据库名称</td>
</tr>
<tr>
<td align="left">USER</td>
<td align="left">数据库用户名</td>
</tr>
<tr>
<td align="left">PASSWD</td>
<td align="left">数据库用户密码</td>
</tr>
<tr>
<td align="left">SSL_MODE</td>
<td align="left">仅限 PostgreSQL 使用</td>
</tr>
<tr>
<td align="left">PATH</td>
<td align="left">仅限 SQLite3 使用，数据库文件路径</td>
</tr>
</tbody></table>
<p><strong>应用管理 (admin)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DISABLE_REGULAR_ORG_CREATION</td>
<td align="left">激活该选项来禁止普通用户（非管理员）创建组织</td>
</tr>
</tbody></table>
<p><strong>安全 (security)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INSTALL_LOCK</td>
<td align="left">用于指示是否允许访问安装页面（该页面可以设置管理员帐号，因此该选项非常重要）</td>
</tr>
<tr>
<td align="left">SECRET_KEY</td>
<td align="left">全局的加密密钥，务必修改该值以确保您的服务器安全（会在每次安装时自动生成随机字符串）</td>
</tr>
<tr>
<td align="left">LOGIN_REMEMBER_DAYS</td>
<td align="left">记住登录的天数</td>
</tr>
<tr>
<td align="left">COOKIE_USERNAME</td>
<td align="left">记录用户名的 Cookie 名称</td>
</tr>
<tr>
<td align="left">COOKIE_REMEMBER_NAME</td>
<td align="left">记录用户自动登录信息的 Cookie 名称</td>
</tr>
<tr>
<td align="left">REVERSE_PROXY_AUTHENTICATION_USER</td>
<td align="left">反向代理认证用户的 Header 字段名</td>
</tr>
</tbody></table>
<p><strong>服务 (service)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ACTIVE_CODE_LIVE_MINUTES</td>
<td align="left">激活码的有效期，单位为分钟</td>
</tr>
<tr>
<td align="left">RESET_PASSWD_CODE_LIVE_MINUTES</td>
<td align="left">重置密码的有效期，单位为分钟</td>
</tr>
<tr>
<td align="left">REGISTER_EMAIL_CONFIRM</td>
<td align="left">激活该选项来要求注册用户必须验证邮箱，要求已启用 Mailer</td>
</tr>
<tr>
<td align="left">DISABLE_REGISTRATION</td>
<td align="left">激活该选项来禁止用户注册功能，只能由管理员创建帐号</td>
</tr>
<tr>
<td align="left">SHOW_REGISTRATION_BUTTON</td>
<td align="left">用于指示是否显示注册按钮</td>
</tr>
<tr>
<td align="left">REQUIRE_SIGNIN_VIEW</td>
<td align="left">激活该选项来要求用户必须登录才能浏览任何页面</td>
</tr>
<tr>
<td align="left">ENABLE_CACHE_AVATAR</td>
<td align="left">激活该选项来缓存 Gravatar 的头像</td>
</tr>
<tr>
<td align="left">ENABLE_NOTIFY_MAIL</td>
<td align="left">激活该选项来发送通知邮件给关注者，例如创建 issue 时，要求已启用 Mailer</td>
</tr>
<tr>
<td align="left">ENABLE_REVERSE_PROXY_AUTHENTICATION</td>
<td align="left">激活该选项来开启反向代理用户认证，请从 #165 了解更多信息</td>
</tr>
<tr>
<td align="left">ENABLE_REVERSE_PROXY_AUTO_REGISTRATION</td>
<td align="left">激活该选项来开启反向代理用户认证的自动注册功能</td>
</tr>
<tr>
<td align="left">DISABLE_MINIMUM_KEY_SIZE_CHECK</td>
<td align="left">激活该选项来禁止检查响应类型的密钥最小长度</td>
</tr>
<tr>
<td align="left">ENABLE_CAPTCHA</td>
<td align="left">激活该选项以在用户注册时要求输入验证码</td>
</tr>
</tbody></table>
<p><strong>Web 钩子 (webhook)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TYPES</td>
<td align="left">启动的 Web 钩子类型，可以是 gogs、slack、discord或dingtalk</td>
</tr>
<tr>
<td align="left">QUEUE_LENGTH</td>
<td align="left">Web钩子队列长度，如果发现部分Webhook未能成功触发，可考虑增加该值</td>
</tr>
<tr>
<td align="left">DELIVER_TIMEOUT</td>
<td align="left">发送通知的超时时间，以秒为单位</td>
</tr>
<tr>
<td align="left">SKIP_TLS_VERIFY</td>
<td align="left">指示是否允许向具有非信任证书的地址发送通知</td>
</tr>
<tr>
<td align="left">PAGING_NUM</td>
<td align="left">Web 钩子历史页面每页显示记录条数</td>
</tr>
</tbody></table>
<p><strong>邮件 (mailer)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ENABLED</td>
<td align="left">启用该选项以激活邮件服务</td>
</tr>
<tr>
<td align="left">SUBJECT_PREFIX</td>
<td align="left">邮件标题的前缀</td>
</tr>
<tr>
<td align="left">HOST</td>
<td align="left">SMTP 主机地址与端口</td>
</tr>
<tr>
<td align="left">DISABLE_HELO</td>
<td align="left">禁用 HELO 操作</td>
</tr>
<tr>
<td align="left">HELO_HOSTNAME</td>
<td align="left">HELO 操作的自定义主机名</td>
</tr>
<tr>
<td align="left">SKIP_VERIFY</td>
<td align="left">不验证自签发证书的有效性</td>
</tr>
<tr>
<td align="left">FROM</td>
<td align="left">邮箱的来自地址，遵循 RFC 5322规范，可以是一个单纯的邮箱地址或者 “名字” <a href="mailto:&#101;&#x6d;&#x61;&#105;&#x6c;&#64;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#109;">&#101;&#x6d;&#x61;&#105;&#x6c;&#64;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#109;</a> 的形式</td>
</tr>
<tr>
<td align="left">USER</td>
<td align="left">邮箱用户名</td>
</tr>
<tr>
<td align="left">PASSWD</td>
<td align="left">邮箱密码</td>
</tr>
<tr>
<td align="left">USE_PLAIN_TEXT</td>
<td align="left">使用 text/plain 作为邮件内容格式</td>
</tr>
</tbody></table>
<p>备注：Gogs 仅支持使用 STARTTLS 的 SMTP 协议</p>
<p><strong>缓存 (cache)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ADAPTER</td>
<td align="left">缓存引擎适配器，可以为 memory、redis 或 memcache。如果您使用 redis 或 memcache，请确保使用 -tags 选项重新构建所有依赖，例如：go build -tags=’redis’</td>
</tr>
<tr>
<td align="left">INTERVAL</td>
<td align="left">仅限内存缓存使用，GC 周期，单位为秒</td>
</tr>
<tr>
<td align="left">HOST</td>
<td align="left">仅限 redis 和 memcache 使用，主机地址和端口号</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">Redis：network=tcp,addr=127.0.0.1:6379,password=macaron,db=0,pool_size=100,idle_timeout=180</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">Memache：127.0.0.1:9090;127.0.0.1:9091</td>
</tr>
</tbody></table>
<p><strong>会话 (session)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PROVIDER</td>
<td align="left">Session 引擎提供者，可以是 memory、file、redis 或 mysql</td>
</tr>
<tr>
<td align="left">PROVIDER_CONFIG</td>
<td align="left">如果提供者为 file，则为文件根目录；如果为其它提供者，则为主机地址和端口号</td>
</tr>
<tr>
<td align="left">COOKIE_SECURE</td>
<td align="left">激活该选项以要求所有 session 操作均通过 HTTPS</td>
</tr>
<tr>
<td align="left">GC_INTERVAL_TIME</td>
<td align="left">GC 周期，单位为秒</td>
</tr>
</tbody></table>
<p><strong>图片 (picture)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AVATAR_UPLOAD_PATH</td>
<td align="left">存放用户上传头像的目录</td>
</tr>
<tr>
<td align="left">GRAVATAR_SOURCE</td>
<td align="left">可以是 gravatar、duoshuo 或任何 URL，例如：<a href="http://cn.gravatar.com/avatar/">http://cn.gravatar.com/avatar/</a></td>
</tr>
<tr>
<td align="left">DISABLE_GRAVATAR</td>
<td align="left">激活该选项来仅使用本地头像</td>
</tr>
<tr>
<td align="left">ENABLE_FEDERATED_AVATAR</td>
<td align="left">激活该选项来启用 Federated 头像服务（<a href="http://www.libravatar.org),当/">http://www.libravatar.org），当</a> Gravatar 被禁用时此选项无法生效</td>
</tr>
</tbody></table>
<p><strong>附件 (attachment)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ENABLED</td>
<td align="left">激活该选项以允许用户上传附件</td>
</tr>
<tr>
<td align="left">PATH</td>
<td align="left">存放附件的路径</td>
</tr>
<tr>
<td align="left">ALLOWED_TYPES</td>
<td align="left">允许上传的 MIME 类型，例如 “image/jpeg</td>
</tr>
<tr>
<td align="left">MAX_SIZE</td>
<td align="left">最大允许上传的附件体积，单位为 MB，例如 4</td>
</tr>
<tr>
<td align="left">MAX_FILES</td>
<td align="left">最大允许一次性上传的附件个数，例如 5</td>
</tr>
</tbody></table>
<p><strong>时间 (time)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FORMAT</td>
<td align="left">指定日期的输出格式，默认为 RFC1123，其它可选的格式为 ANSIC、UnixDate、RubyDate、RFC822、RFC822Z、RFC850、RFC1123、RFC1123Z、RFC3339、RFC3339Nano、Kitchen、Stamp、StampMilli、StampMicro 和 StampNano。访问 <a href="http://golang.org/pkg/time/#pkg-constants">http://golang.org/pkg/time/#pkg-constants</a> 查看详情</td>
</tr>
</tbody></table>
<p><strong>日志 (log)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ROOT_PATH</td>
<td align="left">日志文件的根目录</td>
</tr>
<tr>
<td align="left">MODE</td>
<td align="left">日志记录模式，默认为 console。如果想要开启多模式，请使用逗号分割，例如：”console, file”</td>
</tr>
<tr>
<td align="left">LEVEL</td>
<td align="left">基本日志级别，默认为 Trace</td>
</tr>
</tbody></table>
<p><strong>日志 - 控制台 (log.console)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LEVEL</td>
<td align="left">控制台日志级别，留空则继承父值</td>
</tr>
</tbody></table>
<p><strong>日志 - 文件 (log.file)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LEVEL</td>
<td align="left">文件日志级别，留空则继承父值</td>
</tr>
<tr>
<td align="left">LOG_ROTATE</td>
<td align="left">激活该选项以启用日志文件自转</td>
</tr>
<tr>
<td align="left">DAILY_ROTATE</td>
<td align="left">激活该选项以进行日常自转</td>
</tr>
<tr>
<td align="left">MAX_SIZE_SHIFT</td>
<td align="left">自转需要达到的最大文件体积，使用位左移，默认为 28 即 1 &lt;&lt; 28，表示 256MB</td>
</tr>
<tr>
<td align="left">MAX_LINES</td>
<td align="left">自转需要达到的最大文件行数，默认为 1000000</td>
</tr>
<tr>
<td align="left">MAX_DAYS</td>
<td align="left">保留自转文件的最长期限，默认为 7 天后删除</td>
</tr>
</tbody></table>
<p><strong>日志 - Slack (log.slack)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LEVEL</td>
<td align="left">Slack 日志级别，留空则继承父值</td>
</tr>
<tr>
<td align="left">URL</td>
<td align="left">Slack Web 钩子 URL</td>
</tr>
</tbody></table>
<p><strong>日志 - Discord (log.discord)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LEVEL</td>
<td align="left">Discord 日志级别，留空则继承父值</td>
</tr>
<tr>
<td align="left">URL</td>
<td align="left">Discord Web 钩子 URL</td>
</tr>
<tr>
<td align="left">USERNAME</td>
<td align="left">在 Web 钩子中显示的用户名</td>
</tr>
</tbody></table>
<p><strong>Cron (cron)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ENABLED</td>
<td align="left">激活该选项以允许周期性运行 Cron 任务</td>
</tr>
<tr>
<td align="left">RUN_AT_START</td>
<td align="left">激活该选项以允许在启动时执行 Cron 任务</td>
</tr>
</tbody></table>
<p><strong>Cron - 更新镜像 (cron.update_mirrors)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SCHEDULE</td>
<td align="left">定时更新仓库镜像的 Cron 语法，例如：@every 1h</td>
</tr>
</tbody></table>
<p><strong>Cron - 仓库健康检查 (cron.repo_health_check)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SCHEDULE</td>
<td align="left">定时进行仓库健康检查的 Cron 语法，例如：@every 24h</td>
</tr>
<tr>
<td align="left">TIMEOUT</td>
<td align="left">仓库健康检查超时的定义语法，例如：60s</td>
</tr>
<tr>
<td align="left">ARGS</td>
<td align="left">git fsck 命令的参数，例如：–unreachable –tags</td>
</tr>
</tbody></table>
<p><strong>Cron - 仓库统计检查 (cron.check_repo_stats)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RUN_AT_START</td>
<td align="left">激活该选项以在启动时执行仓库统计检查</td>
</tr>
<tr>
<td align="left">SCHEDULE</td>
<td align="left">定时进行仓库统计检查的 Cron 语法，例如：@every 24h</td>
</tr>
</tbody></table>
<p><strong>Cron - 仓库归档清理 (cron.repo_archive_cleanup)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RUN_AT_START</td>
<td align="left">激活该选项以在启动时执行仓库归档清理</td>
</tr>
<tr>
<td align="left">SCHEDULE</td>
<td align="left">定时进行仓库归档清理的 Cron 语法，例如：@every 24h</td>
</tr>
<tr>
<td align="left">OLDER_THAN</td>
<td align="left">仓库归档的文件有效期，过期的归档将被清理，例如：24h</td>
</tr>
</tbody></table>
<p><strong>Git (git)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DISABLE_DIFF_HIGHLIGHT</td>
<td align="left">激活该选项以禁用行内差异高亮</td>
</tr>
<tr>
<td align="left">MAX_GIT_DIFF_LINES</td>
<td align="left">差异对比页面单个文件显示的最大行数</td>
</tr>
<tr>
<td align="left">MAX_GIT_DIFF_LINE_CHARACTERS</td>
<td align="left">差异对比页面单行显示的最大字符数</td>
</tr>
<tr>
<td align="left">MAX_GIT_DIFF_FILES</td>
<td align="left">差异对比页面文件显示的最多个数</td>
</tr>
<tr>
<td align="left">GC_ARGS</td>
<td align="left">git gc 命令的参数，例如：–aggressive –auto</td>
</tr>
</tbody></table>
<p><strong>Git - 超时 (git.timeout)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MIGRATE</td>
<td align="left">仓库迁移操作超时，默认为 600 秒</td>
</tr>
<tr>
<td align="left">MIRROR</td>
<td align="left">仓库镜像同步操作超时，默认为 300 秒</td>
</tr>
<tr>
<td align="left">CLONE</td>
<td align="left">仓库克隆操作超时，默认为 300 秒</td>
</tr>
<tr>
<td align="left">PULL</td>
<td align="left">仓库拉取操作超时，默认为 300 秒</td>
</tr>
<tr>
<td align="left">GC</td>
<td align="left">仓库垃圾回收操作超时，默认为 60 秒</td>
</tr>
</tbody></table>
<p><strong>UI (ui)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">EXPLORE_PAGING_NUM</td>
<td align="left">探索页面每页显示仓库的数量</td>
</tr>
<tr>
<td align="left">ISSUE_PAGING_NUM</td>
<td align="left">每页显示工单（Issue）的数量（应用到所有以列表形式显示工单的页面）</td>
</tr>
<tr>
<td align="left">FEED_MAX_COMMIT_NUM</td>
<td align="left">一条最新活动中显示代码提交（Commit）的最大数量</td>
</tr>
<tr>
<td align="left">THEME_COLOR_META_TAG</td>
<td align="left">被用于 Android &gt;= 5.0 版本 “theme-color” 标记的值，无效的值将被忽略并使用默认值（查看详情）</td>
</tr>
<tr>
<td align="left">MAX_DISPLAY_FILE_SIZE</td>
<td align="left">显示到页面的最大文件体积（Byte）</td>
</tr>
</tbody></table>
<p><strong>UI - Admin (ui.admin)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">USER_PAGING_NUM</td>
<td align="left">用户管理页面每页显示记录条数</td>
</tr>
<tr>
<td align="left">REPO_PAGING_NUM</td>
<td align="left">仓库管理页面每页显示记录条数</td>
</tr>
<tr>
<td align="left">NOTICE_PAGING_NUM</td>
<td align="left">系统提示管理页面每页显示记录条数</td>
</tr>
<tr>
<td align="left">ORG_PAGING_NUM</td>
<td align="left">组织管理页面每页显示记录条数</td>
</tr>
</tbody></table>
<p><strong>Prometheus (prometheus)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ENABLED</td>
<td align="left">激活该选项以启用 Prometheus 监控信息，默认为 true</td>
</tr>
<tr>
<td align="left">ENABLE_BASIC_AUTH</td>
<td align="left">激活该选项以启用 HTTP 基本认证保护监控信息数据，默认为 false</td>
</tr>
<tr>
<td align="left">BASIC_AUTH_USERNAME</td>
<td align="left">HTTP 基本认证的用户名</td>
</tr>
<tr>
<td align="left">BASIC_AUTH_PASSWORD</td>
<td align="left">HTTP 基本认证的密码</td>
</tr>
</tbody></table>
<p><strong>其他 (other)</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHOW_FOOTER_BRANDING</td>
<td align="left">激活该选项以在页脚显示 Gogs 推广信息</td>
</tr>
<tr>
<td align="left">SHOW_FOOTER_VERSION</td>
<td align="left">激活该选项以在页脚显示 Gogs 版本信息</td>
</tr>
<tr>
<td align="left">SHOW_FOOTER_TEMPLATE_LOAD_TIME</td>
<td align="left">激活该选项以在页脚显示 Gogs 模板加载时间</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>学习笔记</tag>
        <tag>Gogs</tag>
        <tag>自查手册</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + GitHub Pages搭建个人博客网站</title>
    <url>/2021/04/05/Hexo-GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h3 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了如何利用 Hexo 和 Github Pages 快速搭建个人博客网站的整个过程。以下代码均已我的博客和仓库为例，请自行更改为自己的。</p>
<p>中文官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<span id="more"></span>

<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h4><p>官网地址：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a><br>选择相应版本安装后分别执行<code>node -v</code>和<code>npm -v</code>查看是否正确安装。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; node -v</span><br><span class="line">v12.16.2</span><br><span class="line">&gt; npm -v</span><br><span class="line">6.14.4</span><br></pre></td></tr></table></figure>

<h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h4><p>官网地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>同样在安装好后检查安装的版本信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; git --version</span><br><span class="line">git version 2.29.2.windows.2</span><br></pre></td></tr></table></figure>

<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>全局安装<code>hexo-cli</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>检查 Hexo 版本，会得到以下输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; hexo -v</span><br><span class="line">hexo-cli: 4.2.0</span><br><span class="line">os: Windows_NT 10.0.18363 win32 x64</span><br><span class="line">node: 12.16.2</span><br><span class="line">v8: 7.8.279.23-node.34</span><br><span class="line">uv: 1.34.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.15.0</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.40.0</span><br><span class="line">napi: 5</span><br><span class="line">llhttp: 2.0.4</span><br><span class="line">http_parser: 2.9.3</span><br><span class="line">openssl: 1.1.1e</span><br><span class="line">cldr: 36.0</span><br><span class="line">icu: 65.1</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 12.1</span><br></pre></td></tr></table></figure>

<p>然后依次执行以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; mkdir myBlog <span class="comment"># 创建一个空的博客文件夹</span></span><br><span class="line">&gt; <span class="built_in">cd</span> myBlog <span class="comment"># 进入到博客文件夹中</span></span><br><span class="line">&gt; hexo init <span class="comment"># 使用 hexo init 命令下在 Hexo 项目初始化文件</span></span><br><span class="line">&gt; npm install <span class="comment"># 下载 Hexo 项目的第三方依赖</span></span><br></pre></td></tr></table></figure>

<p>最后得到的文件目录如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">文件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_config.yml</td>
<td align="left">网站配置文件</td>
</tr>
<tr>
<td align="left">package.json</td>
<td align="left">项目配置文件</td>
</tr>
<tr>
<td align="left">scaffolds</td>
<td align="left">模板文件夹</td>
</tr>
<tr>
<td align="left">source</td>
<td align="left">资源文件夹</td>
</tr>
<tr>
<td align="left">themes</td>
<td align="left">主题文件夹</td>
</tr>
</tbody></table>
<p>本地预览</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; hexo generate</span><br><span class="line">&gt; hexo server</span><br></pre></td></tr></table></figure>

<p>在浏览器中访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可查看网站默认样式。</p>
<h4 id="关联-GitHub-仓库"><a href="#关联-GitHub-仓库" class="headerlink" title="关联 GitHub 仓库"></a>关联 GitHub 仓库</h4><ul>
<li>创建仓库</li>
</ul>
<p>在 GitHub 中创建一个同名仓库，命名为<code>coley48.github.io</code>，这也将成为网站的域名。</p>
<ul>
<li>配置 Git</li>
</ul>
<p>如果初次使用 Git，需要设置用户名和邮箱。打开 Git Bash，设置全局用户名和邮箱。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name coley48</span><br><span class="line">$ git config --global user.email coley48@qq.com</span><br></pre></td></tr></table></figure>

<p>查看用户名和邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config user.name &amp;&amp; git config user.email</span><br><span class="line">coley48</span><br><span class="line">coley48@qq.com</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 SSH 密钥</li>
</ul>
<p><code>ssh</code>还可以设置密码，通常方便起见，这里不设置密码，全部回车。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;coley48@qq.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认创建在用户文件夹下的<code>.ssh</code>文件夹中，查看生成的密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh &amp;&amp; ls</span><br><span class="line">id_rsa  id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>其中<code>id_rsa</code>是私钥，<code>id_rsa.pub</code>是公钥，用于上传到 GitHub。</p>
<p>将<code>ssh key</code>关联到 GitHub 账号<br>在 Git Bash 中复制<code>id_rsa.pub</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat id_rsa.pub &gt; /dev/clipboard</span><br></pre></td></tr></table></figure>

<p>或在 cmd 终端中复制<code>id_rsa.pub</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; clip &lt; id_rsa.pub</span><br></pre></td></tr></table></figure>

<ul>
<li>添加 SSH 密钥</li>
</ul>
<p>在 <a href="https://github.com/settings/keys">https://github.com/settings/keys</a> 页面中选择<code>New SSH key</code>新建<code>ssh key</code>，标题自定义，然后将上一步复制的公钥粘贴进去，点击<code>Add SSH key</code>完成添加。</p>
<img src="/2021/04/05/Hexo-GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/%E6%B7%BB%E5%8A%A0ssh-key.png" class="">

<ul>
<li>测试 SSH 连接</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Warning: Permanently added the RSA host key <span class="keyword">for</span> IP address <span class="string">&#x27;192.30.255.113&#x27;</span> to the list of known hosts.</span><br><span class="line">Hi Coley48! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

<p>GitHub文档：<a href="https://docs.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh">使用 SSH 连接到 GitHub</a></p>
<ul>
<li>Hexo 一键部署</li>
</ul>
<p>一键部署功能是在本地编辑完成之后，直接使用<code>hexo deploy</code>命令就可以完成部署操作。</p>
<p>一键部署功能需要安装 Hexo 的部署插件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后修改_config.yml，为 Hexo 指定部署的 Github 仓库：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/Coley48/coley48.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>之后就可以使用以下命令更新网站：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; hexo clean <span class="comment"># 清除之前生成的静态文件，不是必须的</span></span><br><span class="line">&gt; hexo generate <span class="comment"># 生成静态网页文件</span></span><br><span class="line">&gt; hexo deploy <span class="comment"># 部署到远程仓库</span></span><br></pre></td></tr></table></figure>

<ul>
<li>绑定个人域名</li>
</ul>
<p>GitHub Pages还提供 Custom Domain 可以使用自定义域名。</p>
<ol>
<li>在域名解析控制台添加 CNAME 解析记录，将 coley48.github.io 解析到 blog.coley48.cn。</li>
<li>同时在 github.io 仓库中设置 Custom Domain 为 blog.coley48.cn。</li>
<li>然后在 /source 文件夹下创建一个 CNAME 文本文件，存放域名。</li>
<li>最后重新生成部署一下网站，稍微等待片刻便可以通过自己的域名访问博客网站了。</li>
</ol>
<p>Github文档：<a href="https://docs.github.com/cn/pages/configuring-a-custom-domain-for-your-github-pages-site">配置 GitHub Pages 站点的自定义域</a></p>
<h3 id="Hexo-基本配置"><a href="#Hexo-基本配置" class="headerlink" title="Hexo 基本配置"></a>Hexo 基本配置</h3><p>Hexo的所有配置都在_config.yml文件中，部分配置如下：</p>
<table>
<thead>
<tr>
<th align="right">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="right">title</td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="right">subtitle</td>
<td align="left">网站副标题，可以放座右铭</td>
</tr>
<tr>
<td align="right">description</td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="right">keywords</td>
<td align="left">网站的关键词</td>
</tr>
<tr>
<td align="right">author</td>
<td align="left">作者名字</td>
</tr>
<tr>
<td align="right">language</td>
<td align="left">网站使用的语言</td>
</tr>
<tr>
<td align="right">url</td>
<td align="left">网址，必须是完整的url</td>
</tr>
<tr>
<td align="right">post_asset_folder</td>
<td align="left">启动 Asset 文件夹，默认false</td>
</tr>
<tr>
<td align="right">relative_link</td>
<td align="left">把链接改为与根目录的相对位址，默认false</td>
</tr>
<tr>
<td align="right">theme</td>
<td align="left">设置主题，false禁用主题</td>
</tr>
<tr>
<td align="right">theme_config</td>
<td align="left">主题的配置参数，优先级高</td>
</tr>
<tr>
<td align="right">deploy</td>
<td align="left">部署配置</td>
</tr>
</tbody></table>
<p>更多配置详见<a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a></p>
<h3 id="Hexo-的基本使用"><a href="#Hexo-的基本使用" class="headerlink" title="Hexo 的基本使用"></a>Hexo 的基本使用</h3><ul>
<li>初始化</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; hexo init [folder]</span><br></pre></td></tr></table></figure>

<p>新建网站，未指定 folder 时在当前文件夹下创建。<br>创建步骤：</p>
<ol>
<li>git 下载包含 hexo-theme-landscape 主题的 hexo-starter 项目。</li>
<li>通过包管理工具安装依赖，默认使用 npm。</li>
</ol>
<ul>
<li>新建</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>新建文章，<code>layout</code>默认使用<code>_config.yml</code>中<code>default_layout</code>参数值，包含空格的标题需要加引号。三种布局：<code>post</code>、<code>page</code>、<code>draft</code>。<br>参数：<br><code>-p, --path</code> 自定义文章的路径，默认使用标题作为文章路径。<br><code>-r, --replace</code> 替换同名文章。<br><code>-s, --slug</code> 作为新文章的文件名和发布后的 URL。</p>
<ul>
<li>生成</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; hexo generate/g</span><br></pre></td></tr></table></figure>

<p>生成网页，将生成的文件放入<code>public</code>文件夹下，如果存在<code>public</code>，默认只生成改动的文件。<br>参数：<br><code>-d, --deploy</code> 文件生成后立即部署网站。<br><code>-w, --watch</code> 监视文件变动。<br><code>-b, --bail</code> 生成过程中如果发生任何未处理的异常则爆出异常。<br><code>-f, --force</code> 强制重新生成文件，等同于<code>hexo clean &amp;&amp; hexo generate</code>。<br><code>-c, --concurrency</code> 设置最大同时生成文件的数量，默认无限制。<br><code>--config &lt;custom.yml&gt; [config.json]</code> 使用自定义配置文件。</p>
<ul>
<li>发布</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>发表草稿。</p>
<ul>
<li>本地预览</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; hexo server/s</span><br></pre></td></tr></table></figure>

<p>启动服务器。默认情况下，网址为：<a href="http://localhost:4000/">http://localhost:4000</a>。<br>参数：<br><code>-p, --port</code> 设置端口。<br><code>-s, --static</code> 只使用静态文件。<br><code>-l, --log</code> 启动日志记录，使用覆盖记录格式。<br><code>--config &lt;custom.yml&gt;</code> 使用自定义配置文件。</p>
<ul>
<li>部署</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; hexo deploy/d</span><br></pre></td></tr></table></figure>

<p>部署网站<br><code>-g, --generate</code> 部署之前预先生成静态文件，等同于<code>hexo g -d</code>。</p>
<ul>
<li>清除</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; hexo clean</span><br></pre></td></tr></table></figure>

<p>清除缓存文件<code>db.json</code>和已生成的静态文件夹<code>public</code>。</p>
<p>更多命令详见<a href="https://hexo.io/zh-cn/docs/commands">官方文档</a>。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a></li>
<li><a href="https://www.cnblogs.com/michael-xiang/p/10464518.html">Hexo 搭建 Blog 精简笔记</a></li>
<li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.baidujs&dist_request_id=1328741.37347.16169781187402753&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.baidujs">Hexo 史上最全搭建教程</a></li>
<li><a href="http://www.xinxiaoyang.com/programming/2016-11-25-hexo-image-bug/">Hexo 图片插入</a></li>
<li><a href="https://www.mls-tech.info/hexo/hexo-use-internal-link/">如何在Hexo的博文中引用自己的文章</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML 语言教程</a></li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next主题的配置和优化</title>
    <url>/2021/04/14/Hexo-Next%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="Next-简介"><a href="#Next-简介" class="headerlink" title="Next 简介"></a>Next 简介</h3><p>Next 是 Hexo 最受欢迎的主题之一，而且在 Next 之下还分为4个<code>scheme</code>。可以根据个人喜好来设置相应的<code>scheme</code>。</p>
<img src="/2021/04/14/Hexo-Next%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/Next-theme.png" class="">

<p>官方文档：<a href="https://theme-next.js.org/">https://theme-next.js.org/</a><br>GitHub 地址：<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></p>
<span id="more"></span>

<h3 id="Next-安装"><a href="#Next-安装" class="headerlink" title="Next 安装"></a>Next 安装</h3><p>进入到博客根目录下，将主题项目下载到<code>themes/</code>文件夹下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> myBlog</span><br><span class="line">&gt; git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>然后打开根目录下的<code>_config.yml</code>配置文件，即网站配置文件，将其中的主题选项，参数改为<code>next</code>即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<h3 id="Next-配置"><a href="#Next-配置" class="headerlink" title="Next 配置"></a>Next 配置</h3><p>这里有两种方式配置 Next 主题，一是更改<code>/themes/next/</code>文件夹下的<code>_config.yml</code>，即主题配置文件；二是在网站配置文件中添加一个 <code>theme_config</code>属性，然后在该属性后面添加配置参数。</p>
<p>这里推荐使用第二种方式，因为网站配置文件中<code>theme_config</code>下参数优先级高于主题配置文件，因此会覆盖主题配置文件，同时不用更改 Next 主题源码，当 Next 主题更新时也不需要再修改主题配置文件。</p>
<p>以我的博客为例，主题配置部分如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span> </span><br><span class="line">  <span class="comment"># 页面底部设置</span></span><br><span class="line">  <span class="attr">footer:</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="comment"># 设置年份和版权信息</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span> <span class="comment"># 默认心形，也可以设置 Font Awessome 中的其他图标 </span></span><br><span class="line">      <span class="comment"># https://fontawesome.com/icons</span></span><br><span class="line">      <span class="attr">animated:</span> <span class="literal">true</span> <span class="comment"># 添加动画，默认 false</span></span><br><span class="line">      <span class="attr">color:</span> <span class="string">&quot;#fc6423&quot;</span> <span class="comment"># 使用十六进制设置图标颜色</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">powered:</span> <span class="literal">false</span> <span class="comment"># 是否显示 Powered by Hexo &amp; NexT</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2021</span> <span class="comment"># 设置建站时间</span></span><br><span class="line">    <span class="attr">copyright:</span> <span class="string">Hush</span> <span class="comment"># 设置版权归属</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 文章协议</span></span><br><span class="line">  <span class="attr">creative_commons:</span></span><br><span class="line">    <span class="attr">license:</span> <span class="string">by-nc-sa</span> <span class="comment"># 协议名</span></span><br><span class="line">    <span class="attr">sidebar:</span> <span class="literal">false</span> <span class="comment"># 是否显示在侧栏</span></span><br><span class="line">    <span class="attr">post:</span> <span class="literal">true</span> <span class="comment"># 是否显示在文章中</span></span><br><span class="line">    <span class="attr">language:</span> <span class="comment"># 选择语言</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 主题方案</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">Gemini</span> <span class="comment"># 选择主题方案，默认 Muse</span></span><br><span class="line">  <span class="comment"># Muse | Mist | Pisces | Geminim</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 菜单栏页面设置</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span> <span class="comment"># 主页</span></span><br><span class="line">    <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span> <span class="comment"># 关于</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span> <span class="comment"># 标签</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span> <span class="comment"># 分类</span></span><br><span class="line">    <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span> <span class="comment"># 归档</span></span><br><span class="line">    <span class="comment">#schedule: /schedule/ || fa fa-calendar # 计划</span></span><br><span class="line">    <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap # 站点地图</span></span><br><span class="line">    <span class="comment"># commonweal: /404/ || fa fa-heartbeat # 公益404</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 头像设置</span></span><br><span class="line">  <span class="attr">avatar:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/images/avator.jpg</span> <span class="comment"># 设置头像路径</span></span><br><span class="line">    <span class="attr">rounded:</span> <span class="literal">true</span> <span class="comment"># 头像圆角</span></span><br><span class="line">    <span class="attr">rotated:</span> <span class="literal">true</span> <span class="comment"># 头像旋转效果</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 社交设置</span></span><br><span class="line">  <span class="attr">social:</span></span><br><span class="line">    <span class="attr">GitHub:</span> <span class="string">https://github.com/Coley48</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span> <span class="comment"># GitHub</span></span><br><span class="line">    <span class="attr">E-Mail:</span> <span class="string">mailto:coley48@qq.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span> <span class="comment"># 邮箱</span></span><br><span class="line">    <span class="comment"># Weibo | Google | Twitter | FB Page | StackOverflow |  YouTube</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 打赏功能设置</span></span><br><span class="line">  <span class="attr">reward_settings:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 是否开启打赏功能</span></span><br><span class="line">    <span class="attr">animation:</span> <span class="literal">false</span> <span class="comment"># 打赏功能动画效果</span></span><br><span class="line">    <span class="comment">#comment: Donate comment here. # 设置打赏语</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 打赏方式设置</span></span><br><span class="line">  <span class="attr">reward:</span></span><br><span class="line">    <span class="comment">#wechatpay: /images/wechatpay.png</span></span><br><span class="line">    <span class="comment">#alipay: /images/alipay.png</span></span><br><span class="line">    <span class="comment">#paypal: /images/paypal.png</span></span><br><span class="line">    <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 代码块设置</span></span><br><span class="line">  <span class="attr">codeblock:</span></span><br><span class="line">    <span class="attr">highlight_theme:</span> <span class="string">normal</span> <span class="comment"># 高亮主题 </span></span><br><span class="line">    <span class="comment"># normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">    <span class="attr">copy_button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启一键复制功能</span></span><br><span class="line">      <span class="attr">show_result:</span> <span class="literal">true</span> <span class="comment"># 显示复制成功结果</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">mac</span> <span class="comment"># 三种显示效果 default | flat | mac</span></span><br><span class="line">    <span class="attr">beian:</span> <span class="comment"># 备案</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">icp:</span> <span class="string">蜀ICP备</span> <span class="number">20003974</span><span class="number">-1</span><span class="string">号</span></span><br><span class="line">      <span class="comment"># gongan_id: 1234567890</span></span><br><span class="line">      <span class="comment"># gongan_num: 京公网安备 1234567890号</span></span><br><span class="line">      <span class="comment"># gongan_icon_url: /uploads/beian.png</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 回顶部按钮</span></span><br><span class="line">  <span class="attr">back2top:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启</span></span><br><span class="line">    <span class="attr">sidebar:</span> <span class="literal">true</span> <span class="comment"># 在侧栏显示</span></span><br><span class="line">    <span class="attr">scrollpercent:</span> <span class="literal">true</span> <span class="comment"># 显示百分比</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 阅读进度条</span></span><br><span class="line">  <span class="attr">reading_progress:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">top</span> <span class="comment"># 显示位置 top | bottom</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span> <span class="comment"># 进度条颜色</span></span><br><span class="line">    <span class="attr">height:</span> <span class="string">3px</span> <span class="comment"># 进度条宽度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line">  <span class="attr">github_banner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否显示</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="string">https://github.com/Coley48</span> <span class="comment"># GitHub 地址</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Local Search 本地搜索</span></span><br><span class="line">  <span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line">  <span class="attr">local_search:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">trigger:</span> <span class="string">auto</span> <span class="comment"># 搜索结果显示方式，auto 内容更改显示；manual 手动回车显示</span></span><br><span class="line">    <span class="attr">top_n_per_article:</span> <span class="number">1</span> <span class="comment"># 设置显示条数，-1 为显示所有</span></span><br><span class="line">    <span class="attr">unescape:</span> <span class="literal">false</span> <span class="comment"># 反转义 html 字符串</span></span><br><span class="line">    <span class="attr">preload:</span> <span class="literal">false</span> <span class="comment"># 页面加载时预加载搜索数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 添加友链</span></span><br><span class="line">  <span class="attr">links:</span></span><br><span class="line">    <span class="comment"># Title: http://site.com</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更多配置详见：<a href="http://theme-next.iissnan.com/">Next 使用文档</a>。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://jiyali.github.io/2019/04/15/hexo-next-%E9%83%A8%E7%BD%B2%E5%90%84%E7%A7%8D%E7%82%AB%E9%85%B7%E5%8D%9A%E5%AE%A2%E7%89%B9%E6%95%88/">hexo+next 部署各种炫酷博客特效</a></li>
<li><a href="https://io-oi.me/tech/hexo-next-optimization/">打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化</a></li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX环境搭建和配置教程</title>
    <url>/2021/10/10/LaTeX%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="关于-LaTeX"><a href="#关于-LaTeX" class="headerlink" title="关于 LaTeX"></a>关于 LaTeX</h3><blockquote>
<p>LaTeX is not a stand-alone typesetting program in itself, but document preparation software that runs on top of Donald E. Knuth’s TeX typesetting system. </p>
</blockquote>
<p>LaTeX 不是一个独立运行的排版程序，LaTeX 运行在高德纳 (Donald E. Knuth) 开发的、以排版文字和数学公式为目的的排版软件上。LaTeX 使用 TEX 作为它的排版引擎，可以粗略的把 LaTeX 理解为对 TeX 的一层封装。</p>
<p>本文主要记录了 LaTeX 环境搭建以及配置的过程。</p>
<span id="more"></span>

<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>LaTeX 还有很多编辑器，如 TeXworks、TexStudio、WinEdt、MiKtex、protex等等。因为 TeX Live 同 VS Code 一样是开源免费的，且跨平台的工具；且维护更新都比较快；因此我选用 TeX Live 和 VS Code 搭建 LaTeX 的编译环境。</p>
<h4 id="安装-tex-Live"><a href="#安装-tex-Live" class="headerlink" title="安装 tex Live"></a>安装 tex Live</h4><p>这里只记录一下大致的安装步骤，详细带图的安装步骤可以参考<a href="https://zhuanlan.zhihu.com/p/41855480">最新TeXLive 环境的安装与配置</a>；</p>
<ol>
<li>从<a href="https://www.tug.org/texlive/">TeX Live 官网</a>或者<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">清华镜像源</a>下载 TeX Lsive 文件；</li>
<li>打开下载好的 iso 文件，找到文件夹下的<code>install-tl-windows.bat</code>，右键以管理员身份运行，就会看到安装的界面；</li>
<li>在安装界面中，修改一下安装的目录，去掉安装texwork前端界面选项，然后在高级选项中只保留中文，之后点击安装；</li>
<li>安装的时间稍微有点长，最后看到欢迎字样时，表示安装完成，可以直接关闭；</li>
<li>在命令行中输入<code>xelatex -v</code>命令测试，会有很多版本信息出现，表示安装成功；</li>
</ol>
<img src="/2021/10/10/LaTeX%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/TeX-Live%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png" class="">

<h4 id="配置-VS-Code"><a href="#配置-VS-Code" class="headerlink" title="配置 VS Code"></a>配置 VS Code</h4><p>这里省略 VS Code 安装步骤，详细安装配置以及配置项说明可以参考<a href="https://zhuanlan.zhihu.com/p/166523064">Visual Studio Code 配置LaTeX</a>；</p>
<ol>
<li>安装插件 LaTeX Workshop；</li>
<li>在<code>setting.json</code>设置中添加一下配置；</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.autoBuild.run&quot;</span>: <span class="string">&quot;never&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;latex-workshop.showContextMenu&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;latex-workshop.intellisense.package.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;latex-workshop.message.error.show&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;latex-workshop.message.warning.show&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.tools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;latexmk&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;latexmk&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-pdf&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-outdir=%OUTDIR%&quot;</span>,</span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.recipes&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;XeLaTeX&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;PDFLaTeX&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;BibTeX&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;bibtex&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;LaTeXmk&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;latexmk&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">                <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">                <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;*.aux&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.bbl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.blg&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.idx&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.ind&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.lof&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.lot&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.out&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.toc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.acn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.acr&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.alg&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.glg&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.glo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.gls&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.ist&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.fls&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.log&quot;</span>,</span><br><span class="line">        <span class="string">&quot;*.fdb_latexmk&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.autoClean.run&quot;</span>: <span class="string">&quot;onFailed&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.recipe.default&quot;</span>: <span class="string">&quot;lastUsed&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;</span>: <span class="string">&quot;double-click&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ol>
<li>新建 tex 文件；</li>
<li>切换到右侧的 tex 栏；</li>
<li>选择构建方式<code>xelatex -&gt; bibtex -&gt; xelatex*2</code>；</li>
<li>编译后文件夹下会生成 pdf 文件和很多其他文件；</li>
</ol>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">Hello, <span class="keyword">\LaTeX</span>!</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/10/10/LaTeX%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/hello-latex.png" class="">

<p>在 VS Code 中可以使用快捷键：<br><code>Ctrl</code>+<code>Alt</code>+<code>b</code>：编译输出当前编辑的 tex 文件；<br><code>Ctrl</code>+<code>Alt</code>+<code>v</code>：预览当前编辑的 tex 文件输出的 pdf 文件；</p>
<p>主要的编译器：</p>
<ul>
<li>latex 虽然名为 latex 命令，底层调用的引擎其实是 pdfTEX。该命令生成 dvi（Device Indexpendent）格式的文档，用 dvipdfmx 命令可以将其转为 pdf。</li>
<li>pdflatex 底层调用的引擎也是 pdfTEX，可以直接生成 pdf 格式的文档。</li>
<li>xelatex 底层调用的引擎是 XƎTEX，支持 UTF-8 编码和 TrueType / OpenType 字体。当前较为方便的中文排版解决方案基于 xelatex。</li>
<li>lualatex 底层调用的引擎是 LuaTEX，这个引擎在 pdfTEX 引擎基础上发展而来，除了支持 UTF-8 编码和 TrueType / OpenType 字体外，还支持通过 Lua 语言扩展 TEX 的功能。lualatex 编译命令下的中文排版支持需要借助 luatex-ja 宏包。</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://www.latex-project.org/">LaTeX 官网</a></li>
<li><a href="https://www.tug.org/texlive/">TeX Live 官网</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">TeX Live 清华镜像源</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/41855480">最新TeXLive 环境的安装与配置</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/166523064">Visual Studio Code 配置LaTeX</a></li>
<li><a href="https://www.overleaf.com/">overleaf 在线编辑工具</a></li>
<li><a href="https://www.sharelatex.com/">ShareLaTeX 在线编辑工具</a></li>
<li><a href="https://www.tablesgenerator.com/">LaTeX 表格在线生成工具</a></li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>文字排版</tag>
      </tags>
  </entry>
  <entry>
    <title>Travis CI + GitHub Pages自动部署Hexo博客</title>
    <url>/2021/04/15/Travis-CI-GitHub-Pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="什么是持续集成？"><a href="#什么是持续集成？" class="headerlink" title="什么是持续集成？"></a>什么是持续集成？</h3><p>持续集成（Continuous Integration，简称 CI）指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码“集成”到主干。</p>
<p>持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p>
<p>Travis CI 提供的是持续集成服务。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。</p>
<p>本文记录了利用 Travis CI 搭建自动部署的 Hexo 博客系统的整个过程。</p>
<span id="more"></span>

<h3 id="Travis-CI-的使用"><a href="#Travis-CI-的使用" class="headerlink" title="Travis CI 的使用"></a>Travis CI 的使用</h3><h4 id="创建-token"><a href="#创建-token" class="headerlink" title="创建 token"></a>创建 token</h4><ol>
<li><p>进入配置页面，先在 Github 的设置页面中找到 Developer settings，点进入后选择第三条 Personal access tokens，或者直接点击<a href="https://github.com/settings/tokens">这个链接</a>跳转配置页面。</p>
</li>
<li><p>生成密钥，点击右上 Generate new token 按钮，可能会需要输入密码验证一下用户身份，然后填写 token 名称用于标识该 token 的用途，然后在下方为 token 设置权限，这里只需要添加 repo 即可。</p>
<img src="/2021/04/15/Travis-CI-GitHub-Pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/%E7%94%9F%E6%88%90personal-access-token.png" class="">
<p>这里需要注意的是，密钥只会在第一次生成时可见，页面刷新后就无法查看密钥的值，因此创建后需要立即保存，否则只能重新生成。</p>
</li>
<li><p>添加密钥，进入 Travis CI 官网 <a href="https://travis-ci.com/">travis-ci.com</a>，首次进入需要通过 Github 来进行仓库的授权访问，完成之后会进入到自己的控制面板，这里可以看到自己 GitHub 上的所有仓库，然后进入需要部署的仓库的 setting 页面，在这里添加环境变量，变量名设置为 GH_TOKEN ，变量值为上一步骤中保存的哈希值。</p>
<img src="/2021/04/15/Travis-CI-GitHub-Pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/%E6%B7%BB%E5%8A%A0token%E5%88%B0Travis-CI%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" class="">
<p>切记不要点开 DISPLAY VALUE IN BUILD LOG 选项，否则 token 值会输出到构建日志中，就会暴露给别人。</p>
</li>
</ol>
<h4 id="添加travis-yml"><a href="#添加travis-yml" class="headerlink" title="添加travis.yml"></a>添加<code>travis.yml</code></h4><p>Travis CI 的的部署极其简单，只用在项目根目录中添加一个<code>travis.yml</code>配置文件，该文件指定了所有 Travis CI 的构建和部署行为。</p>
<p>下面以我的 Hexo 博客项目为例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">os:</span> <span class="string">linux</span> <span class="comment"># 选择构建的操作系统</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span> <span class="comment"># 项目语言</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span>  <span class="comment"># 使用 nodejs LTS v10</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># 只监控存放源代码的 main 分支</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span> <span class="comment"># 缓存 node_modules 加快构建速度</span></span><br><span class="line"><span class="attr">before_script:</span> <span class="comment"># 构建环境搭建，根据所用的主题，这里会有所不同</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span> <span class="comment"># 在 CI 环境内安装 Hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">themes</span> <span class="comment"># 由于 main 分支中没有将 themes/ 文件夹，所以需要重新创建</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/theme-next/hexo-theme-next</span> <span class="string">themes/next</span> <span class="comment">#从 Github 上拉取 next 主题</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 最后在根目录安装站点需要的依赖 </span></span><br><span class="line"><span class="attr">script:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># 生成静态文件</span></span><br><span class="line"><span class="attr">deploy:</span> <span class="comment"># 根据个人情况，这里会有所不同</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span> <span class="comment"># 构建完成后不清除</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="string">git</span> <span class="comment"># 默认使用 git</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">$GH_TOKEN</span> <span class="comment"># 在 Travis CI 中设置的环境变量 token</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">true</span> <span class="comment"># 保存历史</span></span><br><span class="line">  <span class="attr">fqdn:</span> <span class="string">blog.coley48.cn</span> <span class="comment"># 自定义域名，使用 username.github.io 可删除</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span> <span class="comment"># hexo 站点源文件所在的 branch</span></span><br><span class="line">  <span class="attr">local_dir:</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">gh-pages</span> <span class="comment"># 存放生成站点文件的 branch，使用 username.github.io 必须是 master</span></span><br></pre></td></tr></table></figure>

<h4 id="提交项目"><a href="#提交项目" class="headerlink" title="提交项目"></a>提交项目</h4><p><code>git push</code>命令执行完成之后，稍等片刻 Travis CI 就会开始运行。<br>在 Travis CI 控制面板中，进入到自己的仓库页面中可以看到项目正在构建，显示黄色：</p>
<img src="/2021/04/15/Travis-CI-GitHub-Pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/travis-CI%E6%9E%84%E5%BB%BA%E4%B8%AD.png" class="">

<p>在下方<code>Job log</code>中还可以查看构建过程中的输出信息：</p>
<img src="/2021/04/15/Travis-CI-GitHub-Pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/travis-CI%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF.png" class="">

<p>当输出<code>Done. Your build exited with 0.</code>时，表示构建成功，显示为绿色：</p>
<img src="/2021/04/15/Travis-CI-GitHub-Pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/travis-CI%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%88%90.png" class="">

<p>此后，Travis CI 会自动监听 GitHub 仓库提交，每次有新的代码提交，Travis CI 会自动按照<code>travis.yml</code>配置文件中的命令执行，然后将生成的代码推送到指定的分支中。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.travis-ci.com/">Travis CI 官网</a></li>
<li><a href="https://www.travis-ci.com/getting_started">Travis CI 官方文档</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html">持续集成服务 Travis CI 教程</a></li>
<li><a href="https://dunwu.github.io/tools/travis-ci%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B.html">Travis CI 极简教程</a></li>
<li><a href="https://www.itrhx.com/2018/08/15/A02-hexo-blog/">使用 Github Pages 和 Hexo 搭建自己的独立博客</a></li>
<li><a href="https://segmentfault.com/a/1190000017909815?utm_source=sf-similar-article">Travis CI + github + hexo 自动化部署</a></li>
<li><a href="https://segmentfault.com/a/1190000021987832">Travis CI 加 Hexo 实现自动构建部署 Github Pages 博客</a></li>
<li><a href="https://developer.aliyun.com/article/569237">使用Travis CI自动部署Hexo博客</a></li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
        <tag>Travis-CI</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack-学习笔记</title>
    <url>/2021/07/28/Webpack-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="webpack-学习笔记"><a href="#webpack-学习笔记" class="headerlink" title="webpack 学习笔记"></a>webpack 学习笔记</h2><blockquote>
<p>At its core, webpack is a static module bundler for modern JavaScript applications. When webpack processes your application, it internally builds a dependency graph which maps every module your project needs and generates one or more bundles.<br>本质上，webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图 (dependency graph) ，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。</p>
</blockquote>
<span id="more"></span>

<h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><p>webpack 是基于 nodejs 的，因此 webpack 项目也是一个 node 项目，直接使用 npm 来初始化项目；对于大多数项目，建议本地安装，便于后期分项目升级；</p>
<ol>
<li>使用<code>npm init</code>命令初始化项目文件夹，创建<code>package.json</code>文件；</li>
<li>安装 webpack 和 webpack-cli 开发依赖；</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; npm init -y</span><br><span class="line">&gt; npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure>

<p>以该项目为例，目录结构如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .gitignore</span><br><span class="line">├── README.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── package.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── src</span><br><span class="line">|   └── index.js</span><br><span class="line">└── dist</span><br></pre></td></tr></table></figure>

<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ol>
<li>新建一个模块<code>a.js</code>，并在里面编写一个简单的打印函数；</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/a.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    print,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建入口<code>index.js</code>，并引入模块<code>a.js</code>；</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line"></span><br><span class="line">moduleA.print(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行 <code>npx webpack</code> 开始打包，结果将被输出到根目录下 dist 文件夹中，并得到以下输出：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">asset main.js 224 bytes [compared <span class="keyword">for</span> emit] [minimized] (name: main)</span><br><span class="line">./src/index.js 83 bytes [built] [code generated]</span><br><span class="line">./src/a.js 104 bytes [built] [code generated]</span><br><span class="line"></span><br><span class="line">WARNING <span class="keyword">in</span> configuration</span><br><span class="line">The <span class="string">&#x27;mode&#x27;</span> option has not been <span class="built_in">set</span>, webpack will fallback to <span class="string">&#x27;production&#x27;</span> <span class="keyword">for</span> this value.</span><br><span class="line">Set <span class="string">&#x27;mode&#x27;</span> option to <span class="string">&#x27;development&#x27;</span> or <span class="string">&#x27;production&#x27;</span> to <span class="built_in">enable</span> defaults <span class="keyword">for</span> each environment.</span><br><span class="line">You can also <span class="built_in">set</span> it to <span class="string">&#x27;none&#x27;</span> to <span class="built_in">disable</span> any default behavior. Learn more: https://webpack.js.org/configuration/mode/</span><br><span class="line"></span><br><span class="line">webpack 5.37.1 compiled with 1 warning <span class="keyword">in</span> 201 ms</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>得到打包好的输出文件<code>dist/main.js</code>；</li>
</ol>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><strong>入口</strong>（entry）：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图（dependency graph）的开始，默认值是<code>./src/index.js</code>。</li>
<li><strong>输出</strong>（output）：告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 <code>./dist/main.js</code>，其他生成文件默认放置在<code>./dist</code>文件夹中。</li>
<li><strong>加载器</strong>（loader）：让 webpack 能够去处理 js 和 json 以外的其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。 </li>
<li><strong>插件</strong>（plugin）：让 webpack 可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量等。                           </li>
<li><strong>模式</strong>（mdoe）：通过选择<code>development</code>、<code>production</code>或<code>none</code>之中的一个，来设置 mode 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为<code>production</code>。</li>
<li><strong>目标</strong>（target）：告知 webpack 为部署目标指定一个环境。默认值为<code>browserslist</code>，如果没有找到<code>browserslist</code>的配置，则默认为<code>web</code>。      </li>
<li><strong>模块热替换</strong>（HMR - hot module replacement）：是指在应用程序运行过程中，替换、添加或删除模块，而无需重新加载整个页面。</li>
<li><strong>初始化块</strong>（initail chunk） 是入口起点的主块。此 chunk 包含为入口起点指定的所有模块及其依赖项。默认名为<code>main.js</code>。</li>
<li><strong>非初始化块</strong> （non-initial chunk）是可以延迟加载的块。可能会出现在使用 动态导入(dynamic imports) 或者 SplitChunksPlugin 时。默认情况下，这些非初始化块没有名称，因此会使用唯一 ID 来替代名称。</li>
</ul>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>webpack 可以无需使用任何配置文件。webpack 会假定项目的入口起点为<code>src/index.js</code>，然后会在<code>dist/main.js</code>输出结果，并且在生产环境开启压缩和优化。但通常我们还需要对 webpack 进行更精细化的配置，以充分发挥 webpack 的能力。</p>
<p>习惯性的将配置文件拆分为三个配置文件，并提取公共配置部分到<code>webpack.common.js</code>，然后分别将开发模式和生产模式的配置放在<code>webpack.dev.js</code>和<code>webpack.prod.js</code>中，并用<code>webpack-merge</code>合并公共部分的配置。</p>
<p>最后<code>package.json</code>中添加 webpack 的 script 启动命令，让 webpack 使用自定义的配置文件替代默认的<code>webpack.config.js</code>：</p>
<p><strong>package.json</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;script&quot; : &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;webpack --config webpack.dev.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遵循不重复原则(Don’t repeat yourself - DRY)，保留一个通用配置，将相同的公共配置放入<code>webpack.common.js</code>中：</p>
<p><strong>webpack.common.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">        print: <span class="string">&#x27;./src/print.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            include: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">            loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        &#125;, ],</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        symlinks: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        sideEffects: <span class="literal">true</span>,</span><br><span class="line">        usedExports: <span class="literal">true</span>,</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">&#x27;async&#x27;</span>, <span class="comment">// 对哪些块进行优化，all | async | initial，</span></span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                vendors: &#123;</span><br><span class="line">                    test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                    priority: -<span class="number">10</span>,</span><br><span class="line">                    reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    minChunks: <span class="number">2</span>,</span><br><span class="line">                    priority: -<span class="number">20</span>,</span><br><span class="line">                    reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将开发模式的配置放入<code>webpack.dev.js</code>中：</p>
<p><strong>webpack.dev.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    merge</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(config, &#123;</span><br><span class="line">    mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    devtool: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        publicPath: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        host: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        port: <span class="number">8000</span>,</span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">        historyApiFallback: &#123;</span><br><span class="line">            index: <span class="string">&#x27;/index.html&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            esModule: <span class="literal">false</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            esModule: <span class="literal">false</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        runtimeChunk: <span class="string">&#x27;single&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>将生产模式的配置放入<code>webpack.prod.js</code>中：</p>
<p><strong>webpack.prod.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(config, &#123;</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        publicPath: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">&#x27;css/[name].[contenthash:8].css&#x27;</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">            assetNameRegExp: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            cssProcessor: <span class="built_in">require</span>(<span class="string">&#x27;cssnano&#x27;</span>),</span><br><span class="line">            cssProcessorPluginOptions: &#123;</span><br><span class="line">                preset: [<span class="string">&#x27;default&#x27;</span>, &#123;</span><br><span class="line">                    discardComments: &#123;</span><br><span class="line">                        removeAll: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;],</span><br><span class="line">            &#125;,</span><br><span class="line">            canPrint: <span class="literal">true</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                sideEffects: <span class="literal">true</span>,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                        loader: MiniCssExtractPlugin.loader,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            publicPath: <span class="string">&quot;../&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                sideEffects: <span class="literal">true</span>,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                        loader: MiniCssExtractPlugin.loader,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            publicPath: <span class="string">&quot;../&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用 webpack-cli 脚手架初始化项目，需要安装 @webpack-cli/generators 依赖；<br>根据项目需要选择相应配置；</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; npx webpack-cli init &lt;project&gt;</span><br></pre></td></tr></table></figure>

<h4 id="实现热重载"><a href="#实现热重载" class="headerlink" title="实现热重载"></a>实现热重载</h4><p>热重载能为开发提供极大的便利，不需要每次修改代码后手动编译，然后在浏览器中手动刷新页面来观察效果；同时每次只更新改动部分的代码，并且将编译的结果存在内存中；通过在内存中（而不是写入磁盘）编译和 serve 资源来提高性能。这里提供两种实现热重载的方式：</p>
<p><strong>webpack-dev-serve</strong><br>使用 webpack 官方提供的开发服务器实现热重载是最简便的方式，需要安装开发依赖<code>webpack-dev-serve</code>，然后只需要在<code>webpack.dev.js</code>配置文件中添加 devSever 项的配置即可；</p>
<p><strong>webpack watch + live server</strong><br>使用 webpack 的 watch 模式是一种替代方案，它会实时监听文件的变动，编辑保存后便开始编译，并将文件输出到 dist 文件夹下，然后开启 VS Code 的插件 live server 即可实现模块热替换。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ol>
<li>package.json 属性说明</li>
</ol>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>name</code></td>
<td align="left">设置软件包的名称。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">列出软件包的作者名称。</td>
</tr>
<tr>
<td align="left"><code>contributors</code></td>
<td align="left">除作者外，该项目可以有一个或多个贡献者。 此属性是列出他们的数组。</td>
</tr>
<tr>
<td align="left"><code>bugs</code></td>
<td align="left">链接到软件包的问题跟踪器，最常用的是 GitHub 的 issues 页面。</td>
</tr>
<tr>
<td align="left"><code>homepage</code></td>
<td align="left">设置软件包的主页。</td>
</tr>
<tr>
<td align="left"><code>version</code></td>
<td align="left">指定软件包的当前版本。x.x.x 分别表示主版本号、次版本号、补丁版本号仅修复缺陷的版本是补丁版本，引入向后兼容的更改的版本是次版本，具有重大更改的是主版本。</td>
</tr>
<tr>
<td align="left"><code>license</code></td>
<td align="left">指定软件包的许可证。</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">此属性包含与软件包功能相关的关键字数组。</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">此属性包含了对软件包的简短描述。</td>
</tr>
<tr>
<td align="left"><code>repository</code></td>
<td align="left">此属性指定了此程序包仓库所在的位置。</td>
</tr>
<tr>
<td align="left"><code>main</code></td>
<td align="left">设置软件包的入口点。</td>
</tr>
<tr>
<td align="left"><code>private</code></td>
<td align="left">如果设置为 true，则可以防止应用程序/软件包被意外发布到 npm 上。</td>
</tr>
<tr>
<td align="left"><code>scripts</code></td>
<td align="left">可以定义一组可以运行的 node 脚本。</td>
</tr>
<tr>
<td align="left"><code>dependencies</code></td>
<td align="left">设置作为依赖安装的 npm 软件包的列表。</td>
</tr>
<tr>
<td align="left"><code>devDependencies</code></td>
<td align="left">设置作为开发依赖安装的 npm 软件包的列表。</td>
</tr>
<tr>
<td align="left"><code>browserslist</code></td>
<td align="left">用于告知要支持哪些浏览器（及其版本）。 Babel、Autoprefixer 和其他工具会用到它，以将所需的 polyfill 和 fallback 添加到目标浏览器。</td>
</tr>
</tbody></table>
<ol start="2">
<li>软件包版本说明符</li>
</ol>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">~</td>
<td align="left">如果写入的是 〜0.13.0，则只更新补丁版本：即 0.13.1 可以，但 0.14.0 不可以。</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">如果写入的是 ^0.13.0，则要更新补丁版本和次版本：即 0.13.1、0.14.0、依此类推。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">如果写入的是 *，则表示接受所有的更新，包括主版本升级。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">接受高于指定版本的任何版本。</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">接受等于或高于指定版本的任何版本。</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">接受等于或低于指定版本的任何版本。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">接受低于指定版本的任何版本。</td>
</tr>
<tr>
<td align="left">无符号</td>
<td align="left">仅接受指定的特定版本。</td>
</tr>
<tr>
<td align="left">latest</td>
<td align="left">使用可用的最新版本。</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">使用范围组合</td>
</tr>
</tbody></table>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://webpack.docschina.org/">webpack中文官方文档</a></li>
<li><a href="https://v4.webpack.js.org/">webpack v4 官网</a></li>
<li><a href="https://github.com/ronami/minipack">一个简单打包工具的详细说明</a></li>
<li><a href="https://blog.csdn.net/weixin_33936401/article/details/87963738">nodejs 中的依赖管理</a></li>
<li><a href="https://github.com/Coley48/webpack">个人webpack项目地址</a></li>
<li><a href="https://github.com/Coley48/webpack-code">个人webpack测试代码项目地址</a></li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>学习笔记</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>写给自己</title>
    <url>/2021/06/29/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1/</url>
    <content><![CDATA[<p>首先要对自己说一句：“毕业快乐！”。<br>四年大学生活已经落下帷幕，从此也踏上了新的人生征途。<br>纵观整个大学四年，我觉得自己过得很充实，也没留下什么遗憾。</p>
<span id="more"></span>

<p><strong>做个简单的总结：</strong></p>
<p>大一担任了班委，进了院上两委会，工作上比较忙，有时候饭都顾不上吃；然后参加了校上运动会，结交了很多朋友，但是学业上有些忽略了，所以前期成绩不太理想，后面开始慢慢将精力投入到学习上来，成绩有了很大的提升；</p>
<p>大二因为大一表现还不错，有幸读了党校，也因此认识了更多的优秀的同学；虽然大二没有留在两委会，但进入了学校的社团，认识了不少其他学院的同学；平时的时间大多都是在泡在图书馆里看书学习，因此大二整个学年的成绩都还不错；</p>
<p>从大三开始，积极参加了各种专业上的学科竞赛，数学建模、创新创业、计算机设计大赛、蓝桥杯等，不断积累项目经验以及获奖经历；专业的知识技能也是在大三这一年不断的通过项目的打磨提升上来的。</p>
<p>到了大四，整个第一学期，几乎都是在为老师写项目，我们也因为项目成为了很好的朋友；这个项目也是成为了我的毕业设计，然后也是找到了跟专业对口的工作，进入了新的人生阶段；</p>
<img src="/2021/06/29/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1/thumbnail.png" class="">

<p>当然毕业不是终点，而是新生活、新奋斗的起点；<br>况且学无止境，我愿常怀一颗赤子之心，在知识的海洋里，乘风破浪；在学习的道路上，披荆斩棘！</p>
<p>最后愿你历尽千帆，归来仍是少年；<br>愿你在多年之后再读到这篇文章时，仍是个积极进取，不断向前的少年。加油！</p>
]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>diary</tag>
        <tag>大学</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>前端小技巧汇总</title>
    <url>/2022/05/10/%E5%89%8D%E7%AB%AF%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章主要是记录 HTML 部分可用于实际开发中的小技巧，部分章节是翻译整理而来，所有章节后都附有原文地址或者其他参考资料，本文将持续更新；</p>
<span id="more"></span>

<h3 id="添加键盘快捷键"><a href="#添加键盘快捷键" class="headerlink" title="添加键盘快捷键"></a>添加键盘快捷键</h3><p>通过使用 <code>accesskey</code> 特性，我们可以为用户激活或聚焦在一个元素上赋予一个快捷键。这个特性的值必须是一个单独的字符。</p>
<p>值得注意的是每个浏览器提供了不同的组合键来触发快捷方式。</p>
<table>
<thead>
<tr>
<th align="left">浏览器</th>
<th align="left">macOS</th>
<th align="left">Windows</th>
<th align="left">Linux</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Chrome</td>
<td align="left"><code>alt</code> + <code>ctrl</code> + key</td>
<td align="left"><code>alt</code> + key</td>
<td align="left"><code>alt</code> + key</td>
</tr>
<tr>
<td align="left">Firefox</td>
<td align="left"><code>alt</code> + <code>ctrl</code> + key</td>
<td align="left"><code>alt</code> + <code>shift</code> + key</td>
<td align="left"><code>alt</code> + <code>shift</code> + key</td>
</tr>
<tr>
<td align="left">Safari</td>
<td align="left"><code>alt</code> + <code>ctrl</code> + key</td>
<td align="left">n/a</td>
<td align="left">n/a</td>
</tr>
</tbody></table>
<p>在下面的示例代码中，在 macOS Chrome 中按下组合键  <code>alt</code> + <code>ctrl</code> + <code>e</code> 会触发按钮的 <code>click</code> 事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">accesskey</span>=<span class="string">&quot;e&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Edit&#x27;)&quot;</span>&gt;</span>Edit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://getfrontend.tips/add-keyboard-shortcuts/">原文：Add keyboard shortcuts</a></li>
</ul>
<h3 id="判断浏览器是否支持一个元素属性"><a href="#判断浏览器是否支持一个元素属性" class="headerlink" title="判断浏览器是否支持一个元素属性"></a>判断浏览器是否支持一个元素属性</h3><p>我们可以检测当前浏览器是否支持给定的特性，以 <code>pattern</code> 为例，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isPatternSupported = <span class="string">&#x27;pattern&#x27;</span> <span class="keyword">in</span> <span class="built_in">document</span>.createElement(<span class="string">&#x27;input&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果你想检查某些特性值，则需要多几个步骤。下面的示例代码判断原生的日期输入框标签是否被支持：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDateInputSupported = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的 input 元素</span></span><br><span class="line">    <span class="keyword">const</span> ele = <span class="built_in">document</span>.createElement(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 type 特性</span></span><br><span class="line">    ele.setAttribute(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;date&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> invalidValue = <span class="string">&#x27;not-a-valid-date&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个非法的值</span></span><br><span class="line">    ele.setAttribute(<span class="string">&#x27;value&#x27;</span>, invalidValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ele.value !== invalidValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果浏览器支持 <code>date input</code>，调用 <code>setAttribute</code> 并传入一个非法的日期将不会在 <code>value</code> 特性上生效。因此，<code>ele.value</code> 将会是一个空字符串。</p>
<p>否则，这个输入框会被当做普通文本输入框，同时 <code>ele.value</code> 会返回原始的值。</p>
<ul>
<li><a href="https://getfrontend.tips/check-if-the-browser-supports-for-an-element-attribute/">原文 Check if the browser supports for an element attribute</a></li>
</ul>
<h3 id="通过-is-伪类选择器组合样式"><a href="#通过-is-伪类选择器组合样式" class="headerlink" title="通过 :is 伪类选择器组合样式"></a>通过 :is 伪类选择器组合样式</h3><p><code>:is</code> 伪类选择器为其参数中列出的选择器匹配到的所有元素应用样式，而不是写分开的选择器：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-tag">footer</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把它们组合成一个单独的，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:is</span>(<span class="selector-tag">header</span>, <span class="selector-tag">nav</span>, <span class="selector-tag">footer</span>) <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://getfrontend.tips/combine-styles-with-the-is-pseudo-class-selector/">原文 Combine styles with the :is pseudo-class selector</a></li>
</ul>
<h3 id="创建一个一次性的事件处理器"><a href="#创建一个一次性的事件处理器" class="headerlink" title="创建一个一次性的事件处理器"></a>创建一个一次性的事件处理器</h3><p>有时候我们想要一个给定元素的事件触发一次。通常，这可以通过绑定一个移除自身的处理器实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 做些事情 ...</span></span><br><span class="line">    element.removeEventListener(<span class="string">&#x27;click&#x27;</span>, handler);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, handler);</span><br></pre></td></tr></table></figure>

<p>我们可以使用一个命名函数表达式使代码缩短一点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 做些事情 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除处理器</span></span><br><span class="line">    e.currentTarget.removeEventListener(e.type, handler);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然而，现代浏览器提供了一个新的 <code>once</code> 选项让事情变得更简单了。我们不再需要去跟踪处理器的引用了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.addEventListener(</span><br><span class="line">    <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">    (e) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 做些事情 ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        once: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://getfrontend.tips/create-an-one-time-event-handler/">原文 Create an one-time event handler</a></li>
</ul>
<h3 id="强制给定必须的参数"><a href="#强制给定必须的参数" class="headerlink" title="强制给定必须的参数"></a>强制给定必须的参数</h3><p>在 ES6 中，默认参数值在参数缺省时被计算。这让我们可以强制给定某个必须的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> required = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Missing parameter&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAges = <span class="function">(<span class="params">yearOfBirth = required()</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - yearOfBirth;</span><br></pre></td></tr></table></figure>

<p>不带参数调用 <code>getAges()</code> 函数会抛出 <code>Missing parameter</code> 异常。</p>
<ul>
<li><a href="https://getfrontend.tips/enforce-required-parameters/">原文 Enforce required parameters</a></li>
</ul>
<h3 id="在-CSS-属性选择器中忽略大小写敏感"><a href="#在-CSS-属性选择器中忽略大小写敏感" class="headerlink" title="在 CSS 属性选择器中忽略大小写敏感"></a>在 CSS 属性选择器中忽略大小写敏感</h3><p>默认情况下，CSS 属性选择器是大小写敏感的。这意味着 <code>a[href$=&quot;.png&quot;]</code> 只对带有 <code>.png</code> 扩展名的链接起作用。</p>
<p>设想你正在创建一个文件管理应用。这可能需要根据文件的扩展名来添加一个图标。比如，下面的 CSS 为任意的 <code>.png</code> 文件插入一个图标。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&#x27;.png&#x27;</span>]</span>:after &#123;</span><br><span class="line">    content: <span class="built_in">url</span>(<span class="string">/img/png.svg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在现实中，文件是由用户上传的，我们不能控制文件的扩展名。一个 png 文件可以被命名为 <code>.png</code>，<code>.PNG</code>，<code>.pNG</code>。</p>
<p>为了接受所有这些变种，我们可以在选择器的 <code>]</code> 前面添加 <code>i</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&#x27;.png&#x27;</span> i]</span>:after &#123;</span><br><span class="line">    content: <span class="built_in">url</span>(<span class="string">/img/png.svg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://getfrontend.tips/ignore-case-sensitivity-in-a-css-attribute-selector/">原文 Ignore case sensitivity in a CSS attribute selector</a></li>
</ul>
]]></content>
      <categories>
        <category>tricks</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>学习笔记</tag>
        <tag>前端</tag>
        <tag>tricks</tag>
      </tags>
  </entry>
  <entry>
    <title>单车维修之补胎换胎</title>
    <url>/2021/10/08/%E5%8D%95%E8%BD%A6%E7%BB%B4%E4%BF%AE%E4%B9%8B%E8%A1%A5%E8%83%8E%E6%8D%A2%E8%83%8E/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间，我的车前轮胎瘪了，又刚好那段时间连着下了好长一段时间的雨，我也就很长时间没有管。后边考虑了一下，觉得自己换轮胎要方便些，于是就在网上买了轮胎和一些工具，然后照着网上的视频开始自己换轮胎。</p>
<p>其实说来惭愧，骑了这么多年的车，都没有自己换过轮胎，这里记录一下换轮胎时需要注意的一些细节。</p>
<span id="more"></span>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>卸外胎：可以借助撬胎棒等工具把外胎掰开，然后顺着口子把整个外胎弄到钢圈外，因为公路车轮胎比较细，所以卸的时候会相对难一些；</li>
<li>检查外胎：卸下外胎后需要用手检查外胎内壁中是否有刺或其他异物，避免装上内胎后再次将内胎砸破；</li>
<li>补内胎：取出内胎，先用气枪加点气，然后放在耳垂旁感受气流，找到出气口；用锉刀把出气口周末打磨粗糙，再贴上补胎片，之后反复挤压搓几下使结合紧密；</li>
<li>上内胎：先往补好的内胎或者新内胎打少量的气定型，避免上内胎的时候与外胎挤压发生褶皱导致内胎破裂；然后把气嘴插入钢圈上对应的孔位，再依次将内胎放入外胎中；</li>
<li>装外胎：将内胎尽量放在内胎和钢圈中间的位置，然后将外胎在刚圈外的一侧依次摁入钢圈中；</li>
<li>打气：然后开始向轮胎中打气，轮胎的压强范围一般都在外胎上有标注，通常打到用手指掐不动的时候就差不多了；</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>为避免伤及外胎和内胎，在装胎过程中：</p>
<ol>
<li>严禁使用螺丝刀或其它锋利的工具；</li>
<li>严禁充气过饱；</li>
<li>定期检查，保持正常胎压；</li>
</ol>
]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>diary</tag>
        <tag>单车</tag>
      </tags>
  </entry>
  <entry>
    <title>小白装机指南</title>
    <url>/2021/12/10/%E5%B0%8F%E7%99%BD%E8%A3%85%E6%9C%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>老早之前就打算换台电脑了，刚开始的时候看的都是整机，但是对于这些各种各样的参数配置我是不太了解的（说实话我对台式硬件部分了解不多）；然后就在网上找了一些讲电脑配置的视频看，然后就了解到DIY装机，因为我本身也是一个喜欢动手的人；然后就决定自己选配置，自己组装电脑；</p>
<p>经过这次更新电脑，我也算是恶补了很多电脑相关的硬件知识了。这里就整理一下整个装机的过程。</p>
<span id="more"></span>

<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>准备工作主要就是挑选配置，先罗列一下我的清单，方便抄作业的同学；</p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">类型</th>
<th align="left">单价</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CPU + 主板</td>
<td align="left">i7 11700 + 微星 B560M 迫击炮 WiFi版</td>
<td align="left">2869</td>
</tr>
<tr>
<td align="left">机箱</td>
<td align="left">爱国者 YOGO M2白</td>
<td align="left">163</td>
</tr>
<tr>
<td align="left">固态</td>
<td align="left">西数 SN550 1T</td>
<td align="left">620</td>
</tr>
<tr>
<td align="left">电源</td>
<td align="left">鑫谷 750W 金牌全模组 GP850G</td>
<td align="left">437</td>
</tr>
<tr>
<td align="left">显示器</td>
<td align="left">HKC V271M IPS 27英寸</td>
<td align="left">849</td>
</tr>
<tr>
<td align="left">键盘</td>
<td align="left">艾石头 84键RGB 红轴</td>
<td align="left">199</td>
</tr>
<tr>
<td align="left">内存条</td>
<td align="left">金士顿 FURY DDR4 3600</td>
<td align="left">658</td>
</tr>
<tr>
<td align="left">鼠标</td>
<td align="left">罗技 G102 RGB 白</td>
<td align="left">105</td>
</tr>
<tr>
<td align="left">扇热</td>
<td align="left">酷冷至尊 冰神B240 ARGB水冷</td>
<td align="left">399</td>
</tr>
<tr>
<td align="left">总计</td>
<td align="left"></td>
<td align="left">6299</td>
</tr>
</tbody></table>
<p>刚开始的时候，我也不懂这样那样的配置，所以就去B站上找了很多视频来看；然后在京东上一件一件的挑，不仅要看性能，还要看颜值。然后所有配置挑选出来之后，再慢慢筛，哪些地方可以优化的，哪些配置之间是有冲突的，然后再做一些调整；</p>
<h3 id="组装机器"><a href="#组装机器" class="headerlink" title="组装机器"></a>组装机器</h3><p>拿到所有配件，然后迫不及待就开始组装，经过一番研究，自己总结一下组装的顺序：</p>
<h4 id="CPU-主板"><a href="#CPU-主板" class="headerlink" title="CPU + 主板"></a>CPU + 主板</h4><ol>
<li>先打开主板上的盖子，注意千万不要触碰主板上的针脚❗；</li>
<li>然后辨别一下主板上和 CPU 边缘的卡槽位置，轻轻放上去；</li>
<li>用手指按住 CPU 上下左右移动一下，会发现主板和 CPU 之间稍微有一些间隙；</li>
<li>盖上主板的盖子，完成安装，AMD 和 Intel 的主板稍微有一点不同；</li>
</ol>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/244970307">intel第11代i7-11700F装机配置推荐，11700F/11700搭配主板推荐，11700F搭配显卡推荐</a></li>
</ul>
<h4 id="内存条"><a href="#内存条" class="headerlink" title="内存条"></a>内存条</h4><p>在选择内存条的时候，要注意 CPU、主板和内存条的频率要一致，否则按照三者最低频率；当然这里不考虑超频的情况；</p>
<p>其次要注意主板支持的内存条类型，可以根据内存条上的豁口判断，我买的是 DDR4 的；</p>
<p>然后要注意，现在的主板大多支持双通道的内存，所以预计自己需要多大的内存，分成两根内存条，效果会比一根的要好；</p>
<ol>
<li>找到主板上内存条插槽，通常主板上有 2 个或者 4 个，有些主板甚至有 8 个；</li>
<li>然后打开插槽上两端的卡扣，对应内存条上的豁口，用力按下，直到卡口自动收起；</li>
<li>有些主板是单边卡口，安装差不多；</li>
</ol>
<ul>
<li><a href="https://www.sohu.com/a/472903735_121068095">电脑内存条频率取决于CPU还是主板？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/269392989">台式机 | 如何正确选购内存条</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/63604430">内存条怎么选？——从入门到精通</a></li>
</ul>
<h4 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h4><p>硬盘主要分两种，固态硬盘 SSD 以及 机械硬盘 HDD；现在市面上硬盘的接口主要以 SATA、mSATA、M.2 以及 PCI-E为主，我这里买的是 M.2 接口的固态硬盘；</p>
<p>B560M 上有两处 M.2 安装位置，一处位于中部散热片下方，再往下是另一处，建议优先安装散热片下的槽位；</p>
<ol>
<li>先要拆下散热片；</li>
<li>注意防呆插槽的位置，通常硬盘上有字的一面向上；</li>
<li>倾斜角度 30° 插入卡槽；</li>
<li>散热片背面一般会有贴纸，撕开后盖在硬盘上；</li>
<li>拧紧螺丝就完成了；</li>
</ol>
<h4 id="散热"><a href="#散热" class="headerlink" title="散热"></a>散热</h4><p>散热器一般分为风冷和水冷两种，风冷虽然性能上略低，但相对便宜；而水冷散热性能好，但是相对贵一些，还有就是会有水冷会有漏液的风险，所以要买好一点的水冷；</p>
<p>有些 CPU 是自带了一个原装散热的，我这款 11700 也是；为了方便后面做点亮测试，我就没有直接装上我自己买的水冷；</p>
<ol>
<li>在安装好 CPU 的基础上，进行以下操作；</li>
<li>在 CPU 表面涂一层硅脂，但是很多原装散热上有预涂的硅脂；</li>
<li>然后对准主板上 CPU 周围的四个孔位盖上散热；</li>
<li>固定散热，不同散热的连接方式有些不同，具体操作可以参看说明书；</li>
</ol>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/258379061">2021年12月电脑cpu散热器选购指南</a></li>
</ul>
<h4 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h4><p>电源这块的话，如果有极限超频的需求建议在上面的推荐基础上选择高100W~200W的电源，当然不超频也可以买比我推荐功率更大的电源，也留下后续配置升级的空间。</p>
<p>电源有多种认证标志，从白牌到钛金；通常选择铜牌以上就可以了；等级越高转换效率越高也就越省电，但是和电源的品质不是正相关的，一般来说金牌以上的电源绝大部分质量都不错。</p>
<p>然后根据电源的线是否可拆卸可分为：全模组、半模组和非模组；其中全模组电源上的线均可拆卸；半模组电源的主板供电线和 CPU 供电线不能拆卸，其他可拆；非模组电源的线是不可拆卸的，所以装机的时候会有很多线是多余的，走线会比较难。</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/179066013">2021年12月电脑电源选择指南与推荐</a></li>
</ul>
<h4 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h4><p>注意机箱支持的主板规格：ATX、MATX、ITX；然后是显卡长度限制，风扇位个数，电池规格，硬盘位等；</p>
<p>当时我这款散热和主板就有点冲突，尝试拆了主板最上面的散热也不行，最后在水冷风扇上取了两个固定螺柱才装上去，捣鼓了好半天；</p>
<p>在正式装机之前，一般要做一个短接测试；</p>
<ol>
<li>将主板、CPU、内存条、固态、散热安装好；</li>
<li>用 8pin（CPU供电线） 和 24pin（主板供电线） 的线将主板和电源连接；</li>
<li>用数据线连接显示器，可以方便看到是否有图像输出；</li>
<li>将电源通电，使用螺丝刀轻触 power+ 和 power- 针脚，通常在主板右下方；</li>
<li>短接后，看到风扇转动，表示短接开机成功；</li>
<li>然后有些主板上有自检灯，当第二个黄灯一直亮起时说明内存条没有插好；</li>
<li>断电后❗，将内存条重新插好，再次短接开机；</li>
<li>看到亮起了白灯，自检通过；</li>
<li>同时屏幕上可以看到，顺利进入到 BIOS 界面；</li>
<li>至此短接测试就通过了，就可以正式装机了；</li>
</ol>
<p>大致的装机步骤：</p>
<ol>
<li> 在机箱上预埋主板螺柱，不同主板的孔位是有差异的，所以要根据主板来；</li>
<li> 然后把主板平行放入机箱中，一次拧上螺丝；</li>
<li> 安装散热，</li>
</ol>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/337206779">2021年12月电脑机箱推荐</a></li>
</ul>
<h4 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h4><p>外设就是鼠标、键盘、显示器、音响等输入输出设备；这部分直接按着主板上的接口插就可以了；至此，硬件部分的安装就完成了；</p>
<h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><p>主机组装完成之后就是</p>
<ul>
<li><a href="https://www.wepe.com.cn/">微PE官网</a></li>
<li><a href="https://blog.csdn.net/weixin_42256332/article/details/106933772">解决微PE不支持移动硬盘NTFS的UEFI启动</a></li>
</ul>
<h3 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/54529443">系统安装好后，怎么用最正规的方法安装驱动</a></li>
<li><a href="https://www.bilibili.com/video/BV12t4y1S7Uw">微星主板如何正确安装主板驱动和声卡驱动</a></li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/43011827">小白的初次DIY装机攻略</a></li>
<li><a href="https://www.163.com/dy/article/GE64K4040512MJDN.html">遇事不决？迫击炮！微星B560M迫击炮评测</a></li>
<li><a href="https://new.qq.com/omn/20210428/20210428A0A9TE00.html">微星MAG B560M MORTAR主板评测：主流配置再升级</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/349293186">热门Z590主板推荐。Z590主板CPU搭配建议。支持PCIE4.0。包含ATX,M-ATX,ITX版型。</a></li>
<li><a href="https://cn.msi.com/">微星中国官网</a></li>
<li><a href="https://cn.msi.com/Motherboard/MAG-B560M-MORTAR-WIFI/support#down-driver&Win10%2064">产品支持 MAG B560M MORTAR WIFI</a></li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
        <tag>电脑</tag>
        <tag>装机</tag>
      </tags>
  </entry>
  <entry>
    <title>总结@21-09</title>
    <url>/2021/10/02/%E6%80%BB%E7%BB%93-21-09/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>自意见实施以来已有1个月时间，从各方面来看，效果还是很明显的；总的来说，相较于9月之前，我已经在各个方面有了很大的进步，但我还有很多地方需要继续完善。</p>
<p>这里总结下自己这一个月以来在各方面的变化，以及接下来下一个月的大致规划：</p>
<span id="more"></span>

<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>整个9月可以说是工作以来最忙的一个月，QT组日常加班到9点，然后连续两个周六加班到了12点半，之后中秋前一天晚上又通知周日要去公司加班，当时的自己确实有点遭不住了，因为头两天家里停水了，连续两天晚上没洗成澡，就是加班完回去发现没法洗澡，心里头有点崩溃，说实话当时已经做好了离职的打算；</p>
<p>然后在最后一周调回了Web组，开始接手新的项目，另个项目发版，又跟着加班到了2点半，上个月加班说实话确实多；但是往后面看，在Web组，一般只会在发版的时候加班，平时的话一般都能6点下班，这样我还能回去自己做饭，晚上还能学习会。</p>
<p>从9月开始，我也开始分担了一些前端面试新人的工作，要知道，我才进公司工作了5个月，算起来我也还是一个新人；等国庆收假回来，我打算申请带那个即将入职的新人，好开心😉。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>在平时，由于早起的缘故，每天早上会提前1小时到公司，通常是读半小时英语，有时是新闻，有时是科比自传；然后要么练会打字，要么看会文档，捣鼓一下自己的东西；</p>
<p>在周末，如果是放两天，我除了运动，一般也会抽时间专研一下技术；但是上个月由于加班比较多，自己剩下的时间相对较少，后期应该时间会相对充足一些；</p>
<p>9月把自己的 Git 服务器搭建好了，后面会逐渐把写的项目都放到 Git 下方便管理，然后10月要把持续集成搭建好，然后开始深入学习 JS 基础部分；</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>首先是作息较之前规律了很多，绝大部分时候是晚上11点睡觉，早上7点起床；其次现在的饮食也很规律，每天三餐都按时吃了，现在也拒绝外卖零食奶茶这些，然后坚持每天吃水果；</p>
<p>然后不管加班多晚，晚上的锻炼也从没有间歇过，肚子上的肥肉也少了一些，腹肌若隐若现，我感觉再坚持一个月，应该效果就更明显了。</p>
<p>9月也是很丰富的一个月，有和同事一起打了羽毛球，聚了餐，唱了歌；但是，因为上个月加班比较多，所以组织的活动相对较少；这个月开始应该会组织更多的活动；</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在后面的日子里，我还要更加严格的要求自己，更加专注的提升自己，更加主动的挑战自己。先撂下狠话：我，绝不躺平！</p>
<p>9月关键字是<code>规律</code>；10月关键字将是<code>专业</code>；</p>
]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>diary</tag>
        <tag>总结</tag>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>总结@21-10</title>
    <url>/2021/11/05/%E6%80%BB%E7%BB%93-21-10/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>最近事情确实有点多，导致很多计划都被推迟或者暂停了；纵观整个10月，有很多时候并没有按照自己的规划来，说到底就是找了借口，就是惰性、懒；特别是从最近天气转凉，早上有点起不来就能看出来；</p>
<span id="more"></span>

<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>从上个月开始，我就全面负责千里眼项目，因为之前项目的设计就很复杂，就导致了我开发进度较慢，通常要花较长的时间来整理代码的逻辑；而且因为之前没有怎么做过小程序的开发，因此还踩了一些坑。😔</p>
<p>项目和项目之间关系也挺复杂，小程序页面里面嵌套了webview，然后webview里面的页面是uniapp开发的移动端和H5的页面，然后又在这里面套了一个网页，开发的时候一不注意就要影响到其他地方，上线的时候也要分成三部分；每次开发都要同时开七八个窗口，感觉开发的时候到处是坑，得特别小心才行；</p>
<p>特别地，需求是要在第三层的网页跳转到第一层的微信小程序，然后调用微信支付的api，然后在开发工具里面好好的，上线之后就失效不起作用了，后面才知道这是webview的一个坑，后面经过不懈的努力才终于把支付的功能弄好了；（😣心累。。。）</p>
<p>在月底的时候，我申请了调薪，现在公司的调薪和技术评级挂钩了，虽然自己来公司也并没有多久，也没有做出多大的贡献，不过最后还是涨了一些，还是挺好的。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p><strong>21-10-01</strong></p>
<p>国庆这天叫肖玉林过来吃饭，然后下午去看长津湖，结果这货这几天反胃，没吃几口就吐了，😑，然后晚上佳文又约我们去吃饭，吃了饭又在外面转了好久，聊了好多我们高中的趣闻轶事，真好。</p>
<p><strong>21-10-07</strong></p>
<p>国庆最后一天，和同事去玩了剧本杀，第七号嫌疑人，一部推理本，这还是我头一次玩剧本杀，我们六个人推了6个小时，最后把答案全都推出来了，可真有我们的。</p>
<p><strong>21-10-16</strong></p>
<p>吕叔来成都找我玩，那天在春熙路逛了一晚上，请他吃了一个韩国菜；给他买了可乐，他又不喝，最后我拿回去了，现在都还放在家里。。。</p>
<p><strong>21-10-20</strong></p>
<p>双11居然10月份就开始了，我还是没忍住换了手机，然后把原来那个在闲鱼上卖了，还行，头一次在闲鱼上卖东西，没几天就卖掉了；</p>
<p>这个月生活整体上还算规律，不过到了下旬，大部分的时间在准备调薪的面谈了，所以每天早上读英语时间就一直搁置了；然后那段时间心情可能不太好，导致每周的运动计划也逐渐淡化了；处在了放纵的边缘；</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自己能够明显感觉到，自己对自己要求有些松了，要时刻提醒自己，不要找借口，并严格要求自己。</p>
]]></content>
      <tags>
        <tag>日记</tag>
        <tag>diary</tag>
        <tag>总结</tag>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>总结@21-11</title>
    <url>/2021/12/01/%E6%80%BB%E7%BB%93-21-11/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>纵观整个11月份，自己过的很乱，熬夜次数也多了，这是个很不好的变化；但是不管多晚，还是有坚持在锻炼；从下个月开始，把手头事情处理完就得<br>开始好好整了；</p>
<span id="more"></span>

<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>因为月初的时候回了趟家，不知咋的，过了一周健康码变黄了，额😐；那段时间成都的疫情反弹有点严重，然后我就申请在家办公；9点上班，早上可以睡到8点50，是真的爽；</p>
<p>不知道为啥，感觉我一直扮演的是一个奇兵的作用，一旦有什么很紧急的任务，就会落到我的头上，所以我手上的项目换了一个又一个；然后很烦的是现在什么问题都找我，后端要改个接口，财务绑不了账号，售后又有什么问题了。有几天都是这样的，一直被打断，导致我开发的速度贼慢。</p>
<p>然后另外一个要吐槽的是，本来就整不完，还非要这周就要；周六也加到了9点，结果还不是第二周才弄完，第二周用的，搞不懂那些人是怎么想的，开发不是人吗？</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p><strong>21-11-05</strong></p>
<p>黄码那一周，去做了两次核算，头一次做核算，直接就是鼻拭子，棉签捅进鼻子的时候，那种火辣辣的感觉，眼泪忍都忍不住，第二次就要好一点了；第二天健康码就转绿了，但还是被要求居家隔离7天，那几天差不多都是自己在做饭；</p>
<p><strong>21-11-13</strong></p>
<p>这天周六，欧阳过生日，叫我们去唱歌，我上午去了公司一趟，下午就去KTV，玩骰子，就喝了一场酒，然后就在隔壁吃的火锅，味道还挺好的，又是一场酒，吃完饭又去了小酒馆，存粹就是玩游戏喝酒了；其实本来我吃完饭之后就有一点酒意了，但是走小酒馆的时候就醒了差不多了；所以虽然那天喝了三场酒，但我没醉；倒是欧阳这个酒仙最后给喝醉了，🤣，不过那天是真的开心。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个月呢，感觉就是工作上的事情变多了，然后有点小累吧，很多时候就不想再学习了，或者做点其他事情什么的；然后就想着玩了，后面得平衡一下工作和生活，在这之间还是得留给自己学习提升的时间和空间；</p>
]]></content>
  </entry>
  <entry>
    <title>斯人已去，举国皆哀</title>
    <url>/2021/05/27/%E6%96%AF%E4%BA%BA%E5%B7%B2%E5%8E%BB%EF%BC%8C%E4%B8%BE%E5%9B%BD%E7%9A%86%E5%93%80/</url>
    <content><![CDATA[<blockquote>
<p>我一直有两个梦想，一个是 禾下乘凉梦，一个是杂交水稻覆盖世界梦。————袁隆平</p>
</blockquote>
<img src="/2021/05/27/%E6%96%AF%E4%BA%BA%E5%B7%B2%E5%8E%BB%EF%BC%8C%E4%B8%BE%E5%9B%BD%E7%9A%86%E5%93%80/dream.jpg" class="">

<span id="more"></span>

<p>2021年5月22日是每个中国人都应该铭记的日子，“杂交水稻之父”，中国工程院院士，“共和国勋章”获得者袁隆平爷爷永远的离开了我们。<br>先是从外公口中得知了这个消息，后面有人出来辟谣，但随后新闻报道证实，袁老因为多器官功能衰竭，在长沙逝世。得知这个噩耗，一时还真有点难以接受。</p>
<p>对此，我深有感触，因为这天上午刚刚在田里帮忙插秧，仅仅一个上午的时间，我就全身肌肉酸痛，所以我也早就明白了为什么粒粒皆辛苦，为什么纸上学来终觉浅，绝知此事要躬行！<br>晚上躺在床上，久久不能入睡，打开微博，全是袁老的话题。“袁老病危时仍挂念田里的稻子”，“长沙市民鸣笛送别袁老”，“市民雨中送别”……泪水止不住的往出涌。我也是一个感性的人，每每看到袁老那些感人的事迹，就会引起共鸣，立马泪目。</p>
<p>虽然文字是最苍白无力的，况且自己的文笔不好，但终究还是想写点什么。谨以此篇，献给为我们付出一生的袁老，一路走好！</p>
]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>diary</tag>
        <tag>纪念</tag>
      </tags>
  </entry>
  <entry>
    <title>我的大学</title>
    <url>/2021/08/31/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>一转眼已经毕业了2个月了，算上实习也工作了有4个月了。总的来说，自己已经逐渐适应了每天两点一线的上班生活。相较而言，工作的压力要大一些，什么事情都要自己考虑，花钱的地方也多，因此还是读书要比工作轻松；然后另一个感受是经济独立真的太爽了，从出来工作之后也没再问家里要过钱，虽然之前实习挣的少，还要交房租，但还是勉强撑过来了，之后的日子也会逐渐步入正轨，越来越好！</p>
<p>由于自己没有写日记的习惯，因此大学经历过的很多有趣好玩的事情并没记录下来，就打算写一篇文章，大概记录一下自己觉得好玩、有意义的事情，也算是自己的一篇大学的自传！有些时间点不准确，只是大概的参考日期。</p>
<span id="more"></span>

<h3 id="大一篇"><a href="#大一篇" class="headerlink" title="大一篇"></a>大一篇</h3><p><strong>2017-09-06</strong><br>大一，刚进入大学，便是为期一周的寝室内务 + 半个多月的军训，完全刷新了我对咱们学校的认知😱；不过比较好的一点是我们学校有一个传统是大二同专业的学长会带着大一新生搞内务；</p>
<p>这是我总结的内务操作指南：</p>
<ul>
<li>缝床单：要用针线把床单沿着席子的边缝在一起，这样看起来床单才整齐；</li>
<li>包棕垫：要用牛皮纸将棕垫包起来，用透明胶粘好，避免掉棕毛；</li>
<li>砂铁锈：要用砂纸将床上的铁锈擦掉，然后涂上指甲油防锈；</li>
<li>擦地板：要用洗衣粉把地面刷过之后，再拿帕子擦干净；</li>
<li>叠军被：要把处理过的被子叠成豆腐块，但我们睡觉的时候一般都收到柜子里盖另一床被子，免得每天都叠；</li>
<li>拉军被：要用桌桌面盖在被子上，来回拉扯把被子压得平薄，4人合作拉桌腿，2人站桌斗里加重量，1人往地上的席子上抹肥皂减小摩擦；</li>
</ul>
<p>拉军被的工作量最大，都是师兄弟一起拉了几天才完成，最后我们还去了女寝（还是头一次去女生寝室😊）帮女生拉军被，当时不知道有多少张桌子腿被拉断了。</p>
<p>军训期间我的社死瞬间：刚开始军训，无知的把军训服里的腰带当作皮带用了，然后教官讲了正确的使用方式，可是该死的裤子太大了，我只能把裤子提得尽量高一点，然后把腰带扎紧一点，这样裤子也被扎住了；可惜我还是年轻了，结束了上午的军训，刚好到饭点，高年级的也下课了，我转过主教楼，迎面走来几个师姐，好巧不巧的就在这个时候，我裤子哗的一下掉了下来，我🙃…..，也没敢看她们，就一把抓住了裤子，绕开从边上跑了，还隐隐听到了她们在笑，我去之后我就把裤子裁了。</p>
<p>还有一次，早上睡得正香的时候，被室长的叫声给吵醒了，本来还以为是军训集合了；给我们说了半天，但是不知道是他语速太快还是我们都还没清醒过来，都没听懂他在说啥，后面才知道他说老鼠爬到他床上了，还被他摸了🤨，然后看了看时间才4点过，都没当回事，接着又睡下了；</p>
<p><strong>2017-09-15</strong><br>军训期间，我也认识了我大学中的第一位贵人，我们的班助（班主任助理），也是我的老大——婷哥；</p>
<p><strong>2017-10-08</strong><br>国庆之后，班会上我竞选班长，落选了，当了劳生委员；后来我跟着婷哥进了两委会监察部，她是部长，我是干事。<br>按院上两委会的传统，每届都会有一个新干事见面大会，每个部门都会出一个节目，当时在一起排练的场景我还依稀记得；后面居然还是在新传演播大厅举行的！</p>
<p><strong>2017-10-18</strong><br>我在大学过的第一个生日是我们监察部的小伙伴陪我过的，真的很惊喜！<br>那天真的是出奇的忙，中午饭晚饭都没顾上吃，就中午忙完回了寝室吃了两口面包，还拉肚子了……<br>然后那天也是我们高中校庆，我还穿了一天高中校服。✌</p>
<p><strong>2017-11-01</strong><br>自己攒钱买了自行车，为此吃了半个月的土，谁能想象我半个月只用了80块；<br>从此我都生活中多了一个伙伴，没事的时候就喜欢骑车到处跑，所以南充的路，我也比较熟。</p>
<p><strong>2017-12-29</strong><br>后来遇到了我的初恋，那是快放寒假假的时候了；</p>
<p>寒假在家拿了驾照，之前科三挂了，然后还干了些啥都忘干净了。</p>
<p><strong>2018-04-01</strong><br>第二学期开学没多久，学校的运动会就来了；我也参加了院上的集训队，带我们训练的教练都是体育学院的高年级学长；只要不下雨，每天都会训练，包括周末；大概持续了大半个月的样子，反正每天都是腰酸背痛的，在训练的日子里，虽然训练的时候很累，但是过的真的很充实，还认识了很多朋友，大家都是一起训练的同学们，可能是因为一起吃过苦，所以革命友谊都很深厚！</p>
<p>有一次在我们训练的时候，院上新闻中心的干事来给我们拍照写新闻稿子。好巧不巧，当时在做一个一边扭腰一边横移的热身运动，专业名称叫啥我也不知道；然后我就被抓拍到了……🙄，然后就有了下面这张图，为啥刚好只有我一个人，为啥我当时要那么认真？</p>
<img src="/2021/08/31/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/exercise.png" class="">

<p><strong>2018-04-21</strong><br>因为我的优势是耐力好，所以我报的项目是5000米，后面进行专项训练的时候，差不多每天会跑15、6圈左右，最高纪录是训练一天一共跑了7000多米，没记错的话；正式比赛的时候，还是有点紧张，感觉还是没有发挥好，最后小组第3名，总成绩第10名，运动会也就告一段落了。</p>
<p>我还是像之前一样，一边学一边玩，不过数学课程已经听不懂了，是真心难😐；期中之后，突然意识到，这样下去不行，怕是毕业后工作都不好找，危机感油然而生；从此以后开始好好学习，课后都是追着老师问问题，有高中时候那味儿了。😕</p>
<p>然后大一还有一件让我记忆深刻的事情，有一天中午在寝室睡午觉，睡着睡着我给哭醒了；</p>
<p><strong>2018-07-09</strong><br>剩下半个学期也很快过去，临时通知要和大二的一起搬寝室到新区，折腾了两天总算搬完了；<br>然后我就踏上了回家的路途，但是和往常不同的是，这次放暑假，我选择骑自行车回家；都是瞒着家里的，他们这时候还不知道我自己买了自行车；😁</p>
<p><strong>2018-07-11</strong><br>大部分行李提前寄回家了，只背了一个书包，头一天上午全是在山里绕来绕去，有的坡是陡得没法，只能下来把车推上去；整个上午骑了刚好有100公里，已经一点钟了，找了个管子吃了饭，在路边休息了一会又出发了，下午骑了有60多公里，六点刚好到了绵阳三台，随便找了个宾馆住了一晚，花了我100块……（好贵，我回家车费也才100块不到😭）</p>
<p><strong>2018-07-12</strong><br>第二天早上有点下雨，我等到10点雨停了才出发；第二天明显比第一天累多了，不过路况要好得多，大多时候是走的省道；当然也有走机耕道的时候，特别是下午跟着导航走到了一处低洼处，这里的路已经被水淹没，还好我当时没打算涉险淌过去，我折回去，凭着感觉继续往另一边的大路上走，后面好长一段前不着村后不着店，水也喝完了，后面终于又导航到了一条新的路上；所以能够发现最后轨迹图上有一个很明显的弧形；</p>
<p>18年暑假那段时间刚好在下暴雨，不过那两天还好都没怎么下雨，我才能按计划顺利到家；在路上就能够看到路边的河道里全是洪水，岸边的玉米，一些房子有一半都泡在了水里；不过总的来说，这是一段非常棒、非常 nice 的体验！😃</p>
<p>也是因为连续下大雨的缘故，奶奶在家不小心摔了，把手腕整骨折了，然后住进了镇上的医院。刚好这天我骑车到家这边，所以我直接骑车去了医院。这时候亲戚都在，见到我，都吃了一惊，问我这问我那的，然后就跟我说下不为例。</p>
<p>暑假前面一段时间主要是经常来医院照顾奶奶，好在也没什么大碍，没多久就出院在家休养了，只是偶尔会去医院换个药。暑假剩余时间我也忘了干了些啥，大一就这样过去了。</p>
<h3 id="大二篇"><a href="#大二篇" class="headerlink" title="大二篇"></a>大二篇</h3><p><strong>18-09-01</strong><br>是不是这天开的学，我也记不清了。开学一段时间还是挺忙的，然后被通知可以去读党校的我还是很惊喜的，因为经过上学期后半段的努力，成绩有了很大的进步，然后又因为担任劳生委员确实很辛苦。</p>
<p>党校是在这年中秋之后开始的，然后就是每天中午一点到教室开始背书，三天一小考五天一大考，这些都算做平时成绩。除了每天中午会固定的背书之外，我早上一般会起的早一些，然后会在教室过道里背一会书，差不多要到早上第一节课开始之前。</p>
<p><strong>18-10-25</strong><br>这一天是我们积极分子的奉献日，奉献日有不同的活动，这跟不同的学院也有关系。之前几期党校的同学有去打扫烈士陵园的、有去植树的，我们那次是去老区教室办的宣传党的19大的黑板报，我其实最想做的还是植树，我觉得这对我来说会更有意义一点，毕竟还没有去植过树。</p>
<p><strong>18-10-28</strong><br>这天是学校组织去参观红色景点的社会实践，我去的是广安武胜，然后参观了乡村振兴橙子种植基地，观看了当地传统的民俗表演，还是很有意义的一天；</p>
<p>之后的整个大二上学期我就全身心投入学习了。当时的背景是这样的，离每年12月的研究生考试越来越近，加上我们学校学习氛围一向很好，然后图书馆的位置有限且离我们校区又有一点远，这样就催生出了很多在教室复习的同学，但是教室时不时有会有人上课，就得不断地换教室，所以很多人干脆直接买了小板凳小桌子摆在教学楼的过道上用来学习。</p>
<p>于是我也买了一个小板凳，开始每天早上准时6点起床，7点到教学楼与15级的师兄师姐为伴，一起背书；也是受了当时都党校时候的影响，那时候是背的党校考试的复习资料，后面党校结束后，开始看一些专业书，一直到期末。</p>
<p><strong>18-12-20</strong><br>研究生考试前夕，我还做了一些我觉得很有意义的事情，那天下午，我发动整个过道的师兄师姐一起来合张影，大家都是朝夕相处的战友，虽然可能都不认识彼此；照片中的大部分我也不认识，最后反正我认识的几个师姐都上了岸。然后晚上从图书馆回来的时候，拿着提前买的两袋大白兔奶糖，在教学楼里见人就发，然后对师兄师姐说了鼓励的话，祝他们考个好成绩！</p>
<p>临近期末，同学们都在紧张的复习准备期末考试，我也是在这个时候摸索找到了适合自己的复习方法：我会把目录撕下，然后跟着目录依次复习，然后把自己觉得重要的或者不太容易记住的知识点写在目录对应的章节处，课本过完一遍之后再做题，等到了考试前，就直接拿出目录看重点，也不用再拿书翻来翻去，因为重点都在目录上了；而且这样整个知识脉络也特别清晰。</p>
<p>因为课程比较多，然后有时候考试是上午一门下午一门，然后隔两天又是两门，复习的时间都不太够，整个学期没记错的话有13门课，包括公共课；不过我考的还是可以😁；</p>
<p>寒假干了什么早忘了，反正也没去哪玩，据我推测，大概率是在家躺尸了，偶尔去城里找同学上网……</p>
<p>然后就到了大二下学期，课程还是一如既往的多，因为之前机缘巧合之下当了手工协会的手工部部长；就要去参加我们协会举办的教学活动，一般教一些折花，穿珠子，中国结这些；中国结是我的最爱，然后我身边的朋友，我比较喜欢的老师我都送了个遍；</p>
<p>但平时大部分时间我都泡在图书馆，看书学习；因为当时课程多，作业也很多；周末的时候也在图书馆，以至于到期末的那段时间，我都感觉我眼睛经常是很干，很难受，有点用眼过度了；</p>
<p>运动会之前我认识了我另一个好哥们——蒲长松，那天正好是他生日，我去外面买了水果，回去的路上看到有一群外国人在过生日，我犹豫了一会，鼓起勇气走过去用蹩脚英语问了是谁的生日，然后我就送了他一个苹果，并祝他生日快乐！然后他叫我留下一起吃了蛋糕，从此多了一个好朋友；后来才知道，他是我们学校的研究生，那些外国人是他的学生们，他兼职教留学生汉语；</p>
<p><strong>19-04-21</strong><br>对，我大二也参加了运动会，也是报的5000，但是因为平时课比较多，我就没怎么经常去参加院上的集训；偶尔自己在操场练练；运动会那天下了好大的雨，淋着雨跑12圈半可真要命，不过成绩和去年相差不大，可累死我了😵，当时蒲长松还有他的几个学生也过来看了我的比赛，给我加油，完了还去了他家吃饭，他就租住在我们学校外面的小区里，不过后面他就搬走了，他毕业后去了另个高校教汉语；</p>
<p><strong>19-05-01</strong><br>我清楚的记得劳动节的时候是放的4天假，为啥呢，因为那四天我都在写入党材料；思想汇报，考察登记表，以及各种会议记录等等；</p>
<p><strong>19-05-07</strong><br>这一天，我光荣的加入了中国共产党，成为了一名预备党员；</p>
<p>纵观整个大二是我整个大学最刻苦，也是最忙的一年，两次一等奖学金和学年的国家励志奖学金就是最好的证明；</p>
<p>暑假，我申请了留校，打算多看些书；蒲长松也毕业了，然后他暑假去川师岗前培训；我们约好在成都碰头然后一起回南充；当时还和他的一个朋友一起看了当时大火的哪吒；然后在厕所外面明白了为啥男左女右：Men to be left because women are always right.</p>
<p><strong>19-08-06</strong><br>然后回了学校，自己学了一下python，然后把打字练了，因为自己打字特慢，而且看着打都会出错，后来练了有一月，就能盲打了，也算是这个暑假最大的收获了；</p>
<h3 id="大三篇"><a href="#大三篇" class="headerlink" title="大三篇"></a>大三篇</h3><p><strong>19-09-01</strong><br>不知不觉就到了大三，课程相对大二来说少了很多，特别是课程类型更偏向计算机了，然后我们开始更多的开始使用实训室作为我们的教室，和自习室；平时有事没事都在实训室，因此整个大三上学期除了期末那段时间去图书馆复习，其他时候都没怎么去了；</p>
<p><strong>19-09-12</strong><br>就在12开始是为期三天的全国大学生数学建模竞赛，那三天真可以用“难忘”二字形容了，数学建模竞赛是全国高校学科竞赛排行榜中第五、含金量极高的比赛；这三天的主要任务就是有一些实际生活中的难题，需要我们用数学公式表示出来，然后用程序找到一个好的解，最后写一篇论文出来；大致可以概述成建立数学模型、编程求解、论文编写三个工作；</p>
<p>当时我们只有比赛的头一天是回寝室睡的，后两天都是在实训室凑合的；但是我感觉我当时还是没有发挥好，然后我们配合也不够好，很多东西因为时间原因都没有最终体现在论文上，所以最后我们只拿了省三等奖，也算是个安慰奖吧；时至今日那段大家一起熬夜做题，吃泡面的时光依然历历在目。</p>
<p>然后数学建模也告一段落了，我也知道自己面上成绩上还比较好看，但是我自己的技术自己清楚，然后就潜下心来专研技术，但那个时候包括之前的时候都还没有一个明确的方向说我今后要干啥，我喜欢C语言，但是前两年自己摸索是啥也没做出来，就把基础学扎实了；</p>
<p>后面因为参加计算机设计大赛以及各种院上校上比赛，以及期末各科的作业，都是要求交项目，刚好大二下学期我们有个小项目组，然后把之前的项目拿来继续做了，然后不断迭代，反正在院上和校上的比赛中拿了不少奖，然后也是从这个时候接触前端的东西比较多了；</p>
<p><strong>20-01-15</strong><br>经过大三上学期的洗礼，自己的技术深入了不少，了解的东西也多了；</p>
<p>未完待续……</p>
<h3 id="大四篇"><a href="#大四篇" class="headerlink" title="大四篇"></a>大四篇</h3>]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>diary</tag>
        <tag>大学</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX-学习笔记</title>
    <url>/2021/10/12/LaTeX-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="LaTeX-简介"><a href="#LaTeX-简介" class="headerlink" title="LaTeX 简介"></a>LaTeX 简介</h3><blockquote>
<p>LaTeX, which is pronounced «Lah-tech» or «Lay-tech» (to rhyme with «blech» or «Bertolt Brecht»), is a document preparation system for high-quality typesetting. It is most often used for medium-to-large technical or scientific documents but it can be used for almost any form of publishing.</p>
</blockquote>
<p>LaTeX 是一个文档准备系统 (Document Preparing System)，它非常适用于生成高印刷质量的科技类和数学类文档。它也能够生成所有其他种类的文档，小到简单的信件，大到完整的书籍。</p>
<p>上一篇文章<a href="/2021/10/10/LaTeX%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" title="LaTeX环境搭建和配置教程">LaTeX环境搭建和配置教程</a>讲了 LaTeX 环境，本文是 LaTeX 详细用法，其内容主要归纳自《一份（不太）简短的 LaTeX 2ε 介绍》一书，文末参考连接中有该书的连接。</p>
<span id="more"></span>

<h3 id="LaTeX-基本概念"><a href="#LaTeX-基本概念" class="headerlink" title="LaTeX 基本概念"></a>LaTeX 基本概念</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>LATEX 中命令2以反斜线 \ 开头，为以下两种形式之一：</p>
<ol>
<li>反斜线和后面的一串字母，如 \LaTeX。它们以任意非字母符号（空格、数字、标点等）为界限。</li>
<li>反斜线和后面的单个非字母符号，如 $。</li>
</ol>
<p>要注意 LATEX 命令是对大小写敏感的，字母形式的 LATEX 命令忽略其后的所有连续空格。如果要人为引入空格，需要在命令后面加一对花括号阻止其忽略空格。另外也可以在命令后面紧跟一个 \␣ 命令（反斜线加空格），代表插入一个间距。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\TeX</span> ignore space.</span><br><span class="line"><span class="keyword">\TeX</span>&#123;&#125; stay space.</span><br><span class="line"><span class="keyword">\TeX</span><span class="keyword">\ </span>stay space.</span><br></pre></td></tr></table></figure>

<p>一些 LATEX 命令可以接收一些参数，参数的内容会影响命令的效果。LATEX 的参数分为可选参数和必选参数。可选参数以方括号 [] 包裹；必选参数一般以花括号 {} 包裹。还有些命令可以带一个星号 *，可以把星号看作一种特殊的可选参数。</p>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>LATEX 中还包括环境，用以令一些效果在局部生效，或是生成特殊的文档元素。LATEX 环境的用法为一对命令 \begin 和 \end：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;⟨environment name⟩&#125;[⟨optional arguments⟩]&#123;⟨mandatory arguments⟩&#125;</span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line"><span class="keyword">\end</span>&#123;⟨environment name⟩&#125;</span><br></pre></td></tr></table></figure>

<p>其中 ⟨environment name⟩ 为环境名，\begin 和 \end 中填写的环境名应当一致。类似命令，{⟨mandatory arguments⟩} 和 [⟨optional arguments⟩] 为环境所需的必选和可选参数。LATEX 环境可能需要一个或多个必选/可选参数，也可能完全不需要参数。部分环境允许嵌套使用。</p>
<h4 id="文档类"><a href="#文档类" class="headerlink" title="文档类"></a>文档类</h4><p>LATEX 源代码以一个 \documentclass 命令作为开头，其可选参数指定了文档使用的文档类；而文档类规定了 LATEX 源代码所要生成的文档的性质——普通文章、书籍、演示文稿、个人简历等等。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[⟨options⟩]&#123;⟨class-name⟩&#125;</span><br><span class="line"><span class="comment">% 指定纸张为 A4 大小，基本字号为 11pt，双面排版</span></span><br><span class="line"><span class="keyword">\documentclass</span>[11pt,twoside,a4paper]&#123;article&#125; </span><br></pre></td></tr></table></figure>

<p>其中 ⟨class-name⟩ 为文档类的名称，如 LATEX 提供的 article | book | report（称为标准文档类），在其基础上派生的一些文档类如支持中文排版的 ctexart | ctexbook | ctexrep，或者有其它功能的一些文档类，如 moderncv | beamer 等。</p>
<p>可选参数 ⟨options⟩ 为文档类指定选项，以全局地规定一些排版的参数，如字号、纸张大小、单双面等等；更多可选参数见附录。</p>
<h4 id="宏包"><a href="#宏包" class="headerlink" title="宏包"></a>宏包</h4><p>在 \documentclass 和 \begin{document} 之间的位置称为导言区。在导言区中一般会使用 \usepackage 调用宏包，以及会进行对文档的全局设置。</p>
<p>宏包就是一些增强或补充 LATEX 功能的扩展，比如排版复杂的表格、插入图片、增加颜色甚至超链接等等。调用宏包的方法非常类似调用文档类的方法：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[⟨options⟩]&#123;⟨package-name⟩&#125;</span><br><span class="line"><span class="comment">% 一次性调用三个排版表格常用的宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;tabularx, makecell, multirow&#125;</span><br></pre></td></tr></table></figure>
<p>\usepackage 可以一次性调用多个宏包，在 ⟨package-name⟩ 中用逗号隔开。这种用法一般不要指定选项；使用多个宏包时指定选项，相当于给每个宏包指定同样的选项。如果有某个宏包不能识别指定的选项，则会出错。</p>
<p>在命令行中可以通过<code>texdoc ⟨pkg-name⟩</code>命令打开宏包本地的英文文档。</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>当编写长篇文档时，可以将源文件分割成若干个文件，例如将每章内容单独写在一个文件中，会大大简化修改和校对的工作。LATEX 提供了命令 \include 用来在源代码里插入文件：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\include</span>&#123;⟨filename⟩&#125;</span><br><span class="line"><span class="keyword">\include</span>&#123;chapters/a.tex&#125; <span class="comment">% 相对路径</span></span><br><span class="line"><span class="keyword">\include</span>&#123;/home/Bob/file.tex&#125; <span class="comment">% Linux/macOS 绝对路径</span></span><br><span class="line"><span class="keyword">\include</span>&#123;D:/file.tex&#125; <span class="comment">% Windows 绝对路径，用正斜线</span></span><br></pre></td></tr></table></figure>

<p>⟨filename⟩ 为文件名，如果和要编译的主文件不在一个目录中，则要加上相对或绝对路径；⟨filename⟩ 可以不带扩展名，此时默认扩展名为 .tex。\include 在读入 ⟨filename⟩ 之前会另起一页，因此可以使用 \input 命令，它纯粹是把文件里的内容插入：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 插入内容，不换页</span></span><br><span class="line"><span class="keyword">\input</span>&#123;⟨filename⟩&#125;</span><br><span class="line"><span class="comment">% 限制引用的文件</span></span><br><span class="line"><span class="keyword">\includeonly</span>&#123;⟨filename1⟩,⟨filename2⟩,…&#125;</span><br></pre></td></tr></table></figure>

<p>另外 LATEX 提供了一个 \includeonly 命令来组织文件，用于导言区，指定只载入某些文件：导言区使用了 \includeonly 后，正文中不在其列表范围的 \include 命令不会起效。</p>
<blockquote>
<p>一个实用的工具宏包 syntonly。加载这个宏包后，在导言区使用 \syntaxonly 命令，可令 LATEX 编译后不生成 DVI 或者 PDF 文档，只排查错误，编译速度会快不少：</p>
</blockquote>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;syntonly&#125;</span><br><span class="line"><span class="keyword">\syntaxonly</span></span><br></pre></td></tr></table></figure>

<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><strong>引擎</strong>：全称为排版引擎，是编译源代码并生成文档的程序，如 pdfTEX、XƎTEX 等。有时也称为编译器。</li>
<li><strong>格式</strong>：是定义了一组命令的代码集。LATEX 就是最广泛应用的一个格式，高德纳本人还编写了一个简单的 plain TEX 格式，没有定义诸如 \documentclass 和 \section 等等命令。</li>
<li><strong>编译命令</strong>：是实际调用的、结合了引擎和格式的命令。如 xelatex 命令是结合 XƎTEX 引擎和 LATEX 格式的一个编译命令。</li>
</ul>
<h3 id="LaTeX-排版文字"><a href="#LaTeX-排版文字" class="headerlink" title="LaTeX 排版文字"></a>LaTeX 排版文字</h3><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>Unicode 是一个多国字符的集合，覆盖了几乎全球范围内的语言文字。UTF-8 是 Unicode 的一套编码方案，一个字符可以由一个到四个字节编码，其中单字节字符兼容 ASCII 编码。</p>
<p>latex 命令及 pdflatex 命令下可以使用 inputenc 宏包支持 UTF-8 编码：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[utf8]&#123;inputenc&#125;</span><br></pre></td></tr></table></figure>

<p>xelatex 和 lualatex 命令原生支持 UTF-8 编码，而且也不适用 inputenc 宏包。将 .tex 源代码保存为 UTF-8 编码，并借助 fontspec 宏包调用适当的字体，就可以在源代码中输入任意语言的文字。</p>
<h4 id="中文排版"><a href="#中文排版" class="headerlink" title="中文排版"></a>中文排版</h4><p>ctex 宏包和文档类是对 CJK 和 xeCJK 等宏包的进一步封装。ctex 文档类包括 ctexart / ctexrep / ctexbook，是对 LATEX 的三个标准文档类的封装，对 LATEX 的排版样式做了许多调整，以切合中文排版风格。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">中文<span class="keyword">\LaTeX</span>&#123;&#125;排版。</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>注：建议在使用 ctex 宏包和文档类时总是将源代码保存为 UTF-8 编码，并用 xelatex 命令编译。</p>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><h5 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h5><p>LATEX 源代码中，空格键和 Tab 键输入的空白字符视为“空格”。连续的若干个空白字符视为一个空格。一行开头的空格忽略不计。</p>
<p>行末的回车视为一个空格；但连续两个回车，也就是空行，会将文字分段。多个空行被视为一个空行。也可以在行末使用 \par 命令分段。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">An empty line starts a new paragraph.<span class="keyword">\par</span> 123456</span><br><span class="line"><span class="comment">% A \verb|\par| command also starts a new line.</span></span><br></pre></td></tr></table></figure>

<h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><p>以下字符在 LATEX 里有特殊用途，如 % 表示注释，$、^、_ 等用于排版数学公式，&amp; 用于排版表格，等等。直接输入这些字符得不到对应的符号，还往往会出错：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># $ &amp; &#123; &#125; _ ^ ~ \ %</span><br></pre></td></tr></table></figure>

<p>若要使用特殊字符需要在前面添加反斜杠 \，进行转义；其中 ^ 和 ~ 两个命令是需要带参数的，如果不加一对花括号（空参数），就将后面的字符作为参数，形成重音效果；而 \ 被直接定义成了手动换行的命令，输入反斜杠就只好用 \textbackslash。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\#</span> <span class="keyword">\$</span> <span class="keyword">\%</span> <span class="keyword">\&amp;</span> <span class="keyword">\&#123;</span> <span class="keyword">\&#125;</span> <span class="keyword">\_</span></span><br><span class="line"><span class="keyword">\^</span>&#123;&#125; <span class="keyword">\~</span>&#123;&#125; <span class="keyword">\textbackslash</span></span><br></pre></td></tr></table></figure>

<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>LATEX 用 % 字符作为注释。在这个字符之后直到行末，所有的字符都被忽略，行末的回车也不引入空格。</p>
<h5 id="连字"><a href="#连字" class="headerlink" title="连字"></a>连字</h5><p>西文排版中经常会出现连字（Ligatures），常见的有 ff / fi / fl / ffi / ffl。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">It&#x27;s difficult to find <span class="keyword">\ldots</span> .<span class="keyword">\\</span></span><br><span class="line">It&#x27;s dif&#123;&#125;f&#123;&#125;icult to f&#123;&#125;ind <span class="keyword">\ldots</span> .</span><br></pre></td></tr></table></figure>

<h5 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h5><p>LATEX 的单引号 ‘ ’ 用 ` 和 ‘ 输入；双引号 “ ” 用 `` 和 ‘’ 输入，虽然 “ 也能表示双引号，但没有合适的单个符号用来表示前双引号，所以不常用在正文。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">``Please press the `x&#x27; key.&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="连字号与破折号"><a href="#连字号与破折号" class="headerlink" title="连字号与破折号"></a>连字号与破折号</h5><p>LATEX 中有三种长度的“横线”可用：连字号（hyphen）、短破折号（en-dash）和长破折号（em-dash）。它们分别有不同的用途：连字号 - 用来组成复合词；短破折号 – 用来连接数字表示范围；长破折号 — 用来连接单词，与中文语境中的破折号用法类似。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">daughter-in-law, X-rated<span class="keyword">\\</span></span><br><span class="line">pages 13--67<span class="keyword">\\</span></span><br><span class="line">yes---or no?</span><br></pre></td></tr></table></figure>

<h5 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h5><p>LATEX 提供了命令 \ldots 来生成省略号，相对于直接输入三个点的方式更为合理。\ldots和 \dots 是两个等效的命令。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">one, two, three, <span class="keyword">\ldots</span> one hundred.<span class="keyword">\\</span></span><br><span class="line">A, B, C, <span class="keyword">\dots</span> Z.</span><br></pre></td></tr></table></figure>

<h5 id="波浪号"><a href="#波浪号" class="headerlink" title="波浪号"></a>波浪号</h5><p>~ 命令，它可以用来输入波浪号，但位置靠顶端（~ 命令主要用作重音，参考下一小节）。西文中较少将波浪号作为标点符号使用，通常使用中文的全角波浪号（～）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">H<span class="keyword">\^</span>otel, na<span class="keyword">\&quot;</span><span class="keyword">\i</span> ve, <span class="keyword">\&#x27;</span>el<span class="keyword">\`</span>eve,<span class="keyword">\\</span></span><br><span class="line">sm<span class="keyword">\o</span> rrebr<span class="keyword">\o</span> d, !`Se<span class="keyword">\ </span>norita!,<span class="keyword">\\</span></span><br><span class="line">Sch<span class="keyword">\&quot;</span>onbrunner Schlo<span class="keyword">\ss</span>&#123;&#125;</span><br><span class="line">Stra<span class="keyword">\ss</span> e</span><br></pre></td></tr></table></figure>

<img src="/2021/10/12/LaTeX-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/LaTeX%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E9%87%8D%E9%9F%B3%E5%92%8C%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6.png" class="">

<h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><p>LATEX 定义了 \underline 命令用来为文字添加下划线；但 \underline 命令生成下划线的样式比较机械，不同的单词可能生成高低各异的下划线，并且无法换行。</p>
<p>可以使用 ulem 宏包解决了这一问题，它提供的 \uline 命令能够轻松生成自动换行的下划线：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">An <span class="keyword">\underline</span>&#123;underlined&#125; text.</span><br><span class="line"><span class="comment">% 需要 \usepackage&#123;ulem&#125;</span></span><br><span class="line">An example of <span class="keyword">\uline</span>&#123;some long and underlined words.&#125;</span><br><span class="line"></span><br><span class="line">Some <span class="keyword">\emph</span>&#123;emphasized words, including <span class="keyword">\emph</span>&#123;double-emphasized&#125; words&#125;, are shown here.</span><br></pre></td></tr></table></figure>
<p>\emph 命令用来将文字变为斜体以示强调。如果在本身已经用 \emph 命令强调的文字内部嵌套使用 \emph 命令，内部则使用直立体文字：</p>
<h4 id="断行和断页"><a href="#断行和断页" class="headerlink" title="断行和断页"></a>断行和断页</h4><p>LATEX 将文字段落在合适的位置进行断行，尽可能做到每行的宽度一致，并且单词间距匀称。文字段落和公式、图表等内容从上到下顺序排布，并在合适的位置断页，分割成匀称的页面。在绝大多数时候，我们无需自己操心断行和断页。但偶尔会遇到需要手工调整的地方。</p>
<h5 id="手动断行"><a href="#手动断行" class="headerlink" title="手动断行"></a>手动断行</h5><p>使用以下两个命令实现断行，它们有两点区别：一是 \ 可以带可选参数 ⟨length⟩，用于在换行处向下增加垂直间距，而 \newline 不带可选参数；二是 \ 也在表格、公式等地方用于分行，而 \newline 只用于文本段落中。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\\</span>[⟨length⟩]</span><br><span class="line"><span class="keyword">\\</span>[20pt] <span class="comment">% 增加 20pt 单位的垂直间距</span></span><br><span class="line"><span class="keyword">\newline</span></span><br></pre></td></tr></table></figure>

<h5 id="手动断页"><a href="#手动断页" class="headerlink" title="手动断页"></a>手动断页</h5><p>断页的命令也有两个，通常情况下两个命令都能起到另起一页的作用，但有一些区别：一是在双栏排版中 \newpage 只起到另起一栏的作用；二是涉及到浮动体的排版上行为不同。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newpage</span> </span><br><span class="line"><span class="keyword">\clearpage</span></span><br></pre></td></tr></table></figure>

<h5 id="自定义断行断页"><a href="#自定义断行断页" class="headerlink" title="自定义断行断页"></a>自定义断行断页</h5><p>可以通过以下命令告诉 LATEX 哪些地方适合断页，哪些地方不适合：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\linebreak</span>[⟨n⟩]</span><br><span class="line"><span class="keyword">\nolinebreak</span>[⟨n⟩]</span><br><span class="line"></span><br><span class="line"><span class="keyword">\pagebreak</span>[⟨n⟩]</span><br><span class="line"><span class="keyword">\nopagebreak</span>[⟨n⟩]</span><br></pre></td></tr></table></figure>

<p>以上命令都带一个可选参数，用数字 ⟨n⟩ 代表适合/不适合的程度，取值范围为 0-4，不带可选参数时，缺省为 4。比如 \linebreak[3] 意味着此处在断行时优先考虑；\nopagebreak 或\nopagebreak[4] 意味着禁止在此处断页。</p>
<p>以上命令适合给出优先考虑断行断页/禁止断行断页的位置，但不适合直接拿来断行或断页，使用 \newline 或 \newpage 等是更好的选择。因为 \newline 和 \newpage 会在断行/断页位置正确添加空白，但 \linebreak 和 \pagebreak 不能，它们的强行断行/断页会导致 LATEX 报 Underfull \hbox 等警告。</p>
<h5 id="断词"><a href="#断词" class="headerlink" title="断词"></a>断词</h5><p>如果 LATEX 遇到了很长的英文单词，仅在单词之间的位置断行无法生成宽度匀称的行时，就要考虑从单词中间断开。对于绝大部分单词，LATEX 能够找到合适的断词位置，在断开的行尾加上连字符 -。如果一些单词没能自动断词，我们可以在单词内手动使用 - 命令指定断词的位置。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">a very very very long word abcdefghijklmnop<span class="keyword">\-</span>qrstuvwxyz.</span><br></pre></td></tr></table></figure>

<h3 id="LaTeX-文档元素"><a href="#LaTeX-文档元素" class="headerlink" title="LaTeX 文档元素"></a>LaTeX 文档元素</h3><p>本章了解一个结构化的文档所依赖的各种元素——章节、目录、列表、图表、交叉引用、脚注等等。</p>
<h4 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h4><p>一篇结构化的、条理清晰文档一定是层次分明的，通过不同的命令分割为章、节、小节。三个标准文档类 article、report 和 book1提供了划分章节的命令：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\chapter</span>&#123;⟨title⟩&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;⟨title⟩&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;⟨title⟩&#125;</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;⟨title⟩&#125;</span><br><span class="line"><span class="keyword">\paragraph</span>&#123;⟨title⟩&#125;</span><br><span class="line"><span class="keyword">\subparagraph</span>&#123;⟨title⟩&#125;</span><br></pre></td></tr></table></figure>

<p>其中 \chapter 只在 book 和 report 文档类有定义。这些命令生成章节标题，并能够自动编号。除此之外 LATEX 还提供了 \part 命令，用来将整个文档分割为大的分块，但不影响 \chapter 或 \section 等的编号。</p>
<p>上述命令除了生成带编号的标题之外，还向目录中添加条目，并影响页眉页脚的内容。每个命令有两种变体：</p>
<ul>
<li>带可选参数的变体：\section[⟨short title⟩]{⟨title⟩} 标题使用 ⟨title⟩ 参数，在目录和页眉页脚中使用 ⟨short title⟩ 参数；</li>
<li>带星号的变体：\section*{⟨title⟩} 标题不带编号，也不生成目录项和页眉页脚。不影响较低层级的 \paragraph 和 \subparagraph 命令。</li>
</ul>
<p>带编号层级：</p>
<ul>
<li>article 文档类带编号的层级为 \section / \subsection / \subsubsection 三级；</li>
<li>report/book 文档类带编号的层级为 \chapter / \section / \subsection 三级。</li>
</ul>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>在 LATEX 中生成目录非常容易，只需在合适的地方使用命令，而正确生成目录项，一般需要编译两次源代码。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\tableofcontents</span></span><br></pre></td></tr></table></figure>

<p>这个命令会生成单独的一章（book / report）或一节（article），标题默认为 “Contents”，可<br>通过后续给出的方法定制标题。\tableofcontents 生成的章节默认不写入目录（\section*<br>或 \chapter*），可使用 tocbibind 等宏包修改设置。</p>
<p>有时我们使用了 \chapter* 或 \section* 这样不生成目录项的章节标题命令，而又想手动生成该章节的目录项，可以在标题命令后面使用：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\addcontentsline</span>&#123;toc&#125;&#123;⟨level⟩&#125;&#123;⟨title⟩&#125;</span><br><span class="line"><span class="keyword">\addcontentsline</span>&#123;toc&#125;&#123;section&#125;&#123;manual add title&#125;</span><br></pre></td></tr></table></figure>

<p>其中 ⟨level⟩ 为章节层次 chapter 或 section 等，⟨title⟩ 为出现于目录项的章节标题。titletoc、tocloft 等宏包提供了具体定制目录项格式的功能，详情请参考宏包的帮助文档。</p>
<h4 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h4><p>所有标准文档类都提供了一个 \appendix 命令将正文和附录分开2，使用 \appendix 后，最高一级章节改为使用拉丁字母编号，从 A 开始。</p>
<p>book 文档类还提供了前言、正文、后记结构的划分命令：</p>
<ul>
<li>\frontmatter 前言部分，页码为小写罗马字母格式；其后的 \chapter 不编号。</li>
<li>\mainmatter 正文部分，页码为阿拉伯数字格式，从 1 开始计数；其后的章节编号正常。</li>
<li>\backmatter 后记部分，页码格式不变，继续正常计数；其后的 \chapter 不编号。</li>
</ul>
<p>以上三个命令还可和 \appendix 命令结合，生成有前言、正文、附录、后记四部分的文档。章节和目录部分再结合之前的 \include 命令和其它一些命令示意了一份完整的文档结构。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[...]&#123;book&#125;</span><br><span class="line"><span class="comment">% 导言区，加载宏包和各项设置，包括参考文献、索引等</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;makeidx&#125;</span><br><span class="line"><span class="keyword">\makeindex</span></span><br><span class="line"><span class="keyword">\bibliographystyle</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\frontmatter</span></span><br><span class="line"><span class="keyword">\maketitle</span> <span class="comment">% 标题页</span></span><br><span class="line"><span class="keyword">\include</span>&#123;preface&#125; <span class="comment">% 前言章节 preface.tex</span></span><br><span class="line"><span class="keyword">\tableofcontents</span></span><br><span class="line"><span class="keyword">\mainmatter</span></span><br><span class="line"><span class="keyword">\include</span>&#123;chapter1&#125; <span class="comment">% 第一章 chapter1.tex</span></span><br><span class="line"><span class="keyword">\include</span>&#123;chapter2&#125; <span class="comment">% 第二章 chapter2.tex</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">\appendix</span></span><br><span class="line"><span class="keyword">\include</span>&#123;appendixA&#125; <span class="comment">% 附录 A appendixA.tex</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">\backmatter</span></span><br><span class="line"><span class="keyword">\include</span>&#123;prologue&#125; <span class="comment">% 后记 prologue.tex</span></span><br><span class="line"><span class="keyword">\bibliography</span>&#123;...&#125; <span class="comment">% 利用 BibTeX 工具生成参考文献</span></span><br><span class="line"><span class="keyword">\printindex</span> <span class="comment">% 利用 makeindex 工具生成索引</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标题页"><a href="#标题页" class="headerlink" title="标题页"></a>标题页</h4><p>LATEX 支持生成简单的标题页。首先需要给定标题和作者等信息：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;⟨title⟩&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;⟨author⟩&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;⟨date⟩&#125;</span><br></pre></td></tr></table></figure>

<p>其中前两个命令是必须的（不用 \title 会报错；不用 \author 会警告），\date 命令可选。LATEX 还提供了一个 \today 命令自动生成当前日期，\date 默认使用 \today。在 \title、\author 等命令内可以使用 \thanks 命令生成标题页的脚注，用 \and 隔开多个人名。</p>
<p>在信息给定后，就可以使用 \maketitle 命令生成一个简单的标题页了。下面的代码给出了一个标题页的示例。article 文档类的标题默认不单独成页，而 report 和 book 默认单独成页。可在 \documentclass 命令调用文档类时指定 titlepage / notitlepage 选项以修改默认的行为。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;Test title&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123; Mary<span class="keyword">\thanks</span>&#123;E-mail:*****@***.com&#125;</span><br><span class="line"><span class="keyword">\and</span> Ted<span class="keyword">\thanks</span>&#123;Corresponding author&#125;</span><br><span class="line"><span class="keyword">\and</span> Louis&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 在文档中</span></span><br><span class="line"><span class="keyword">\maketitle</span></span><br></pre></td></tr></table></figure>

<p>LATEX 标准类还提供了一个简单的 titlepage 环境，生成不带页眉页脚的一页。用户可以在这个环境中使用各种排版元素自由发挥，生成自定义的标题页以替代 \maketitle 命令。甚至可以利用 titlepage 环境重新定义 \maketitle：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\maketitle</span>&#125;&#123;<span class="keyword">\begin</span>&#123;titlepage&#125;</span><br><span class="line">... <span class="comment">% 用户自定义命令</span></span><br><span class="line"><span class="keyword">\end</span>&#123;titlepage&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，为标准文档类指定了 titlepage 选项以后，使用 \maketitle 命令生成的标题页就是一个 titlepage 环境。</p>
<p>以上是 LATEX 标准文档类的标题页相关命令用法。在各种文档模板中经常有自定义的标题页，有可能需要除了 \title 和 \author 以外的命令给定信息，用法也可能与标准文档类的不一致（甚至有些模板可能没有定义 titlepage 等环境）。使用文档模板前一定要仔细阅读文档模板的帮助文档。</p>
<h4 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h4><p>交叉引用是 LATEX 强大的自动排版功能的体现之一。在能够被交叉引用的地方，如章节、公式、图表、定理等位置使用 \label 命令：为了生成正确的交叉引用，一般也需要多次编译源代码。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\label</span>&#123;⟨label-name⟩&#125;</span><br></pre></td></tr></table></figure>

<p>之后可以在别处使用 \ref 或 \pageref 命令，分别生成交叉引用的编号和页码：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ref</span>&#123;⟨label-name⟩&#125;</span><br><span class="line"><span class="keyword">\pageref</span>&#123;⟨label-name⟩&#125;</span><br></pre></td></tr></table></figure>

<p>\label 命令可用于记录各种类型的交叉引用，使用位置分别为：</p>
<ul>
<li>章节标题 在章节标题命令 \section 等之后紧接着使用。</li>
<li>行间公式 单行公式在公式内任意位置使用；多行公式在每一行公式的任意位置使用。</li>
<li>有序列表 在 enumerate 环境的每个 \item 命令之后、下一个 \item 命令之前任意位置使用。</li>
<li>图表标题 在图表标题命令 \caption 之后紧接着使用。</li>
<li>定理环境 在定理环境内部任意位置使用。</li>
</ul>
<p>在使用不记编号的命令形式（\section<em>、\caption</em>、带可选参数的 \item 命令等）时不要使用 \label 命令，否则生成的引用编号不正确。</p>
<h4 id="脚注边注"><a href="#脚注边注" class="headerlink" title="脚注边注"></a>脚注边注</h4><p>使用 \footnote 命令可以在页面底部生成一个脚注：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\footnote</span>&#123;⟨footnote⟩&#125;</span><br></pre></td></tr></table></figure>

<p>有些情况下（比如在表格环境、各种盒子内）使用 \footnote 并不能正确生成脚注。我们可以分两步进行，先使用 \footnotemark 为脚注计数，再在合适的位置用 \footnotetext 生成脚注。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;l&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">“天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。”<span class="keyword">\footnotemark</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\footnotetext</span>&#123;表格里的名句出自《千字文》。&#125;</span><br></pre></td></tr></table></figure>

<p>使用 \marginpar 命令可在边栏位置生成边注：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\marginpar</span>[⟨left-margin⟩]&#123;⟨right-margin⟩&#125;</span><br><span class="line"><span class="keyword">\marginpar</span>&#123;<span class="keyword">\footnotesize</span> 边注较窄，不要写过多文字，最好设置较小的字号。&#125;</span><br></pre></td></tr></table></figure>

<p>如果只给定了 ⟨right-margin⟩，那么边注在奇偶数页文字相同；如果同时给定了 ⟨left-margin⟩，则偶数页使用 ⟨left-margin⟩ 的文字。</p>
<h4 id="特殊环境"><a href="#特殊环境" class="headerlink" title="特殊环境"></a>特殊环境</h4><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p>LATEX 提供了基本的有序和无序列表环境 enumerate 和 itemize，两者的用法很类似，都用 \item 标明每个列表项。enumerate 环境会自动对列表项编号。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 有序列表</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> An item.</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> A nested item.<span class="keyword">\label</span>&#123;itref&#125;</span><br><span class="line"><span class="keyword">\item</span>[*] A starred item.</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> Reference(<span class="keyword">\ref</span>&#123;itref&#125;).</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 无序列表</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> An item.</span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> A nested item.</span><br><span class="line"><span class="keyword">\item</span>[+] A `plus&#x27; item.</span><br><span class="line"><span class="keyword">\item</span> Another item.</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> Go back to upper level.</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure>

<p>其中 \item 可带一个可选参数，将有序列表的计数或者无序列表的符号替换成自定义的符号。列表可以嵌套使用，最多嵌套四层。</p>
<p>关键字环境 description 的用法与以上两者类似，不同的是 \item 后的可选参数用来写关键字，以粗体显示，一般是必填的：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;description&#125;</span><br><span class="line"><span class="keyword">\item</span>[Enumerate] Numbered list.</span><br><span class="line"><span class="keyword">\item</span>[Itemize] Non-numbered list.</span><br><span class="line"><span class="keyword">\end</span>&#123;description&#125;</span><br></pre></td></tr></table></figure>

<p>各级无序列表的符号由命令 \labelitemi 到 \labelitemiv 定义，可以简单地重新定义它们；而有序列表的符号由命令 \labelenumi 到 \labelenumiv 定义，重新定义这些命令还需要用到计数器相关命令：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 无序列表</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\labelitemi</span>&#125;&#123;<span class="keyword">\ddag</span>&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\labelitemii</span>&#125;&#123;<span class="keyword">\dag</span>&#125;</span><br><span class="line"><span class="comment">% 有序列表</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\labelenumi</span>&#125;&#123;<span class="keyword">\Alph</span>&#123;enumi&#125;&gt;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对齐环境"><a href="#对齐环境" class="headerlink" title="对齐环境"></a>对齐环境</h5><p>center、flushleft 和 flushright 环境分别用于生成居中、左对齐和右对齐的文本环境。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125; … <span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushleft&#125; … <span class="keyword">\end</span>&#123;flushleft&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushright&#125; … <span class="keyword">\end</span>&#123;flushright&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，还可以用以下命令直接改变文字的对齐方式：\centering \raggedright \raggedleft；</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\centering</span></span><br><span class="line">Centered text paragraph.</span><br><span class="line"><span class="keyword">\raggedright</span></span><br><span class="line">Left-aligned text paragraph.</span><br><span class="line"><span class="keyword">\raggedleft</span></span><br><span class="line">Right-aligned text paragraph.</span><br></pre></td></tr></table></figure>

<p>三个命令和对应的环境经常被误用，有直接用所谓 \flushleft 命令或者 raggedright 环境的，都是不甚严格的用法（即使它们可能有效）。有一点可以将两者区分开来：center 等环境会在上下文产生一个额外间距，而 \centering 等命令不产生，只是改变对齐方式。</p>
<h5 id="引用环境"><a href="#引用环境" class="headerlink" title="引用环境"></a>引用环境</h5><p>LATEX 提供了两种引用的环境：quote 用于引用较短的文字，首行不缩进；quotation 用于引用若干段文字，首行缩进。引用环境较一般文字有额外的左右缩进。verse 用于排版诗歌，与 quotation 恰好相反，verse 是首行悬挂缩进的。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% quote</span></span><br><span class="line">Francis Bacon says:</span><br><span class="line"><span class="keyword">\begin</span>&#123;quote&#125;</span><br><span class="line">Knowledge is power.</span><br><span class="line"><span class="keyword">\end</span>&#123;quote&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% quotation</span></span><br><span class="line">《木兰诗》：</span><br><span class="line"><span class="keyword">\begin</span>&#123;quotation&#125;</span><br><span class="line">万里赴戎机，关山度若飞。</span><br><span class="line">朔气传金柝，寒光照铁衣。</span><br><span class="line">将军百战死，壮士十年归。</span><br><span class="line">归来见天子，天子坐明堂。</span><br><span class="line">策勋十二转，赏赐百千强。……</span><br><span class="line"><span class="keyword">\end</span>&#123;quotation&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% verse</span></span><br><span class="line">Rabindranath Tagore&#x27;s short poem:</span><br><span class="line"><span class="keyword">\begin</span>&#123;verse&#125;</span><br><span class="line">Beauty is truth&#x27;s smile</span><br><span class="line">when she beholds her own face in</span><br><span class="line">a perfect mirror.</span><br><span class="line"><span class="keyword">\end</span>&#123;verse&#125;</span><br></pre></td></tr></table></figure>

<h5 id="摘要环境"><a href="#摘要环境" class="headerlink" title="摘要环境"></a>摘要环境</h5><p>摘要环境 abstract 默认只在标准文档类中的 article 和 report 文档类可用，一般用于紧跟\maketitle 命令之后介绍文档的摘要。如果文档类指定了 titlepage 选项，则单独成页；反之，单栏排版时相当于一个居中的小标题加一个 quotation 环境，双栏排版时相当于 \section* 定义的一节。</p>
<h5 id="代码环境"><a href="#代码环境" class="headerlink" title="代码环境"></a>代码环境</h5><p>有时我们需要将一段代码原样转义输出，这就要用到代码环境 verbatim，它以等宽字体排版代码，回车和空格也分别起到换行和空位的作用；带星号的版本更进一步将空格显示成 ␣。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;verbatim&#125;<span class="string"></span></span><br><span class="line"><span class="string">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">std::cout &lt;&lt; &quot;Hello, world!&quot;</span></span><br><span class="line"><span class="string">&lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span><span class="keyword">\end</span>&#123;verbatim&#125;</span><br></pre></td></tr></table></figure>

<p>要排版简短的代码或关键字，可使用 \verb 命令：⟨delim⟩ 标明代码的分界位置，前后必须一致，除字母、空格或星号外，可任意选择使得不与代码本身冲突，习惯上使用 | 符号。同 verbatim 环境，\verb 后也可以带一个星号，以显示空格。\verb 命令对符号的处理比较复杂，一般不能用在其它命令的参数里，否则多半会出错。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\verb</span>⟨<span class="string">delim⟩</span>⟨code⟩⟨delim⟩</span><br><span class="line"><span class="keyword">\verb</span>|<span class="string">\LaTeX</span>|</span><br><span class="line"><span class="keyword">\verb</span>+<span class="string">(a || b)</span>+ <span class="keyword">\verb</span>*<span class="string">+(a || b)+</span></span><br></pre></td></tr></table></figure>

<p>verbatim 宏包优化了 verbatim 环境的内部命令，并提供了 \verbatiminput 命令用来直接读入文件生成代码环境。fancyvrb 宏包提供了可定制格式的 Verbatim 环境；listings 宏包更进一步，可生成关键字高亮的代码环境，支持各种程序设计语言的语法和关键字。详情请参考各自的帮助文档。</p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>排版表格最基本的 tabular 环境用法为：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;⟨column-spec⟩&#125;</span><br><span class="line">⟨item1⟩ <span class="built_in">&amp;</span> ⟨item2⟩ <span class="built_in">&amp;</span> … <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">⟨item1⟩ <span class="built_in">&amp;</span> ⟨item2⟩ <span class="built_in">&amp;</span> … <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用 tabular 环境的话，会和周围的文字混排。tabular 环境可带一个可选参数控制垂直对齐（默认是垂直居中）；但是通常情况下，tabular 环境一般会放置在 table 浮动体环境中，并用 \caption 命令加标题。</p>
<h5 id="列格式"><a href="#列格式" class="headerlink" title="列格式"></a>列格式</h5><p>tabular 环境使用 ⟨column-spec⟩ 参数指定表格的列数以及每列的格式。且表格中每行的单元格数目不能多于列格式里 l/c/r/p 的总数（可以少于这个总数），否则出错。</p>
<table>
<thead>
<tr>
<th align="left">列格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">l/c/r</td>
<td align="left">单元格内容左对齐/居中/右对齐，不折行</td>
</tr>
<tr>
<td align="left">p{⟨width⟩}</td>
<td align="left">单元格宽度固定为 ⟨width⟩，可自动折行</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">绘制竖线</td>
</tr>
<tr>
<td align="left">@{⟨string⟩}</td>
<td align="left">自定义内容 ⟨string⟩</td>
</tr>
</tbody></table>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|l|c|r|&#125;</span><br><span class="line">    <span class="keyword">\hline</span></span><br><span class="line">    left <span class="built_in">&amp;</span> center <span class="built_in">&amp;</span> right <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>

<p>@ 格式可在单元格前后插入任意的文本，但同时它也消除了单元格前后额外添加的间距。@格式可以适当使用以充当“竖线”。特别地，@{} 可直接用来消除单元格前后的间距：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;@&#123;&#125; r@&#123;:&#125;lr @&#123;&#125;&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> one <span class="keyword">\\</span></span><br><span class="line">11 <span class="built_in">&amp;</span> 3 <span class="built_in">&amp;</span> eleven <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>

<p>另外 LATEX 还提供了简便的将格式参数重复的写法 *{⟨n⟩{⟨column-spec⟩}，比如以下两种写法是等效的：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|c|c|c|p&#123;4em&#125;|p&#123;4em&#125;|&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|*&#123;5&#125;&#123;c|&#125;*&#123;2&#125;&#123;p&#123;4em&#125;|&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>有时需要为整列修饰格式，比如整列改变为粗体，如果每个单元格都加上 \bfseries 命令会比较麻烦。array 宏包提供了辅助格式 &gt; 和 &lt;，用于给列格式前后加上修饰命令：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;array&#125;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;&gt;&#123;<span class="keyword">\itshape</span>&#125;r&lt;&#123;*&#125;l&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">italic <span class="built_in">&amp;</span> normal <span class="keyword">\\</span></span><br><span class="line">column <span class="built_in">&amp;</span> column <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>

<p>array 宏包还提供了类似 p 格式的 m 格式和 b 格式，三者分别在垂直方向上靠顶端对齐、居中以及底端对齐。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newcommand</span><span class="keyword">\txt</span></span><br><span class="line">&#123;a b c d e f g h i&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;cp&#123;2em&#125;m&#123;2em&#125;b&#123;2em&#125;&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">pos <span class="built_in">&amp;</span> <span class="keyword">\txt</span> <span class="built_in">&amp;</span> <span class="keyword">\txt</span> <span class="built_in">&amp;</span> <span class="keyword">\txt</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>

<h5 id="列宽"><a href="#列宽" class="headerlink" title="列宽"></a>列宽</h5><p>LATEX 本身提供了 tabular* 环境用来排版定宽表格，但是不太方便使用，比如要用到 @ 格式插入额外命令，令单元格之间的间距为 \fill，但即使这样仍然有瑕疵：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular*&#125;&#123;14em&#125;<span class="comment">%</span></span><br><span class="line">&#123;@&#123;<span class="keyword">\extracolsep</span>&#123;<span class="keyword">\fill</span>&#125;&#125;|c|c|c|c|&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">A <span class="built_in">&amp;</span> B <span class="built_in">&amp;</span> C <span class="built_in">&amp;</span> D <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c <span class="built_in">&amp;</span> d <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular*&#125;</span><br></pre></td></tr></table></figure>

<p>tabularx 宏包为我们提供了方便的解决方案。它引入了一个 X 列格式，类似 p 列格式，不过会根据表格宽度自动计算列宽，多个 X 列格式平均分配列宽。X 列格式也可以用 array 里的辅助格式修饰对齐方式：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabularx&#125;&#123;14em&#125;<span class="comment">%</span></span><br><span class="line">&#123;|*&#123;4&#125;&#123;&gt;&#123;<span class="keyword">\centering</span><span class="keyword">\arraybackslash</span>&#125;X|&#125;&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">A <span class="built_in">&amp;</span> B <span class="built_in">&amp;</span> C <span class="built_in">&amp;</span> D <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c <span class="built_in">&amp;</span> d <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabularx&#125;</span><br></pre></td></tr></table></figure>

<h5 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h5><p>通过 \hline 命令绘制表格线，而 \cline{⟨i⟩-⟨j⟩} 命令用来绘制跨越部分单元格的横线：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|c|&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3 <span class="keyword">\\</span> <span class="keyword">\cline</span>&#123;1-2&#125;</span><br><span class="line">4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6 <span class="keyword">\\</span> <span class="keyword">\cline</span>&#123;3-3&#125;</span><br><span class="line">7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9 <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p>在科技论文排版中广泛应用的表格形式是三线表，形式干净简明。三线表由 booktabs 宏包支持，它提供了 \toprule、\midrule 和 \bottomrule 命令用以排版三线表的三条线，以及和 \cline 对应的 \cmidrule。除此之外，最好不要用其它横线以及竖线：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;cccc&#125;</span><br><span class="line"><span class="keyword">\toprule</span></span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\multicolumn</span>&#123;3&#125;&#123;c&#125;&#123;Numbers&#125; <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\cmidrule</span>&#123;2-4&#125;</span><br><span class="line"><span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3 <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\midrule</span></span><br><span class="line">Alphabet <span class="built_in">&amp;</span> A <span class="built_in">&amp;</span> B <span class="built_in">&amp;</span> C <span class="keyword">\\</span></span><br><span class="line">Roman <span class="built_in">&amp;</span> I <span class="built_in">&amp;</span> II<span class="built_in">&amp;</span> III <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bottomrule</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h5><p>LATEX 通过 \multicolumn 合并横向单元格；</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\multicolumn</span>&#123;⟨n⟩&#125;&#123;⟨column-spec⟩&#125;&#123;⟨item⟩&#125;</span><br></pre></td></tr></table></figure>

<p>其中 ⟨n⟩ 为要合并的列数，⟨column-spec⟩ 为合并单元格后的列格式，只允许出现一个 l/c/r 或 p 格式。如果合并前的单元格前后带表格线 |，合并后的列格式也要带 | 以使得表格的竖线一致。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|c|&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> Center <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\multicolumn</span>&#123;2&#125;&#123;|c|&#125;&#123;3&#125; <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\multicolumn</span>&#123;1&#125;&#123;r|&#125;&#123;Right&#125; <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">4 <span class="built_in">&amp;</span> <span class="keyword">\multicolumn</span>&#123;2&#125;&#123;c|&#125;&#123;C&#125; <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>

<p>此外，形如 \multicolumn{1}{⟨column-spec⟩}{⟨item⟩} 的命令可以用来修改某一个单元格的列格式；</p>
<p>纵向合并单元格需要用到 multirow 宏包提供的 \multirow 命令：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\multirow</span>&#123;⟨n⟩&#125;&#123;⟨width⟩&#125;&#123;⟨item⟩&#125;</span><br></pre></td></tr></table></figure>

<p>⟨width⟩ 为合并后单元格的宽度，可以填 * 以使用自然宽度。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \usepackage&#123;multirow&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;ccc&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\multirow</span>&#123;2&#125;&#123;*&#125;&#123;Item&#125; <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\multicolumn</span>&#123;2&#125;&#123;c&#125;&#123;Value&#125; <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\cline</span>&#123;2-3&#125;</span><br><span class="line"><span class="built_in">&amp;</span> First <span class="built_in">&amp;</span> Second <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">A <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2 <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>

<h5 id="嵌套表格"><a href="#嵌套表格" class="headerlink" title="嵌套表格"></a>嵌套表格</h5><p>相对于合并单元格，拆分单元格对于 LATEX 来说并非易事。在单元格中嵌套一个小表格可以起到“拆分单元格”的效果。在以下的例子中，注意要用 \multicolumn 命令配合 @{} 格式把单元格的额外边距去掉，使得嵌套的表格线能和外层的表格线正确相连；</p>
<p>如果不需要为“拆分的单元格”画线，并且只在垂直方向“拆分”的话，makecell 宏包提供的 \makecell 命令是一个简单的解决方案：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">a <span class="built_in">&amp;</span> <span class="keyword">\makecell</span>&#123;d1 <span class="keyword">\\</span> d2&#125; <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">b <span class="built_in">&amp;</span> c <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>

<h5 id="控制行距"><a href="#控制行距" class="headerlink" title="控制行距"></a>控制行距</h5><p>LATEX 生成的表格看起来通常比较紧凑。修改参数 \arraystretch 可以得到行距更加宽松的表格，但后续的行距都会修改；</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span><span class="keyword">\arraystretch</span>&#123;1.8&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">Really loose <span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line">tabular rows.<span class="keyword">\\</span> <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>

<p>另一种增加间距的办法是给换行命令 \ 添加可选参数，在这一行下面加额外的间距，适合用于在行间不加横线的表格；</p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>LATEX 本身不支持插图功能，需要由 graphicx 宏包辅助支持，然后通过 \includegraphics 命令加载图片：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\includegraphics</span>[⟨options⟩]&#123;⟨filename⟩&#125;</span><br></pre></td></tr></table></figure>

<p>其中 ⟨filename⟩ 为图片文件名，与使用 \include 命令类似，文件名有时需要使用相对路径或绝对路径。图片文件的扩展名可写可不写。</p>
<p>另外 graphicx 宏包还提供了 \graphicspath 命令，用于声明一个或多个图片文件存放的目录，使用这些目录里的图片时可不用写路径：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 假设主要的图片放在 figures 子目录下，标志放在 logo 子目录下</span></span><br><span class="line"><span class="keyword">\graphicspath</span>&#123;&#123;figures/&#125;&#123;logo/&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>\includegraphics 命令的可选参数 ⟨options⟩ 支持 ⟨key⟩=⟨value⟩ 形式赋值，常用的参数如下：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">width=⟨width⟩</td>
<td align="left">将图片缩放到宽度为 ⟨width⟩</td>
</tr>
<tr>
<td align="left">height=⟨height⟩</td>
<td align="left">将图片缩放到高度为 ⟨height⟩</td>
</tr>
<tr>
<td align="left">scale=⟨scale⟩</td>
<td align="left">将图片相对于原尺寸缩放 ⟨scale⟩ 倍</td>
</tr>
<tr>
<td align="left">angle=⟨angle⟩</td>
<td align="left">令图片逆时针旋转 ⟨angle⟩ 度</td>
</tr>
</tbody></table>
<h4 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h4><p>盒子是 LATEX 排版的基础单元，LATEX 提供了一些命令让我们生成一些有特定用途的盒子。</p>
<h5 id="水平盒子"><a href="#水平盒子" class="headerlink" title="水平盒子"></a>水平盒子</h5><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mbox</span>&#123;…&#125;</span><br><span class="line"><span class="keyword">\makebox</span>[⟨width⟩][⟨align⟩]&#123;…&#125;</span><br></pre></td></tr></table></figure>
<p>\mbox 生成一个基本的水平盒子，内容只有一行，不允许分段（除非嵌套其它盒子，比如后文的垂直盒子）。外表看上去，\mbox 的内容与正常的文本无二，不过断行时文字不会从盒子里断开。</p>
<p>\makebox 更进一步，可以加上可选参数用于控制盒子的宽度 ⟨width⟩，以及内容的对齐方式⟨align⟩，可选居中 c（默认值）、左对齐 l、右对齐 r 和分散对齐 s。但分散对齐方式强行拉开单词的间距，往往会报 Underfull \hbox 的消息</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">|<span class="keyword">\mbox</span>&#123;Test some words.&#125;|<span class="keyword">\\</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em]&#123;Test some words.&#125;|<span class="keyword">\\</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em][l]&#123;Test some words.&#125;|<span class="keyword">\\</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em][r]&#123;Test some words.&#125;|<span class="keyword">\\</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em][s]&#123;Test some words.&#125;|</span><br></pre></td></tr></table></figure>

<p>\fbox 和 \framebox 让我们可以为水平盒子添加边框。使用的语法与 \mbox 和 \makebox一模一样：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\fbox</span>&#123;…&#125;</span><br><span class="line"><span class="keyword">\framebox</span>[⟨width⟩][⟨align⟩]&#123;…&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\fbox</span>&#123;Test some words.&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\framebox</span>[10em][r]&#123;Test some words.&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 可以通过 \setlength 命令调节边框的宽度 \fboxrule 和内边距 \fboxsep：</span></span><br><span class="line"><span class="keyword">\framebox</span>[10em][r]&#123;Test box&#125;<span class="keyword">\\</span>[1ex]</span><br><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\fboxrule</span>&#125;&#123;1.6pt&#125;</span><br><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\fboxsep</span>&#125;&#123;1em&#125;</span><br><span class="line"><span class="keyword">\framebox</span>[10em][r]&#123;Test box&#125;</span><br></pre></td></tr></table></figure>

<h5 id="垂直盒子"><a href="#垂直盒子" class="headerlink" title="垂直盒子"></a>垂直盒子</h5><p>如果需要排版一个文字可以换行的盒子，LATEX 提供了两种方式：</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul>
<li>LATEX 的三个标准文档类可指定的选项包括：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10pt, 11pt, 12pt</td>
<td align="left">指定文档的基本字号。默认为 10pt。</td>
</tr>
<tr>
<td align="left">a5paper, b5paper, executivepaper, legalpaper</td>
<td align="left">指定纸张大小，默认为美式信纸 letterpaper （8.5 × 11 英寸）。</td>
</tr>
<tr>
<td align="left">twoside, oneside</td>
<td align="left">指定单面/双面排版。双面排版时，奇偶页的页眉页脚、页边距不同。article 和 report 默认为 oneside，book 默认为 twoside。</td>
</tr>
<tr>
<td align="left">onecolumn, twocolumn</td>
<td align="left">指定单栏/双栏排版。默认为 onecolumn。</td>
</tr>
<tr>
<td align="left">openright, openany</td>
<td align="left">指定新的一章 \chapter 是在奇数页（右侧）开始，还是直接紧跟着上一页开始。report 默认为 openany，book 默认为 openright。对 article 无效。</td>
</tr>
<tr>
<td align="left">landscape</td>
<td align="left">指定横向排版。默认为纵向。</td>
</tr>
<tr>
<td align="left">titlepage, notitlepage</td>
<td align="left">指定标题命令 \maketitle 是否生成单独的标题页。article 默认为 notitlepage，report 和 book 默认为 titlepage。</td>
</tr>
<tr>
<td align="left">fleqn</td>
<td align="left">令行间公式左对齐。默认为居中对齐。</td>
</tr>
<tr>
<td align="left">leqno</td>
<td align="left">将公式编号放在左边。默认为右边。</td>
</tr>
<tr>
<td align="left">draft, final</td>
<td align="left">指定草稿/终稿模式。草稿模式下，断行不良的地方会在行尾添加一个黑色方块。默认为 final。</td>
</tr>
</tbody></table>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://www.latex-project.org/">LaTeX 官网</a></li>
<li><a href="https://www.overleaf.com/learn">LaTeX 英文文档</a></li>
<li><a href="https://ctan.org/">TeX 进阶 CTAN</a></li>
<li><a href="ht;tps://www.jianshu.com/p/3e842d67ada2">LaTeX零基础入门教程</a></li>
<li><a href="http://www.080910t.com/wp-content/uploads/2019/05/LATEX-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.pdf">一份（不太）简短的 LaTeX 2ε 介绍.pdf</a></li>
<li><a href="https://www.overleaf.com/">overleaf 在线编辑工具</a></li>
<li><a href="https://www.sharelatex.com/">ShareLaTeX 在线编辑工具</a></li>
<li><a href="https://www.tablesgenerator.com/">LaTeX 表格在线生成工具</a></li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>学习笔记</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 学习笔记</title>
    <url>/2022/03/01/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2022.02.28 是我从上家公司离职的日子，心中虽还有些许不舍，但更多的还是轻松和惬意。虽然对自己的技术还是比较自信，但是面对即将踏上新的征程，不得不承认的是在生理上自己还是有些焦虑，导致晚上经常失眠，脑海中一遍遍想象着即将到来的面试场景；</p>
<p>在家复习了整整三周，然后又看了三天面试题，基本上都是 997；本文主要记录在家复习 JavaScript 基础所做的相应笔记；对应项目地址：<a href="https://github.com/Coley48/javascript">https://github.com/Coley48/javascript</a></p>
<span id="more"></span>

<h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><ol>
<li>安装 webpack</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i -D webpack webpack-dev-server webpack-cli</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 webpack</li>
</ol>
<p>在根目录下添加<code>webpack.dev.js</code>和<code>webpack.prod.js</code></p>
<p><code>webpack.dev.js</code>用于开发环境，<code>webpack.prod.js</code>用于生产环境；</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产环境中使用 babel-loader；</span></span><br><span class="line">npm i -D @babel/core @babel/preset-env babel-loader</span><br><span class="line">npm i -D @babel/plugin-transform-runtime <span class="comment"># async/await</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据需要安装其他 loader 和 plugin；</span></span><br><span class="line">npm i -D style-loader css-loader html-webpack-plugin</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.npmjs.com/package/html-webpack-plugin">html-webpack-plugin</a></li>
</ul>
<ol start="3">
<li>配置 babel</li>
</ol>
<blockquote>
<p><code>Babel</code> 是一个 JavaScript 编译器，主要用于将采用 <code>ECMAScript 2015+</code> 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中；</p>
</blockquote>
<ul>
<li><a href="https://www.babeljs.cn/setup#installation">babel配置教程</a></li>
</ul>
<ol start="4">
<li>最后在 <code>package.json</code> 中添加运行脚本</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;serve&quot;: &quot;webpack server --config webpack.dev.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h3><p><strong>什么是 JavaScript ？</strong></p>
<blockquote>
<p>JavaScript 最初被创建的目的是“使网页更生动”；这种编程语言写出来的程序被称为脚本，它们可以被直接写在网页的 <code>HTML</code> 中，在页面加载的时候自动执行；脚本被以纯文本的形式提供和执行，它们不需要特殊的准备或编译即可运行；</p>
</blockquote>
<p>JavaScript 引擎工作基本原理：引擎解析脚本，然后将脚本编译转化为机器语言，最后执行机器语言；</p>
<p><strong>浏览器中的 JavaScript 限制</strong></p>
<p>为了用户的（信息）安全，在浏览器中的 JavaScript 的能力是受限的，目的是防止恶意网页获取用户私人信息或损害用户数据；网页中的 JavaScript 不能读、写、复制和执行硬盘上的任意文件，不同的标签页/窗口之间通常互不了解；</p>
<p><strong>JavaScript 手册</strong></p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">JavaScript MDN 中文参考手册</a></li>
<li><a href="https://caniuse.com/">JavaScript 兼容性表</a><!-- 
#### script 标签</li>
</ul>
<p>应该尽量将较复杂的脚本存放在单独的文件中，使用独立文件的好处是浏览器会下载它，然后将它保存到浏览器的缓存中；之后，其他页面想要相同的脚本就会从缓存中获取，所以文件实际上只会下载一次，这可以节省流量，并使得页面（加载）更快；</p>
<blockquote>
<p>Note: 如果设置了 <code>src</code> 特性，<code>script</code> 标签内容将会被忽略；</p>
</blockquote>
<p>JavaScript 代码以分号结尾，注意添加完整分号，以下代码会报错；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read properties of undefined (reading &#x27;2&#x27;)</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].forEach(alert);</span><br><span class="line"><span class="string">``</span><span class="string">` --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 变量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 必须仅包含字母，数字，符号 $ 和 _；</span></span><br><span class="line"><span class="string">2. 首字符必须非数字；</span></span><br><span class="line"><span class="string">3. 通常使用驼峰命名规则；</span></span><br><span class="line"><span class="string">4. 对大小写敏感；</span></span><br><span class="line"><span class="string">5. 不能使用[保留字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#%E5%85%B3%E9%94%AE%E5%AD%97)命名；</span></span><br><span class="line"><span class="string">6. 允许非英文字母，但不推荐；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 数据类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在 JavaScript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）；JavaScript，被称为“动态类型”（dynamically typed）的编程语言，意思是虽然编程语言中有不同的数据类型，但是你定义的变量并不会在定义后，被限制为某一数据类型；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Number 用于任何类型的数字：整数或浮点数，在 ±(2^53-1) 范围内的整数；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// Infinity 代表数学概念中的 无穷大 ∞；是一个比任何数字都大的特殊值；</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> / <span class="number">0</span> === <span class="literal">Infinity</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN 代表一个计算错误；它是一个不正确的或者一个未定义的数学操作所得到的结果；</span></span><br><span class="line"><span class="comment">// 任何对 NaN 的进一步数学运算都会返回 NaN，且 NaN 不等于任何值，包括自己；</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span> / <span class="number">2</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>BigInt 用于任意长度的整数；</li>
</ul>
<p>Number 类型无法表示大于 (253-1)（即 9007199254740991），或小于 -(253-1) 的整数；目前 IE 还未支持该类型；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾部的 &quot;n&quot; 表示这是一个 BigInt 类型</span></span><br><span class="line"><span class="keyword">const</span> bigInt = <span class="number">1234567890123456789012345678901234567890n</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>String 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型；</li>
</ul>
<p>双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别；反引号是功能扩展引号，它们允许我们通过将变量和表达式包装在 ${…} 中，来将它们嵌入到字符串中；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;Single quotes are ok too&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> phrase = <span class="string">`can embed another <span class="subst">$&#123;str&#125;</span>`</span>; <span class="comment">// 模板字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Boolean 用于 true 和 false；表示逻辑类型；</li>
<li>null 用于未知的值，只有一个 null 值的独立类型；</li>
<li>undefined 用于未定义的值，只有一个 undefined 值的独立类型，代表未被赋值；</li>
</ul>
<blockquote>
<p>Note: 不建议显示地将 <code>undefined</code> 赋值给变量，通常，使用 <code>null</code> 将一个“空”或者“未知”的值写入变量中，而 <code>undefined</code> 则保留作为未进行初始化的事物的默认初始值；</p>
</blockquote>
<blockquote>
<p>Tips: <code>void</code> 并不改变表达式的结果，只是让表达式不返回值；因此可以用 <code>void 0</code> 来获得 <code>undefined</code>；</p>
</blockquote>
<ul>
<li>Symbol 用于唯一的标识符；</li>
<li>Object 用于更复杂的数据结构；</li>
</ul>
<p>当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，可以使用 typeof 运算符返回参数的类型；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是官方承认的 typeof 的错误，这个问题来自于 JavaScript 语言的早期阶段，并为了兼容性而保留了下来；</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 JavaScript 语言中没有一个特别的 “function” 类型，函数隶属于 object 类型，但是 typeof 会对函数区分对待，并返回 &quot;function&quot;；</span></span><br><span class="line"><span class="keyword">typeof</span> alert <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul>
<li>字符串转换：转换发生在输出内容的时候，也可以通过 String(value) 进行显式转换；</li>
<li>数字型转换：转换发生在进行算术操作时，也可以通过 Number(value) 进行显式转换；</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">转换</th>
</tr>
</thead>
<tbody><tr>
<td align="left">undefined</td>
<td align="left">NaN</td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">true / false</td>
<td align="left">1 / 0</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">忽略字符串两端的空白，按原样读取，空字符串变成 0，转换出错则输出 NaN</td>
</tr>
</tbody></table>
<ul>
<li>布尔型转换：转换发生在进行逻辑操作时，也可以通过 Boolean(value) 进行显式转换；</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">转换</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0, null, undefined, NaN, “”</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">其他值</td>
<td align="left">true</td>
</tr>
</tbody></table>
<h4 id="基础运算符，数学"><a href="#基础运算符，数学" class="headerlink" title="基础运算符，数学"></a>基础运算符，数学</h4><p><strong>赋值运算符</strong></p>
<p>赋值语句 x = value 将值 value 写入 x 然后返回 x；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span> - (a = b + <span class="number">1</span>); <span class="comment">// a: 3, c: 0 慎用！</span></span><br></pre></td></tr></table></figure>

<p>链式赋值从右到左进行计算，但可读性不高；</p>
<p><strong>自增 / 自减</strong></p>
<p>++, –，又分为前置形式和后置形式，前置形式返回一个新的值，但后置返回原来的值（做加法/减法之前的值）；</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">JavaScript 运算符优先级表</a></p>
<h4 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h4><p>在比较字符串的大小时，JavaScript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定，换言之，字符串是按字符（母）逐个进行比较的；</p>
<p>字符串的比较算法：</p>
<ol>
<li>首先比较两个字符串的首位字符大小；</li>
<li>如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串，算法结束；</li>
<li>否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较；</li>
<li>重复上述步骤进行比较，直到比较完成某字符串的所有字符为止；</li>
<li>如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大；</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">&#x27;Z&#x27;</span> &gt; <span class="string">&#x27;A&#x27;</span> ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="string">&#x27;Glow&#x27;</span> &gt; <span class="string">&#x27;Glee&#x27;</span> ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="string">&#x27;Bee&#x27;</span> &gt; <span class="string">&#x27;Be&#x27;</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当使用严格等于 === 时，不相等，因为它们属于不同的类型；</span></span><br><span class="line">alert( <span class="literal">null</span> === <span class="literal">undefined</span> ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当使用非严格等于 == 时，相等，仅仅等于对方而不等于其他任何的值；</span></span><br><span class="line">alert( <span class="literal">null</span> == <span class="literal">undefined</span> ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当使用数学式或其他比较方法 &lt; &gt; &lt;= &gt;= 时，null/undefined 会被转化为数字：null 被转化为 0，undefined 被转化为 NaN；</span></span><br><span class="line">alert( <span class="literal">null</span> &gt; <span class="literal">undefined</span> ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等性检查 == 和普通比较符 &gt; &lt; &gt;= &lt;= 的代码逻辑是相互独立的</span></span><br><span class="line">alert( <span class="literal">null</span> &gt; <span class="number">0</span> );  <span class="comment">// false</span></span><br><span class="line">alert( <span class="literal">null</span> == <span class="number">0</span> ); <span class="comment">// false</span></span><br><span class="line">alert( <span class="literal">null</span> &gt;= <span class="number">0</span> ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 和 null 在相等性检查 == 中不会进行任何的类型转换；</span></span><br><span class="line"><span class="comment">// 它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值</span></span><br><span class="line">alert( <span class="literal">undefined</span> &gt; <span class="number">0</span> ); <span class="comment">// false</span></span><br><span class="line">alert( <span class="literal">undefined</span> &lt; <span class="number">0</span> ); <span class="comment">// false</span></span><br><span class="line">alert( <span class="literal">undefined</span> == <span class="number">0</span> ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="逻辑运算符-if-和"><a href="#逻辑运算符-if-和" class="headerlink" title="逻辑运算符 if 和 ?:"></a>逻辑运算符 if 和 ?:</h4><ul>
<li>或运算符 || 返回的值是操作数的初始形式，不会做布尔转换；</li>
</ul>
<p>执行过程：</p>
<ol>
<li>从左到右依次计算操作数；</li>
<li>将每一个操作数转化为布尔值；若结果为 true，则返回该操作数的初始值；</li>
<li>如果所有的操作数都被计算过（转换结果都是 false），则返回最后一个操作数；</li>
</ol>
<p>常见用法：</p>
<ol>
<li>获取变量列表或者表达式中的第一个真值；</li>
<li>短路求值（Short-circuit evaluation）；</li>
</ol>
<ul>
<li>与运算符 &amp;&amp; 返回的值是第一个假值的初始形式；</li>
<li>非运算符 ! 返回操作数的取反布尔值；</li>
</ul>
<blockquote>
<p>Tips: 两个非运算 <code>!!</code> 有时候用来将某个值转化为布尔类型：</p>
</blockquote>
<h4 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符 ??"></a>空值合并运算符 ??</h4><p><code>a ?? b</code> 表示如果第一个参数不是 null/undefined，则 ?? 返回第一个参数，否则，返回第二个参数；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ?? 等价写法：</span></span><br><span class="line">result = (a !== <span class="literal">null</span> &amp;&amp; a !== <span class="literal">undefined</span>) ? a : b;</span><br></pre></td></tr></table></figure>

<p>与 || 比较：</p>
<ul>
<li>|| 返回第一个真值；</li>
<li>?? 返回第一个已定义的值；</li>
<li>优先级相同；</li>
</ul>
<p>出于安全原因，JavaScript 禁止将 ?? 运算符与 &amp;&amp; 和 || 运算符一起使用，除非使用括号明确指定了优先级；</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>跳出多层循环：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> input = prompt(<span class="string">`Value at coords (<span class="subst">$&#123;i&#125;</span>,<span class="subst">$&#123;j&#125;</span>)`</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 如果是空字符串或被取消，则中断并跳出这两个循环</span></span><br><span class="line">      <span class="keyword">if</span> (!input) <span class="keyword">break</span> outer; <span class="comment">// (*)</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 用得到的值做些事……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: <code>break</code> 指令必须在代码块内，从技术上讲，任何被标记的代码块都有效；</p>
</blockquote>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在 JavaScript 中，函数是一种特殊的值，函数定义有函数声明和函数表达式两种；二者差别主要在，函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用；而函数声明则不同，在函数声明被定义之前，它就可以被调用；</p>
<p>函数就是行为（action），所以它们的名字通常是动词，它应该简短且尽可能准确地描述函数的作用，这样读代码的人就能清楚地知道这个函数的功能；一种普遍的做法是用动词前缀来开始一个函数，这个前缀模糊地描述了这个行为；</p>
<p>空值的 return 或没有 return 的函数返回值为 undefined；</p>
<p>一个函数应该只包含函数名所指定的功能，而不是做更多与函数名无关的功能；两个独立的行为通常需要两个函数，即使它们通常被一起调用；在这种情况下，我们可以创建第三个函数来调用这两个函数；</p>
<h4 id="在浏览器中调试"><a href="#在浏览器中调试" class="headerlink" title="在浏览器中调试"></a>在浏览器中调试</h4><blockquote>
<p>Tips: 在控制台中要插入多行代码，按 <code>Shift+Enter</code> 来进行换行；</p>
</blockquote>
<ul>
<li>“下一步（Step）”：运行下一条指令，快捷键 F9；</li>
<li>“跨步（Step over）”：运行下一条指令，但 不会进入到一个函数中，快捷键 F10；</li>
<li>“步入（Step into）”，快捷键 F11；</li>
<li>“步出（Step out）”：继续执行到当前函数的末尾，快捷键 Shift+F11；</li>
</ul>
<blockquote>
<p>Tips: 在代码中的某一行上右键，在显示的关联菜单中点击一个非常有用的名为 <code>Continue to here</code> 的选项；</p>
</blockquote>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li>需要注释：</li>
</ul>
<ol>
<li>整体架构，高层次的观点；</li>
<li>函数的用法；</li>
<li>重要又不是很明显的解决方案；</li>
</ol>
<ul>
<li>避免注释：</li>
</ul>
<ol>
<li>描述“代码如何工作”和“代码做了什么”；</li>
<li>已经足够简单或有很好自描述性的代码；</li>
</ol>
<h4 id="忍者代码"><a href="#忍者代码" class="headerlink" title="忍者代码"></a>忍者代码</h4><ol>
<li>不要为了简洁而降低代码可读性；</li>
<li>不用一个字母的变量和单词缩写；</li>
<li>不用无意义的变量名；</li>
<li>避免同义词命名变量或函数；</li>
<li>不在函数或循环中替换变量值；</li>
<li>不在变量名前添加下划线；</li>
<li>避免使用和外部变量同名的变量名；</li>
<li>除了主要任务之外，避免给函数添加一个其他行为；</li>
<li>避免返回非标准结果的函数；</li>
<li>避免将多个功能合并在一个函数中；</li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>前端测试主要分为 3 种：单元测试（Unit Test）、集成测试（Integration Test）、UI 测试（UI Test）；</p>
<ul>
<li>单元测试是最容易实现的：代码中多个组件共用的工具类库、多个组件共用的子组件等；</li>
<li>集成测试通常被应用在：耦合度较高的函数/组件、经过二次封装的函数/组件、多个函数/组件组合而成的函数/组件等；</li>
<li>UI 测试只是对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的；</li>
</ul>
<p>适合引入自动化测试的场景：</p>
<ul>
<li>公共库类的开发维护；</li>
<li>中长期项目的迭代/重构；</li>
<li>引用了不可控的第三方依赖；</li>
</ul>
<p>当通过手动重新运行来测试代码时，很容易漏掉一些东西；自动化测试意味着测试是独立于代码的；它们以各种方式运行我们的函数，并将结果与预期结果进行比较；</p>
<p>BDD（行为驱动开发）规范先行，实现在后，包含了三部分内容：测试、文档和示例；</p>
<p>安装单元测试库 Jest：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i -D jest</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://juejin.cn/post/6844904194600599560">试试前端自动化测试！（基础篇）</a></li>
<li><a href="https://jestjs.io/zh-Hans/">Jest 测试框架中文文档</a></li>
<li><a href="https://alexjover.com/blog/write-the-first-vue-js-component-unit-test-in-jest/">Vue.js Jest 单元测试</a></li>
</ul>
<h4 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h4><p><strong>对象属性</strong></p>
<blockquote>
<p>Tips: 对象属性可以用 <code>delete</code> 操作符移除；</p>
</blockquote>
<p>属性名可以是任何字符串或者 symbol，包括使用保留字；包含空格，以数字开头，或包含特殊字符（除 $ 和 _ 以外）的属性名需要加引号；</p>
<p><strong>计算属性</strong></p>
<p>在对象字面量中使用方括号定义动态属性名，括号中可以使用变量或更复杂的表达式；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = prompt(<span class="string">&quot;Which fruit to buy?&quot;</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bag = &#123;</span><br><span class="line">  [fruit]: <span class="number">5</span>, <span class="comment">// 属性名是从 fruit 变量中得到的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( bag.apple ); <span class="comment">// 5 如果 fruit=&quot;apple&quot;</span></span><br></pre></td></tr></table></figure>


<p><strong>in 操作符</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">alert( <span class="string">&quot;age&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="string">&quot;blabla&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>遍历对象：for(let key in obj) 循环；</p>
<blockquote>
<p>Tips: 对象中，整数属性会被进行排序，其他属性则按照创建的顺序显示；整数属性指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串；</p>
</blockquote>
<h4 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h4><blockquote>
<p>Tips: 赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址”；换句话说就是对该对象的“引用”；</p>
</blockquote>
<blockquote>
<p>Tips: JavaScript 变量复制，原始类型可类比为“搬家”，对象类型类比为“配钥匙”；</p>
</blockquote>
<p>使用 <code>Object.assign(dest, [src1, src2, src3...])</code> 方法拷贝对象；</p>
<ul>
<li>第一个参数 dest 是指目标对象；</li>
<li>一个或多个源对象 src1, …, srcN；</li>
<li>该方法将所有源对象的属性拷贝到目标对象 dest 中；</li>
<li>调用结果返回 dest；</li>
<li>如果被拷贝的属性的属性名已经存在，则会被覆盖；</li>
</ul>
<p>或使用 Spread 语法拷贝对象；<code>clone = &#123; ...user &#125;</code></p>
<p>当对象中存在有其他对象的引用时，可以使用递归循环深拷贝，也可以直接使用 Lodash 定义好的方法 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span> || object === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> copy = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(object, key)) &#123;</span><br><span class="line">      copy[key] = cloneDeep(object[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>JavaScript 中主要的内存管理概念是可达性（Reachability），及存储在内存中并以某种方式可访问或可用的值；</p>
<p>固有的可达值的基本集合，也成为根（roots），包括：</p>
<ol>
<li>当前执行的函数，它的局部变量和参数；</li>
<li>当前嵌套调用链上的其他函数、它们的局部变量和参数；</li>
<li>全局变量；</li>
<li>还有一些内部的根；</li>
</ol>
<p>如果一个值可以通过引用或引用链从根访问任何其他值，则认为该值是可达的；</p>
<p>垃圾回收的基本算法被称为 “mark-and-sweep”，即标记清除；现代浏览器均使用此机制，老浏览器使用引用计数机制；标记算法类似于广度优先遍历；</p>
<p>优化建议：</p>
<ul>
<li><p>分代收集（Generational collection）：对象被分成两组：“新的”和“旧的”；许多对象出现，完成它们的工作并很快死去，它们可以很快被清理；那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少；</p>
</li>
<li><p>增量收集（Incremental collection）：如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟，所以引擎试图将垃圾收集工作分成几部分来做；然后将这几部分会逐一进行处理，这需要它们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟；</p>
</li>
<li><p>闲时收集（Idle-time collection）：垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响；</p>
</li>
<li><p><a href="https://www.ruanyifeng.com/blog/2017/04/memory-leak.html">JavaScript 内存泄漏教程</a></p>
</li>
<li><p><a href="https://www.wolai.com/mary/qwwq3geBqBcXs2cygGY3Lx">内存泄漏（memory leak）</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qappleh/article/details/80337630">JavaScript 内存泄露的4种方式及如何避免</a></p>
</li>
</ul>
<h4 id="对象方法，this"><a href="#对象方法，this" class="headerlink" title="对象方法，this"></a>对象方法，this</h4><p>JavaScript 中的 this 可以用于任何函数，即使它不是对象的方法；this 的值是在代码运行时计算出来的，它取决于代码上下文；</p>
<p>在普通函数中的 this，严格模式下的值为 undefined，非严格模式的情况下，this 将会是全局对象（浏览器为 window）；箭头函数没有自己的 this，其 this 值取决于外部“正常的”函数；</p>
<h4 id="构造器和操作符-new"><a href="#构造器和操作符-new" class="headerlink" title="构造器和操作符 new"></a>构造器和操作符 new</h4><p>从技术上讲，构造函数也是一个常规函数；但一般以大写字母开头并只用 new 操作符执行；当一个函数被使用 new 操作符执行时，它按照以下步骤：</p>
<ol>
<li>一个新的空对象被创建并分配给 this；</li>
<li>函数体执行，通常它会修改 this，为其添加新的属性；</li>
<li>返回 this 的值；</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;;（隐式创建）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加属性到 this</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.isAdmin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return this;（隐式返回）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 创建单个复杂对象的代码，可以将它们封装在一个立即调用的构造函数中 <code>new function() &#123; … &#125;</code>；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个函数并立即使用 new 调用它</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.isAdmin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数定义</span></span><br><span class="line">  <span class="built_in">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert( <span class="string">&quot;My name is: &quot;</span> + <span class="built_in">this</span>.name );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于用户创建的其他代码</span></span><br><span class="line">  <span class="comment">// 也许是复杂的逻辑和语句、局部变量等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在一个函数内部，我们可以使用 <code>new.target</code> 属性来检查它是否被使用 <code>new</code> 进行调用了；对于常规调用，它为 <code>undefined</code>，对于使用 <code>new</code> 的调用，则等于该函数；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">new</span>.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User(); <span class="comment">// function User &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式重定向构造器模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123; <span class="comment">// 没有通过 new 运行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(name); <span class="comment">// 添加 new</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = User(<span class="string">&quot;John&quot;</span>); <span class="comment">// 将调用重定向</span></span><br><span class="line">alert(john.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>通常，构造器没有 return 语句；它们的任务是将所有必要的东西写入 this，并自动转换为结果；</p>
<p>当构造器中有 return，若返回值为一个对象，则会返回该对象并覆盖默认的 this；若返回值为原始类型或为空时，则会被忽略，仍然返回默认的 this；</p>
<blockquote>
<p>Tips: 如果没有参数，我们可以省略 <code>new</code> 后的括号；</p>
</blockquote>
<h4 id="可选链"><a href="#可选链" class="headerlink" title="可选链 ?."></a>可选链 ?.</h4><p>如果可选链 ?. 前面的值为 undefined 或者 null，它会停止运算并返回 undefined；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选链</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user?.name?.first);</span><br><span class="line">user.admin?.();</span><br><span class="line">user?.[<span class="string">&quot;key&quot;</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>?.</code> 前的变量必须已声明，且只将 <code>?.</code> 使用在一些东西可以不存在的地方，不要过度使用可选链；</p>
</blockquote>
<p>可选链 ?. 不是一个运算符，而是一个特殊的语法结构；它还可以与函数和方括号一起使用；</p>
<ol>
<li>?.() 用于调用一个可能不存在的函数；</li>
<li>?.[] 用于访问一个可能不存在的属性；</li>
</ol>
<blockquote>
<p>Tips: 删除一个可能不存在的属性，<code>delete user?.name</code>；可以使用 ?. 来安全地读取或删除，但不能写入；</p>
</blockquote>
<h4 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h4><p>规范中，对象的属性键只能是字符串类型或者 Symbol 类型，Symbol 值表示唯一的标识符；</p>
<p>使用 Symbol() 来创建这种类型的值，创建时可以给 Symbol 一个描述（也称为 Symbol 名），这在代码调试时非常有用；可以通过 symbol.description 属性获取 Symbol 的描述；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// id 是 symbol 的一个实例化对象</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// id 是描述为 &quot;id&quot; 的 Symbol</span></span><br><span class="line"><span class="keyword">let</span> id2 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id2.description) <span class="comment">// id</span></span><br></pre></td></tr></table></figure>

<p>Symbol 保证是唯一的；即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同；描述只是一个标签，不影响任何东西；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(id1 == id2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>Symbol</code> 不会被自动转换为字符串；只能手动调用 <code>toString()</code>；</p>
</blockquote>
<ul>
<li>“隐藏”属性</li>
</ul>
<p>Symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">user[id] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 在对象字面量中使用 <code>Symbol</code>，需要使用方括号；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;Coley&quot;</span>,</span><br><span class="line">  [id]: <span class="number">12</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Symbol 属性不参与 for..in 循环，Object.keys(user) 也会忽略 Symbol；这是一般“隐藏符号属性”原则的一部分；但 Object.assign 会同时复制字符串和 symbol 属性；</p>
<p>从技术上讲，内建方法 Object.getOwnPropertySymbols(obj) 允许我们获取所有的 Symbol；还有一个 Reflect.ownKeys(obj) 方法可以返回一个对象的所有键，包括 Symbol；</p>
<p><strong>全局 symbol</strong></p>
<p>调用 Symbol.for(key) 方法创建或查询，该方法会先检查全局注册表，如果有一个描述为 key 的 Symbol，则返回该 Symbol，否则将创建一个新 Symbol，并通过给定的 key 将其存储在全局注册表中；</p>
<p>或者调用 Symbol.keyFor(sym) 方法，通过全局 Symbol 返回一个名字；如果查找的 Symbol 不是全局的则会返回 undefined；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从全局注册表中读取</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>); <span class="comment">// 如果该 Symbol 不存在，则创建它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次读取（可能是在代码中的另一个位置）</span></span><br><span class="line"><span class="keyword">let</span> idAgain = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同的 Symbol</span></span><br><span class="line">alert( id === idAgain ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(id); <span class="comment">// id</span></span><br></pre></td></tr></table></figure>

<p>除此之外，JavaScript 内部还有许多系统 Symbol，可以用来微调对象的各个方面，以此改变一些内建行为，这些 Symbol 被列在了 <a href="https://tc39.github.io/ecma262/#sec-well-known-symbols">Symbol 表</a> 的规范中；</p>
<h4 id="对象——原始值转换"><a href="#对象——原始值转换" class="headerlink" title="对象——原始值转换"></a>对象——原始值转换</h4><p>JavaScript 不允许自定义运算符对对象的处理方式；因此在对对象进行运算时，对象会被自动转换为原始值，并会得到一个原始值的结果；</p>
<p>所有的对象在布尔上下文（context）中均为 true，因此对于对象，不存在 boolean 转换；</p>
<ul>
<li>“string” hint</li>
</ul>
<p>对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 “alert”；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line">alert(obj); <span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象作为属性键</span></span><br><span class="line">anotherObj[obj] = <span class="number">123</span>; <span class="comment">// &#123;[object Object]: 123&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>“number” hint</li>
</ul>
<p>对象到数字的转换，例如当我们进行数学运算时；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式转换</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="built_in">Number</span>(obj); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数学运算（除了二元加法）</span></span><br><span class="line"><span class="keyword">let</span> n = +obj; <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> delta = <span class="keyword">new</span> <span class="built_in">Date</span> - <span class="keyword">new</span> <span class="built_in">Date</span>; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于/大于的比较</span></span><br><span class="line"><span class="keyword">let</span> greater = user1 &gt; user2; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>“default” hint</li>
</ul>
<p>在少数情况下发生，当运算符“不确定”期望值的类型时；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> total = obj + user; <span class="comment">// [object Object][object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user == <span class="number">1</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 像 <code>&lt;</code> 和 <code>&gt;</code> 这样的小于/大于比较运算符，也可以同时用于字符串和数字；不过，它们使用 <code>number hint</code>，而不是 <code>default</code>，这是历史原因；</p>
</blockquote>
<p>JavaScript 转换算法：</p>
<ol>
<li>调用 obj<a href="hint">Symbol.toPrimitive</a>，带有 symbol 键 Symbol.toPrimitive（系统 symbol）的方法，如果这个方法存在的话；</li>
<li>否则，如果 hint 是 “string”，尝试 obj.toString() 和 obj.valueOf()，对于字符串转换，优先 toString；</li>
<li>否则，如果 hint 是 “number” 或 “default”，尝试 obj.valueOf() 和 obj.toString()，对于数学运算，优先 valueOf；</li>
</ol>
<p><strong>Symbol.toPrimitive</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里是将此对象转换为原始值的代码</span></span><br><span class="line">  <span class="comment">// 它必须返回一个原始值</span></span><br><span class="line">  <span class="comment">// hint = &quot;string&quot;、&quot;number&quot; 或 &quot;default&quot; 中的一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象原型上添加</span></span><br><span class="line"><span class="built_in">Object</span>.prototype[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">&quot;&quot;</span> + o); <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  money: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    alert(<span class="string">`hint: <span class="subst">$&#123;hint&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> hint == <span class="string">&quot;string&quot;</span> ? <span class="string">`&#123;name: &quot;<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>&quot;&#125;`</span> : <span class="built_in">this</span>.money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换演示：</span></span><br><span class="line">alert(user); <span class="comment">// hint: string -&gt; &#123;name: &quot;John&quot;&#125;</span></span><br><span class="line">alert(+user); <span class="comment">// hint: number -&gt; 1000</span></span><br><span class="line">alert(user + <span class="number">500</span>); <span class="comment">// hint: default -&gt; 1500</span></span><br></pre></td></tr></table></figure>

<p><strong>toString 和 valueOf</strong></p>
<p>还可以使用 toString 和 valueOf 方法，但必须返回一个原始值，如果 toString 或 valueOf 返回了一个对象，那么返回值会被忽略；</p>
<p>默认情况下，普通对象具有 toString 和 valueOf 方法：toString 方法返回一个字符串 “[object Object]”；valueOf 方法返回对象自身；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  money: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;string&quot;</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;name: &quot;<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>&quot;&#125;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span></span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 通常我们希望有一个“全能”的地方来处理所有原始转换；这时，我们可以只实现 <code>toString</code>；如果没有 <code>Symbol.toPrimitive</code> 和 <code>valueOf</code>，<code>toString</code> 将处理所有原始转换；</p>
</blockquote>
<blockquote>
<p>Note: 三种方式转换可以返回任何原始类型；但由于历史原因，如果 <code>toString</code> 或 <code>valueOf</code> 返回一个对象，则不会出现 <code>error</code>，但是这种值会被忽略；</p>
</blockquote>
<p>如果将对象作为参数传递，会先被转换为原始值，如果生成的原始值的类型不正确，则继续进行转换；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">// toString 在没有其他方法的情况下处理所有转换</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(obj * <span class="number">2</span>); <span class="comment">// 4，对象被转换为原始值字符串 &quot;2&quot;，之后它被乘法转换为数字 2</span></span><br></pre></td></tr></table></figure>

<h4 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h4><p>JavaScript 允许我们像使用对象一样使用原始类型，如在字符串字面值上调用方法；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先创建一个包含字符串字面值的特殊对象，</span></span><br><span class="line"><span class="comment">// 然后调用 toUpperCase 方法，之后特殊对象被销毁，只留下原始值；</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;string&quot;</span>.toUpperCase()); <span class="comment">// STRING</span></span><br></pre></td></tr></table></figure>

<p>对象包装器：String、Number、Boolean、Symbol 和 BigInt；</p>
<blockquote>
<p>Note: 不要使用 <code>new</code> 操作符调用包装器，因为包装器会返回一个对象，可能会导致判断失效；</p>
</blockquote>
<blockquote>
<p>Note: 特殊的原始类型 <code>null</code> 和 <code>undefined</code> 是例外，它们没有对应的“对象包装器”，也没有提供任何方法；从某种意义上说，它们是“最原始的”；</p>
</blockquote>
<p>原始类型不是对象，不能存储额外的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line">str.test = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(str.test); <span class="comment">// 非严格模式 undefined</span></span><br><span class="line"><span class="built_in">console</span>.warn(str.test); <span class="comment">// 严格模式 Uncaught TypeError: Cannot create property &#x27;test&#x27; on string &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>JavaScript 中的常规数字以 64 位的格式 IEEE-754 存储，也被称为“双精度浮点数”；在内部，所以有 64 位可以存储一个数字：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号；因此所表示的范围介于 ±(2^53-1) 之间；</p>
<blockquote>
<p>Tips: 定义数字时，可以使用下划线间隔数字以增强可读性：<code>let billion = 1_000_000_000;</code>，JavaScript 引擎会直接忽略数字之间的 <code>_</code>；</p>
</blockquote>
<p>科学计数法，在 JavaScript 中，可以通过在数字后面附加字母 “e” 并指定零的个数来缩短数字；</p>
<p>十六进制数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西；前缀为 0x，然后是数字；二进制和八进制数字系统很少使用，但也支持使用 0b 和 0o 前缀；</p>
<p>使用 parseInt 和 toString(base) 两个方法可以对进制进行转换；</p>
<p>toString 参数 base 的范围可以从 2 到 36，默认情况下是 10；parseInt 方法将源数按指定进制解析为十进制数；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(number.toString(<span class="number">16</span>)); <span class="comment">// &quot;c8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;c8&quot;</span>, <span class="number">16</span>)); <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 将一个较长的数字标识符转换成较短的时候，可以使用 toString(36)；</p>
</blockquote>
<blockquote>
<p>Tips: 使用两个点来调用一个方法，JavaScript 语法隐含了第一个点之后的部分为小数部分；若数字后有两个点，那么 JavaScript 就知道小数部分为空，现在使用该方法 <code>123456..toString(36)</code>，或直接为数字添加一对括号 <code>(123456).toString(36)</code>；</p>
</blockquote>
<p><strong>舍入</strong></p>
<ol>
<li>Math.floor 向下取整；</li>
<li>Math.ceil 向上取整；</li>
<li>Math.round 四舍五入；</li>
<li>Math.trunc 截断小数点部分（IE 不支持）；</li>
<li>Math.prototype.toFixed(n) 保留 n 位小数，返回字符串；</li>
</ol>
<p><strong>精度丢失</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span> ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello！我是一个会自我增加的数字！</span></span><br><span class="line">alert( <span class="number">9999999999999999</span> ); <span class="comment">// 显示 10000000000000000</span></span><br><span class="line"><span class="comment">// 超过 2^53 次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度损失可能会导致数字的增加和减小，在这种特殊的情况下，数字变小了一点，就会向下舍入；</span></span><br><span class="line">alert( <span class="number">6.35</span>.toFixed(<span class="number">1</span>) ); <span class="comment">// 6.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 偶发的无限循环</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">10</span>) &#123;</span><br><span class="line">  i += <span class="number">0.2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 toPrecision 凑整并 parseFloat 转成数字后再显示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strip</span>(<span class="params">num, precision = <span class="number">12</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="built_in">parseFloat</span>(num.toPrecision(precision));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否在误差范围</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(arg1 - arg2) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 数字内部表示的另一个有趣结果是存在两个零：<code>0</code> 和 <code>-0</code>；因为在存储时，使用一位来存储符号，不过运算符将它们视为相同的值；</p>
</blockquote>
<p><a href="https://github.com/camsong/blog/issues/9">JavaScript 浮点数陷阱及解法</a></p>
<p><strong>isFinite 和 isNaN</strong></p>
<ul>
<li>isNaN(value) 将其参数转换为数字，然后测试它是否为 NaN；值 “NaN” 是独一无二的，它不等于任何东西，包括它自身，任何不能被转换为数值的的值都会返回 true；</li>
<li>Number.isNaN(value) 首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确；</li>
<li>isFinite(value) 将其参数转换为数字，如果是常规数字，则返回 true，而不是 NaN/Infinity/-Infinity；因此该方法可以用于验证字符串值是否为常规数字；</li>
</ul>
<blockquote>
<p>Note: 在所有数字函数中，包括 <code>isFinite</code>，空字符串或仅有空格的字符串均被视为 <code>0</code>；</p>
</blockquote>
<p><strong>Object.is</strong></p>
<p>当内部算法需要比较两个值是否完全相同时，它使用 Object.is（内部称为 SameValue），这种比较方式经常被用在 JavaScript 规范中；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 适用于 NaN</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>，<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较 0 和 -0，内部符号位不同</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>，-<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>除了以上两种特殊情况，其他情况等价于 ===；</p>
<p><strong>parseInt 和 parseFloat</strong></p>
<p>使用加号 + 或 Number() 的数字转换是严格的，如果一个值不完全是一个数字，就会失败并返回一个 NaN；</p>
<p>parseInt 和 parseFloat 可以从字符串中“读取”数字，直到无法读取为止；如果发生 error，则返回收集到的数字；函数 parseInt 返回一个整数，而 parseFloat 返回一个浮点数；当没有数字可读时会返回 NaN；</p>
<blockquote>
<p>Tips: <code>parseInt(str, radix)</code> 函数具有可选的第二个参数，它指定了数字系统的基数，因此 <code>parseInt</code> 还可以解析十六进制数字、二进制数字等的字符串：</p>
</blockquote>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串的内部格式始终是 UTF-16，它不依赖于页面编码；</p>
<p><strong>转义字符</strong></p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">在 Windows 中，两个字符 \r\n 的组合代表一个换行</td>
</tr>
<tr>
<td align="left">&#39;, &quot;</td>
<td align="left">引号</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">反斜线</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表符</td>
</tr>
<tr>
<td align="left">\b, \f, \v</td>
<td align="left">退格，换页，垂直标签</td>
</tr>
<tr>
<td align="left">\xXX</td>
<td align="left">具有给定十六进制 Unicode XX 的 Unicode 字符</td>
</tr>
<tr>
<td align="left">\uXXXX</td>
<td align="left">以 UTF-16 编码的十六进制代码 XXXX 的 Unicode 字符</td>
</tr>
<tr>
<td align="left">\u{X…XXXXXX}</td>
<td align="left">（1 到 6 个十六进制字符）    具有给定 UTF-32 编码的 Unicode 符号</td>
</tr>
</tbody></table>
<blockquote>
<p>Note: 反斜杠 <code>\</code> 在 JavaScript 中用于正确读取字符串，然后消失，内存中的字符串没有 <code>\</code>；</p>
</blockquote>
<p><strong>访问字符</strong></p>
<p>要获取在 pos 位置的一个字符，可以使用方括号 [pos] 或者调用 str.charAt(pos) 方法；区别是如果没有找到字符，[] 返回 undefined，而 charAt 返回一个空字符串；</p>
<blockquote>
<p>Tips: 通过字符串的 <code>length</code> 属性可以获取字符串的长度；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`Hello`</span>;</span><br><span class="line"></span><br><span class="line">alert( str[<span class="number">1000</span>] ); <span class="comment">// undefined</span></span><br><span class="line">alert( str.charAt(<span class="number">1000</span>) ); <span class="comment">// &#x27;&#x27;（空字符串）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 for ... of 遍历字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> <span class="string">&quot;Hello&quot;</span>) &#123;</span><br><span class="line">  alert(char); <span class="comment">// H,e,l,l,o（char 变为 &quot;H&quot;，然后是 &quot;e&quot;，然后是 &quot;l&quot; 等）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>; <span class="comment">// Uncaught TypeError: Cannot assign to read only property &#x27;0&#x27; of string &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>查找子字符串</strong></p>
<p>使用 str.indexOf(substr, pos) 或 str.lastIndexOf(substr, pos) 方法，从给定位置 pos 开始，在 str 中查找 substr，如果没有找到，则返回 -1，否则返回匹配成功的位置；区别是从字符串的首尾两端开始；</p>
<blockquote>
<p>Tips: 可以使用按位取反 <code>~</code>，将数字转换为 <code>32-bit</code> 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反；对于 <code>32-bit</code> 整数，<code>~n</code> 等于 <code>-(n+1)</code>；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Widget&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未查到是 indexOf 返回 -1，取反后值为 0；</span></span><br><span class="line"><span class="keyword">if</span> (~str.indexOf(<span class="string">&quot;Widget&quot;</span>)) &#123;</span><br><span class="line">  alert( <span class="string">&#x27;Found it!&#x27;</span> ); <span class="comment">// 正常运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>str.includes(substr, pos) 根据 str 中是否包含 substr 来返回 true/false，也可以使用第二个可选参数指定开始搜索的起始位置；</p>
<p>方法 str.startsWith 和 str.endsWith 判断字符串是否以某子字符串开头或结尾；</p>
<p><strong>获取子字符串</strong></p>
<p>str.slice(start [, end]) 返回字符串从 start 到（但不包括）end 的部分；如果没有第二个参数，slice 会一直运行到字符串末尾；start/end 也可以为负值，表示起始位置从字符串结尾计算；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line">alert( str.slice(<span class="number">0</span>, <span class="number">5</span>) ); <span class="comment">// &#x27;strin&#x27;</span></span><br><span class="line">alert( str.slice(<span class="number">0</span>, <span class="number">1</span>) ); <span class="comment">// &#x27;s&#x27;</span></span><br><span class="line">alert( str.slice(<span class="number">2</span>) ); <span class="comment">// &#x27;ringify&#x27;</span></span><br><span class="line">alert( str.slice(-<span class="number">4</span>, -<span class="number">1</span>) ); <span class="comment">// &#x27;gif&#x27;</span></span><br></pre></td></tr></table></figure>

<p>str.substring(start [, end]) 返回字符串在 start 和 end 之间 的部分，与 slice 几乎相同，但允许 start 大于 end（两个值会被交换）；当遇到负数时，会被视为 0；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line">alert( str.substring(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line">alert( str.substring(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line">alert( str.substring(<span class="number">6</span>, <span class="number">0</span>) ); <span class="comment">// &quot;string&quot;</span></span><br><span class="line">alert( str.substring(<span class="number">6</span>, -<span class="number">1</span>) ); <span class="comment">// &quot;string&quot;</span></span><br></pre></td></tr></table></figure>

<p>str.substr(start [, length]) 返回字符串从 start 开始的给定 length 的部分；若第一个参数为负数，则从结尾算起；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line">alert( str.substr(<span class="number">2</span>, <span class="number">4</span>) ); <span class="comment">// &#x27;ring&#x27;</span></span><br><span class="line">alert( str.substr(-<span class="number">4</span>, <span class="number">2</span>) ); <span class="comment">// &#x27;gi&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>str.substr</code> 不在 JavaScript 核心规范中的描述，因此，非浏览器环境可能无法支持它；</p>
</blockquote>
<p><strong>比较字符串</strong></p>
<blockquote>
<p>Note: 小写字母总是大于大写字母，带变音符号的字母存在“乱序”的情况；</p>
</blockquote>
<p>所有的字符串都使用 UTF-16 编码，即每个字符都有对应的数字代码；</p>
<p>str.codePointAt(pos) 返回在 pos 位置的字符代码；<br>String.fromCodePoint(code) 通过数字 code 创建字符；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">&quot;z&quot;</span>.codePointAt(<span class="number">0</span>) ); <span class="comment">// 122</span></span><br><span class="line">alert( <span class="string">&quot;Z&quot;</span>.codePointAt(<span class="number">0</span>) ); <span class="comment">// 90</span></span><br><span class="line"></span><br><span class="line">alert( <span class="built_in">String</span>.fromCodePoint(<span class="number">90</span>) ); <span class="comment">// Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 65..220 的字符</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">65</span>; i &lt;= <span class="number">220</span>; i++) &#123;</span><br><span class="line">  str += <span class="built_in">String</span>.fromCodePoint(i);</span><br><span class="line">&#125;</span><br><span class="line">alert( str );</span><br><span class="line"><span class="comment">// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ</span></span><br></pre></td></tr></table></figure>

<p>一种特殊的方法来比较不同语言的字符串，调用 str.localeCompare(str2) 会根据语言规则返回一个整数，这个整数能指示字符串 str 在排序顺序中排在字符串 str2 前面 <code>-</code>、相同 <code>0</code>、后面 <code>+</code>；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首字母大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialFirst</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&quot;string&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>).toUpperCase() + str.slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是一种特殊的对象，它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 length 属性；JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建空数组：</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会创建一个给定长度的数组，但不含有任何项</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>); <span class="comment">// [empty x 2] </span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(item1, item2, ...);</span><br></pre></td></tr></table></figure>

<p><strong>pop/push, shift/unshift 方法</strong></p>
<p>pop 取出并返回数组的最后一个元素；push 在数组末端添加元素；shift 取出数组的第一个元素并返回它；unshift 在数组的首端添加元素；其中，push 和 unshift 方法都可以一次添加多个元素；</p>
<blockquote>
<p>Note: <code>push</code>/<code>pop</code> 方法运行的比较快，而 <code>shift</code>/<code>unshift</code> 比较慢，是因为后二者会移动数组里所有元素；数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作；</p>
</blockquote>
<p><strong>遍历数组</strong></p>
<p>可以使用普通 for 循环或者 for..of，但 for..of 遍历数组只能获取元素值，不能获取当前元素的索引；</p>
<blockquote>
<p>Note: <code>for..in</code> 循环会遍历所有属性，不仅仅是这些数字属性；<code>for..in</code> 循环适用于普通对象，并且做了对应的优化，但是不适用于数组，因此速度要慢 <code>10-100</code> 倍；</p>
</blockquote>
<p><strong>数组 length</strong></p>
<p>当我们修改数组的时候，length 属性会自动更新，准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一；</p>
<blockquote>
<p>Tips: <code>length</code> 属性是可写的，清空数组最简单的方法就是：<code>arr.length = 0</code>，但该过程是不可逆的；</p>
</blockquote>
<blockquote>
<p>Note: 如果使用 <code>==</code> 来比较数组，除非比较的是两个引用同一数组的变量，否则它们永远不相等；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大子数组之和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxSubSum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxSum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> partialSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    partialSum += item; <span class="comment">// 将其加到 partialSum</span></span><br><span class="line">    maxSum = <span class="built_in">Math</span>.max(maxSum, partialSum); <span class="comment">// 记住最大值</span></span><br><span class="line">    <span class="keyword">if</span> (partialSum &lt; <span class="number">0</span>) partialSum = <span class="number">0</span>; <span class="comment">// 如果是负数就置为 0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><p><strong>splice</strong></p>
<p>arr.splice(start[, deleteCount, elem1, …, elemN])，从索引 start 开始修改 arr，start 可以为负数：删除 deleteCount 个元素并在当前位置插入 elem1, …, elemN，最后返回已被删除元素的数组；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第一个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">0</span>, <span class="number">1</span>), arr); <span class="comment">// [1] [2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 删除最后一个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(-<span class="number">1</span>, <span class="number">1</span>), arr); <span class="comment">// [5] [2, 3, 4]</span></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="number">100</span>), arr); <span class="comment">// [] [2, 3, 100, 4] </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 将 <code>deleteCount</code> 设置为 <code>0</code>，<code>splice</code> 方法就能够插入元素而不用删除任何元素；</p>
</blockquote>
<p><strong>slice</strong></p>
<p>arr.slice([start], [end]) 返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组；start 和 end 都可以是负数，在这种情况下，从末尾计算索；</p>
<blockquote>
<p>Tips: 可以不带参数地调用：<code>arr.slice()</code> 会创建一个 <code>arr</code> 的副本；进行不影响原始数组的进一步转换；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;t&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>];</span><br><span class="line"></span><br><span class="line">alert( arr.slice(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// e,s（复制从位置 1 到位置 3 的元素）</span></span><br><span class="line">alert( arr.slice(-<span class="number">2</span>) ); <span class="comment">// s,t（复制从位置 -2 到尾端的元素）</span></span><br></pre></td></tr></table></figure>

<p><strong>concat</strong></p>
<p>arr.concat(arg1, arg2…) 创建一个新数组，其中包含来自于其他数组和其他项的值；</p>
<blockquote>
<p>Note: <code>concat</code> 只复制数组中的元素，即使是一个类数组的对象，也会被当作一个整体；除非类数组的对象具有 <code>Symbol.isConcatSpreadable</code> 属性，那么它就会被 <code>concat</code> 当作一个数组来处理；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  length: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike2 = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>,</span><br><span class="line">  length: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( arr.concat([<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>) ); <span class="comment">// 1,2,3,4,5</span></span><br><span class="line">alert( arr.concat(arrayLike, arrayLike2) ); <span class="comment">// 1,2,3,4,5,[object Object],something</span></span><br></pre></td></tr></table></figure>

<p><strong>forEach</strong></p>
<p>arr.forEach 方法允许为数组的每个元素都运行一个函数；且该函数的结果（如果有返回）会被抛弃和忽略；</p>
<p><strong>indexOf/lastIndexOf 和 includes</strong></p>
<p>arr.indexOf(item, from)/arr.lastIndexOf(item, from) 都从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1；后者从右向左搜索；arr.includes(item, from) 从索引 from 开始搜索 item，如果找到返回 true，否则返回 false；</p>
<blockquote>
<p>Tips: 这些方法使用的是严格相等 <code>===</code> 比较，<code>includes</code> 的一个非常小的差别是它能正确处理NaN，而 <code>indexOf/lastIndexOf</code> 则不能；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>, <span class="literal">null</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.indexOf(<span class="literal">NaN</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.indexOf(<span class="literal">null</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.lastIndexOf(<span class="literal">undefined</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.includes(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.includes(<span class="literal">null</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.warn(arr2.includes(<span class="literal">undefined</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>find/findIndex 和 filter</strong></p>
<p>在对象数组中查找具有特定条件的对象，可以使用 find/findIndex 和 filter 方法；</p>
<p>arr.find((item, index, array) =&gt; {…}) 依次对数组中的每个元素调用一个回调函数，其中 item 是元素，index 是它的索引，array 是数组本身；如果回调函数返回 true，则返回 item 并停止迭代，如果返回假值（falsy），则返回 undefined；</p>
<p>arr.findIndex 与 arr.find 的区别只有返回值，前者返回元素索引，后者返回元素本身；</p>
<p>arr.filter 方法返回所有匹配（使回调函数返回 true）元素组成的数组；</p>
<p><strong>map 和 some/every</strong></p>
<p>arr.map((item, index, array) =&gt; { … }) 对数组的每个元素都调用函数，并返回一个新的结果数组；</p>
<p>arr.some(fn)/arr.every(fn) 用于检查数组，对数组的每个元素调用函数 fn；如果任何/所有结果为 true，则返回 true，否则返回 false；且存在短路效应；</p>
<p><strong>sort</strong></p>
<p>arr.sort 方法对数组进行原位（in-place） 排序，并更改元素的顺序，原位是指在此数组内，而非生成一个新数组；</p>
<blockquote>
<p>Note: 元素默认情况下被按字符串进行排序；所有元素都被转换为字符串，然后进行比较，对于字符串，按照词典顺序进行排序；</p>
</blockquote>
<p>arr.sort(fn) 方法实现了通用的排序算法，在内部大多数情况下都是经过快速排序或 Timsort 算法优化的；比较函数 fn 可以返回任何数字，实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// [-2, 0, 1, 2, 8, 15]</span></span><br></pre></td></tr></table></figure>

<p>快速排序是对冒泡排序的一种改进，由 C.A.R.Hoare（Charles Antony Richard Hoare，东尼·霍尔）在 1962 年提出；这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序 js 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuickSort</span>(<span class="params">arr, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = start;</span><br><span class="line">  <span class="keyword">let</span> j = end;</span><br><span class="line">  <span class="keyword">let</span> key = arr[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="comment">// 往前找小于的数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">      arr[i++] = arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往后找大于的数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; key) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">      arr[j--] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  arr[i] = key;</span><br><span class="line">  QuickSort(arr, start, i - <span class="number">1</span>);</span><br><span class="line">  QuickSort(arr, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">72</span>, <span class="number">6</span>, <span class="number">57</span>, <span class="number">88</span>, <span class="number">60</span>, <span class="number">42</span>, <span class="number">83</span>, <span class="number">73</span>, <span class="number">48</span>, <span class="number">85</span>];</span><br><span class="line">QuickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [6, 42, 48, 57, 60, 72, 73, 83, 85, 88]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://data.biancheng.net/view/117.html">快速排序算法详解（原理、实现和时间复杂度）</a></li>
<li><a href="https://sikasjc.github.io/2018/07/25/timsort/">Timsort原理学习</a></li>
<li><a href="https://v8.dev/blog/array-sort#timsort">Getting things sorted in V8</a></li>
</ul>
<p><strong>reverse</strong></p>
<p>arr.reverse 方法用于颠倒 arr 中元素的顺序，同时也会返回颠倒后的数组 arr；</p>
<p><strong>split 和 join</strong></p>
<p>str.split(delim[, limit]) 方法通过给定的分隔符 delim 将字符串分割成一个数组；split 还有一个可选的第二个数字参数，可以限制数组长度，忽略额外的元素；</p>
<blockquote>
<p>Tips: 调用带有空字符串参数的 <code>split(&#39;&#39;)</code>，会将字符串拆分为字母数组；如果一个元素为 <code>undefined</code> 或 <code>null</code>，它会被转换为空字符串；</p>
</blockquote>
<p>arr.join(glue) 与 split 相反，该方法会创建并返回一个由连接符连接的数组元素的字符串；</p>
<p><strong>reduce/reduceRight</strong></p>
<p>arr.reduce((accumulator, item, index, array) =&gt; { … }, [initial]) 函数一个接一个地应用于所有数组元素，并将其结果“搬运”到下一个调用，其中 accumulator 是上一个函数调用的结果，第一次等于 initial（若存在）；arr.reduceRight 和 arr.reduce 方法的功能一样，只是遍历为从右到左；</p>
<p><strong>fill 和 copyWithin</strong></p>
<p>arr.fill(value, start, end) 从索引 start 到 end，用重复的 value 填充数组；</p>
<p>arr.copyWithin(target, start, end) 将从位置 start 到 end 的所有元素复制到自身的 target 位置（覆盖现有元素）；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">alert(result); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>如果没有初始值，那么 reduce 会将数组的第一个元素作为初始值，并从第二个元素开始迭代；但如果数组为空，那么在没有初始值的情况下调用 reduce 会导致错误；所以建议始终指定初始值；</p>
<p><strong>Array.isArray</strong></p>
<p>因为数组是基于对象的，不构成单独的语言类型，所以 typeof 不能帮助从数组中区分出普通对象；但可以使用 Array.isArray() 方法判断；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> []); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Array</span>.isArray(&#123;&#125;)); <span class="comment">// false</span></span><br><span class="line">alert(<span class="built_in">Array</span>.isArray([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>thisArg</strong></p>
<p>几乎所有调用函数的数组方法，都接受一个可选的附加参数 thisArg；当数组方法的回调函数为普通函数时，该参数值为 this；当使用对象方法作为数组方法的回调函数时，通过该参数将对象上下文语境传入；（不常用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> army = &#123;</span><br><span class="line">  minAge: <span class="number">18</span>,</span><br><span class="line">  maxAge: <span class="number">27</span>,</span><br><span class="line">  <span class="function"><span class="title">canJoin</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> user.age &gt; <span class="number">20</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> users = [&#123; <span class="attr">age</span>: <span class="number">16</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">23</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">30</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> soldiers = users.filter(army.canJoin, army);</span><br><span class="line"><span class="built_in">console</span>.log(soldiers); <span class="comment">// [&#123;age: 23&#125;, &#123;age: 30&#125;]</span></span><br></pre></td></tr></table></figure>

<p><strong>其他方法</strong></p>
<p>arr.flat(depth)/arr.flatMap(fn) 可以从多维数组创建一个新的扁平数组；</p>
<p>Array.of(element0[, element1[, …[, elementN]]]) 基于可变数量的参数创建一个新的 Array 实例，而不需要考虑参数的数量或类型；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fisher-Yates shuffle 随机排列数组</span></span><br><span class="line"><span class="comment">// 思路：逆向遍历数组，并将每个元素与其前面的随机的一个元素互换位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 从 0 到 i 的随机索引</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>)); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解构交换元素 array[i] 和 array[j]</span></span><br><span class="line">    [array[i], array[j]] = [array[j], array[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h4><p>可迭代（Iterable）对象是数组的泛化，这个概念是说任何对象都可以被定制为可在 for..of 循环中使用的对象；数组和字符串是使用最广泛的内建可迭代对象；</p>
<p>为了让对象可迭代，需要为对象添加一个名为 Symbol.iterator 的方法，该方法是一个专门用于使对象可迭代的内建 symbol；</p>
<p>for..of 循环：</p>
<ol>
<li>首先会调用 Symbol.iterator 方法（没有就报错）；</li>
<li>这个方法必须返回一个迭代器（iterator）即一个有 next 方法的对象；</li>
<li>此后，for..of 仅适用于这个被返回的对象；</li>
<li>然后通过调用返回对象的 next() 方法 for..of 循环取得下一个数值；</li>
<li>next() 方法返回的结果的格式必须是 { done: Boolean, value: any }；</li>
<li>当 done = true 时，表示循环结束，否则 value 是下一个值；</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义可迭代对象 range</span></span><br><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="comment">// 返回一个带有 next 方法的对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      current: <span class="built_in">this</span>.from,</span><br><span class="line">      last: <span class="built_in">this</span>.to,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在每轮 for..of 循环中调用</span></span><br><span class="line">      <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 固定返回一个 &#123; done, value &#125; 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.current &lt; <span class="built_in">this</span>.last</span><br><span class="line">          ? &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;</span><br><span class="line">          : &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; <span class="comment">// 当 done 为 true 时，结束迭代</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> it <span class="keyword">of</span> range) &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(it); <span class="comment">// 1, 2, 3, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 注意可迭代对象的核心功能：关注点分离；<code>range</code> 自身没有 <code>next()</code> 方法，相反，是通过调用 <code>range[Symbol.iterator]()</code> 创建了另一个对象，即所谓的“迭代器”对象，并且它的 <code>next</code> 会为迭代生成值；</p>
</blockquote>
<p>从技术上说，我们可以将它们合并，并使用 range 自身作为迭代器来简化代码，但现在不可能同时在对象上运行两个 for..of 循环：它们共享迭代状态，因为只有一个迭代器，即对象本身；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">this</span>.from;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.current &lt; <span class="built_in">this</span>.to</span><br><span class="line">      ? &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;</span><br><span class="line">      : &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 无穷迭代器，<code>next</code> 没有什么限制，它可以返回越来越多的值，这是正常的，可以通过 <code>break</code> 跳出 <code>for..of</code> 循环；</p>
</blockquote>
<p><strong>可迭代和类数组</strong></p>
<p>Iterable 如上所述，是实现了 Symbol.iterator 方法的对象；Array-like 是有索引和 length 属性的对象，所以它们看起来很像数组；但是一个可迭代对象也许不是类数组对象，反之亦然，类数组对象可能不可迭代</p>
<blockquote>
<p>Note: 字符串即是可迭代的（<code>for..of</code> 对它们有效），又是类数组的（它们有数值索引和 <code>length</code> 属性）；</p>
</blockquote>
<p><strong>Array.from</strong></p>
<p>全局方法 Array.from 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组；Array.from(obj[, mapFn, thisArg]) 完整语法还允许我们提供一个可选的“映射（mapping）”函数；可选的第二个参数 mapFn 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 thisArg 允许我们为该函数设置 this；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(range);</span><br><span class="line">alert(arr); <span class="comment">// 1,2,3,4,5 （数组的 toString 转化方法生效）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求每个数的平方</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(range, <span class="function"><span class="params">num</span> =&gt;</span> num * num);</span><br><span class="line">alert(arr); <span class="comment">// 1,4,9,16,25</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 基于 <code>Array.from</code> 创建代理感知（surrogate-aware）的 <code>slice</code> 方法，即能够处理 <code>UTF-16</code> 扩展字符的 <code>slice</code> 方法；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slice</span>(<span class="params">str, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(str).slice(start, end).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𝒳😂𩷶&#x27;</span>;</span><br><span class="line">alert( slice(str, <span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 😂𩷶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生方法不支持识别代理对（译注：UTF-16 扩展字符）</span></span><br><span class="line">alert( str.slice(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 在规范中，大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高；</p>
</blockquote>
<h4 id="Map-and-Set（映射和集合）"><a href="#Map-and-Set（映射和集合）" class="headerlink" title="Map and Set（映射和集合）"></a>Map and Set（映射和集合）</h4><p><strong>Map</strong></p>
<p>Map 是一个带键的数据项的集合，就像一个 Object 一样；但 Map 允许任何类型的键（key），包括对象；</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">new Map()</td>
<td align="left">创建 map</td>
</tr>
<tr>
<td align="left">map.set(key, value)</td>
<td align="left">根据键存储值，并返回 map 本身，因此可以链式调用</td>
</tr>
<tr>
<td align="left">map.get(key)</td>
<td align="left">根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined</td>
</tr>
<tr>
<td align="left">map.has(key)</td>
<td align="left">如果 key 存在则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="left">map.delete(key)</td>
<td align="left">删除指定键的值</td>
</tr>
<tr>
<td align="left">map.clear()</td>
<td align="left">清空 map</td>
</tr>
<tr>
<td align="left">map.size</td>
<td align="left">返回当前元素个数</td>
</tr>
</tbody></table>
<blockquote>
<p>Note: 虽然 <code>map[key]</code> 也有效，例如我们可以设置 <code>map[key] = 2</code>，这样会将 <code>map</code> 视为 JavaScript 的普通对象 <code>plain object</code>，因此它暗含了所有相应的限制（仅支持 <code>string</code>/<code>symbol</code> 键等）</p>
</blockquote>
<blockquote>
<p>Note: <code>Map</code> 使用 <code>SameValueZero</code> 算法来比较键是否相等，它和严格等于 <code>===</code> 差不多，但区别是 <code>NaN</code> 被看成是等于 <code>NaN</code>，所以 <code>NaN</code> 也可以被用作键；</p>
</blockquote>
<p><strong>Map 迭代</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">map.keys()</td>
<td align="left">返回所有键的迭代器</td>
</tr>
<tr>
<td align="left">map.values()</td>
<td align="left">返回所有值的迭代器</td>
</tr>
<tr>
<td align="left">map.entries()</td>
<td align="left">返回所有实体 [key, value] 的迭代器</td>
</tr>
<tr>
<td align="left">map.forEach((value, key, map) =&gt; {})</td>
<td align="left">与 Array 的类似</td>
</tr>
</tbody></table>
<p>for..of 在遍历 map 时，默认情况下使用的是 map.entries 方法；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化空 Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;str1&quot;</span>).set(<span class="number">1</span>, <span class="string">&quot;num1&quot;</span>).set(<span class="literal">true</span>, <span class="string">&quot;bool1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// [&#x27;1&#x27;, &#x27;str1&#x27;] [1, &#x27;num1&#x27;] [true, &#x27;bool1&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带键值对的二维数组初始化 Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;1&#x27;</span>,  <span class="string">&#x27;str1&#x27;</span>],</span><br><span class="line">  [<span class="number">1</span>,    <span class="string">&#x27;num1&#x27;</span>],</span><br><span class="line">  [<span class="literal">true</span>, <span class="string">&#x27;bool1&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可迭代对象初始化 Map，iter 返回键值对的数组</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(iter);</span><br></pre></td></tr></table></figure>

<p><strong>Map 与对象的转换</strong></p>
<p>Object.entries(obj) 该方法返回对象的键/值对数组，该数组格式完全按照 Map 所需的格式；因此可以根据一个已有的普通对象（plain object）来创建一个 Map；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure>

<p>而 Object.fromEntries 作用是给定一个具有 [key, value] 键值对的数组，它会根据给定数组创建一个对象；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;banana&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">map.set(<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">map.set(<span class="string">&#x27;meat&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个普通对象</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(map.entries()); </span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(map); <span class="comment">// 效果同上，解释如下</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: <code>Object.fromEntries</code> 期望得到一个可迭代对象作为参数，而不一定是数组，并且 <code>map</code> 的标准迭代会返回跟 <code>map.entries()</code> 一样的键/值对；</p>
</blockquote>
<p><strong>Set</strong></p>
<p>Set 是一个特殊的类型集合，没有键，只有值的集合，且它的每一个值只能出现一次；</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">new Set(iterable)</td>
<td align="left">创建一个 set，参数是一个 iterable 对象</td>
</tr>
<tr>
<td align="left">set.add(value)</td>
<td align="left">添加一个值，返回 set 本身</td>
</tr>
<tr>
<td align="left">set.delete(value)</td>
<td align="left">删除值，如果 value 存在则返回 true ，否则返回 false</td>
</tr>
<tr>
<td align="left">set.has(value)</td>
<td align="left">如果 value 在 set 中，返回 true，否则返回 false</td>
</tr>
<tr>
<td align="left">set.clear()</td>
<td align="left">清空 set</td>
</tr>
<tr>
<td align="left">set.size</td>
<td align="left">返回元素个数</td>
</tr>
</tbody></table>
<p>Set 的主要特点是，重复使用同一个值调用 set.add(value) 并不会发生什么改变，这就是 Set 里面的每一个值只出现一次的原因；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>])); <span class="comment">// [1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>Set 迭代</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">set.keys()</td>
<td align="left">返回包含所有值的迭代器</td>
</tr>
<tr>
<td align="left">set.values()</td>
<td align="left">同 keys，为了兼容 Map</td>
</tr>
<tr>
<td align="left">set.entries()</td>
<td align="left">返回所有实体 [value, value] 的迭代器，为了兼容 Map</td>
</tr>
<tr>
<td align="left">set.forEach((value, valueAgain, set) =&gt; {})</td>
<td align="left">与 Array 的类似，也为了兼容 Map</td>
</tr>
</tbody></table>
<blockquote>
<p>Tips: 在 <code>Map</code> 和 <code>Set</code> 中迭代总是按照值插入的顺序进行的，所以我们不能说这些集合是无序的，但是我们不能对元素进行重新排序，也不能直接按其编号来获取元素；</p>
</blockquote>
<h4 id="WeakMap-and-WeakSet"><a href="#WeakMap-and-WeakSet" class="headerlink" title="WeakMap and WeakSet"></a>WeakMap and WeakSet</h4><p><strong>WeakMap</strong></p>
<p>WeakMap 和 Map 的第一个不同点就是，WeakMap 的键必须是对象，不能是原始值；</p>
<p>WeakMap 不支持迭代以及 keys()，values() 和 entries() 方法，所以没有办法获取 WeakMap 的所有键或值；只有 get(key)、set(key, value)、delete(key)、has(key) 方法；</p>
<blockquote>
<p>Note: <code>WeakMap</code> 不会阻止垃圾回收机制对作为键的对象（key object）的回收，在从技术的角度并不能准确知道 何时会被回收，这些都是由 JavaScript 引擎决定的；因此，暂不支持访问 <code>WeakMap</code> 的所有键/值的方法；</p>
</blockquote>
<blockquote>
<p>Tips: <code>WeakMap</code> 的主要应用场景是额外数据的存储；这些数据放到 <code>WeakMap</code> 中，并使用第三方对象作为这些数据的键，那么当该对象被垃圾回收机制回收后，这些数据也会被自动清除；</p>
</blockquote>
<blockquote>
<p>Tips: <code>WeakMap</code> 也可以用于缓存函数的结果，以便将来对同一个对象的调用可以重用这个结果；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cache.js</span></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算并记结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!cache.has(obj)) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="comment">/* calculate the result for */</span> obj;</span><br><span class="line"></span><br><span class="line">    cache.set(obj, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cache.get(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="comment">/* some object */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = process(obj);</span><br><span class="line"><span class="keyword">let</span> result2 = process(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要这个对象时：</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p><strong>WeakSet</strong></p>
<p>与 Set 类似，但是我们只能向 WeakSet 添加对象（而不能是原始值）；且对象只有在其它某个（些）地方能被访问的时候，才能留在 set 中；WeakSet 支持 add，has 和 delete 方法，但不支持 size 和 keys()，并且不可迭代；</p>
<blockquote>
<p>Tips: <code>WeakSet</code> 同 <code>WeakMap</code> 的主要优点是对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除；</p>
</blockquote>
<h4 id="Object-keys，values，entries"><a href="#Object-keys，values，entries" class="headerlink" title="Object.keys，values，entries"></a>Object.keys，values，entries</h4><p>对于普通对象：</p>
<p>Object.keys(obj) 返回一个包含该对象所有的键的数组；<br>Object.values(obj) 返回一个包含该对象所有的值的数组；<br>Object.entries(obj) 返回一个包含该对象所有 [key, value] 键值对的数组；</p>
<blockquote>
<p>Note: <code>Object.*</code> 方法返回的是“真正的”数组对象，而不只是一个可迭代项，这与 <code>Map</code> 有区别，这主要是历史原因；<code>Object.*</code> 还会忽略 <code>symbol</code> 属性；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换对象</span></span><br><span class="line"><span class="keyword">let</span> prices = &#123;</span><br><span class="line">  banana: <span class="number">1</span>,</span><br><span class="line">  orange: <span class="number">2</span>,</span><br><span class="line">  meat: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doublePrices = <span class="built_in">Object</span>.fromEntries(</span><br><span class="line">  <span class="comment">// 将价格转换为数组，将每个键/值对映射为另一对</span></span><br><span class="line">  <span class="comment">// 然后通过 fromEntries 再将结果转换为对象</span></span><br><span class="line">  <span class="built_in">Object</span>.entries(prices).map(<span class="function"><span class="params">entry</span> =&gt;</span> [entry[<span class="number">0</span>], entry[<span class="number">1</span>] * <span class="number">2</span>])</span><br><span class="line">);</span><br><span class="line">alert(doublePrices.meat); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以是一个类似于 map.entries() 的迭代器</span></span><br><span class="line"><span class="built_in">Object</span>.fromEntries(rangeEntries); <span class="comment">// &#123;1: 1, 2: 1, 3: 1, 4: 1&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算属性之和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumSalaries</span>(<span class="params">salaries</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.values(salaries).reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>JavaScript 中最常用的两种数据结构是 Object 和 Array；对象是通过键来存储数据项的单个实体，数组将数据收集到一个有序的集合；</p>
<p>解构赋值是通过将结构中的各元素复制到变量中来达到“解构”的目的，但结构本身是没有被修改的；本质上，解构赋值其实是一种用于对在 = 右侧的值上调用 for..of 并进行赋值的操作的语法糖；</p>
<p><strong>数组解构</strong></p>
<ol>
<li>数组中不想要的元素也可以通过添加额外的逗号来把它丢弃；</li>
<li>等号右侧可以是任何可迭代对象，因为在内部，结构赋值是通过迭代右侧的值来完成工作的；</li>
<li>赋值给等号左侧的任何内容，也可以是一个对象属性；</li>
<li>可以与 .entries() 方法进行循环操作；</li>
<li>可以用于交换变量；</li>
<li>等号左侧可以收集剩余数组项；</li>
<li>如果数组比左边的变量列表短，缺少的值被认为是 undefined；</li>
<li>可在等号左侧指定默认值，默认值可以是更加复杂的表达式甚至可以是函数调用；</li>
<li></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Smith&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [firstName, surname] = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配合 split 使用</span></span><br><span class="line"><span class="keyword">let</span> [firstName, surname] = <span class="string">&quot;John Smith&quot;</span>.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略使用逗号的元素，不需要第二个元素，后面剩余值被忽略</span></span><br><span class="line"><span class="keyword">let</span> [firstName, , title] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等号右侧可以是任何可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="keyword">let</span> [one, two, three] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历键—值对</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(user)) &#123;</span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// name:John, then age:30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换变量</span></span><br><span class="line">[guest, admin] = [admin, guest];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集剩余项，rest 的值就是数组中剩下的元素组成的数组</span></span><br><span class="line"><span class="keyword">let</span> [name1, name2, ...rest] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也不会出现报错，缺省值为 undefined</span></span><br><span class="line"><span class="keyword">let</span> [firstName, surname] = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定未赋值的变量默认值</span></span><br><span class="line"><span class="keyword">let</span> [name = <span class="string">&quot;Guest&quot;</span>, surname = <span class="string">&quot;Anonymous&quot;</span>] = [<span class="string">&quot;Julius&quot;</span>];</span><br><span class="line"><span class="comment">// 表达式或函数只会在这个变量未被赋值的时候才会被计算</span></span><br><span class="line"><span class="keyword">let</span> [name = prompt(<span class="string">&#x27;name?&#x27;</span>), surname = prompt(<span class="string">&#x27;surname?&#x27;</span>)] = [<span class="string">&quot;Julius&quot;</span>];</span><br></pre></td></tr></table></figure>

<p><strong>对象解构</strong></p>
<ol>
<li>可以使用 : 指定属性和变量之间的映射关系；</li>
<li>可以使用 = 设置默认值；</li>
<li>默认值可以是任意表达式或函数调用，且只会在未提供对应的值时才会被计算/调用；</li>
<li>可以只提取所需的内容；</li>
<li>可以提取剩余属性的，并存为对象；</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">200</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本使用，且变量的顺序并不重要</span></span><br><span class="line"><span class="keyword">let</span> &#123; title, width, height &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定属性和变量之间的映射关系</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">width</span>: w, <span class="attr">height</span>: h, title &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &quot;=&quot; 设置默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123; width = <span class="number">100</span>, height = <span class="number">200</span>, title &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值可以是任意表达式甚至可以是函数调用</span></span><br><span class="line"><span class="keyword">let</span> &#123; width = prompt(<span class="string">&quot;width?&quot;</span>), title = prompt(<span class="string">&quot;title?&quot;</span>) &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时指定映射关系和默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">width</span>: w = <span class="number">100</span>, <span class="attr">height</span>: h = <span class="number">200</span>, title &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只提取所需的内容</span></span><br><span class="line"><span class="keyword">let</span> &#123; title &#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest 存有剩余属性的对象</span></span><br><span class="line"><span class="keyword">let</span> &#123; title, ...rest &#125; = options;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 不使用 <code>let</code> 时可能存在 JavaScript 引擎把 <code>&#123;...&#125;</code> 当作代码块处理；因此需要用括号将解构赋值语句包裹起来；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title, width, height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;=&#x27;</span></span><br><span class="line">&#123;title, width, height&#125; = &#123;<span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加括号后，正常运行</span></span><br><span class="line">(&#123;title, width, height&#125; = &#123;<span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 如果一个对象或数组嵌套了其他的对象和数组，可以在等号左侧使用更复杂的模式来提取更深层的数据，也称嵌套结构；</p>
</blockquote>
<blockquote>
<p>Tips: 可以把所有参数当作一个对象来传递，然后函数马上把这个对象解构成多个变量；然后通过指定空对象 <code>&#123;&#125;</code> 为整个参数对象的默认值，实现让所有的参数都使用默认值；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">&#123; title = <span class="string">&quot;Untitled&quot;</span>, width: w = <span class="number">100</span>, height: h = <span class="number">200</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;w&#125;</span> <span class="subst">$&#123;h&#125;</span>`</span> ); <span class="comment">// My Menu 100 200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种默认 options 参数</span></span><br><span class="line"><span class="keyword">let</span> defaultOptions = &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> computedOptions = &#123; ...defaultOptions, ...options &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(computedOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p>内建对象：日期（Date）用于存储日期和时间，并提供了日期/时间的管理方法；</p>
<p><strong>创建方法</strong>：</p>
<ol>
<li>new Date() 不带参数，创建当前日期和时间的 Date 对象；</li>
<li>new Date(milliseconds) 传入的整数参数代表自 1970-01-01 00:00:00 以来经过的毫秒数，该整数被称为时间戳，时间戳也可以为负；</li>
<li>new Date(datestring) 若只有一个字符串参数，则会被自动解析；该算法与 Date.parse 所使用的算法相同；</li>
<li>new Date(year, month, date, hours, minutes, seconds, ms) 使用当前时区中的给定组件创建日期，只有前两个参数是必须的；year 必须是四位数，month 是 0 到 11 的整数，date 是当月的具体某一天，缺失则默认 1，hours/minutes/seconds/ms 缺失则均为默认值 0；</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new Date()</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// Fri Mar 04 2022 08:57:13 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new Date(milliseconds)</span></span><br><span class="line"><span class="keyword">let</span> Jan01_1970 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>); <span class="comment">// 0 表示 01.01.1970 UTC+0</span></span><br><span class="line"><span class="keyword">let</span> Dec31_1969 = <span class="keyword">new</span> <span class="built_in">Date</span>(-<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>); <span class="comment">// 负时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new Date(datestring)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2017-01-26&quot;</span>);</span><br><span class="line"><span class="comment">// 该时间未被设定，因此被假定为格林尼治标准时间（GMT）的午夜</span></span><br><span class="line"><span class="comment">// 并会根据代码运行时的时区进行调整，因此可能得到以下结果</span></span><br><span class="line"><span class="comment">// Thu Jan 26 2017 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)</span></span><br><span class="line"><span class="comment">// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new Date(year, month, date, hours, minutes, seconds, ms)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 1 Jan 2011, 00:00:00</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">567</span>); <span class="comment">// 1.01.2011, 02:03:04.567</span></span><br></pre></td></tr></table></figure>

<p><strong>访问日期</strong></p>
<ol>
<li>getFullYear() 获取年份（4 位数）；</li>
<li>getMonth() 获取月份，从 0 到 11；</li>
<li>getDate() 获取当月的具体日期，从 1 到 31；</li>
<li>getHours()，getMinutes()，getSeconds()，getMilliseconds() 获取相应的时间组件；</li>
<li>getDay() 获取一周中的第几天，从 0（星期日）到 6（星期六），第一天始终是星期日；</li>
<li>getTime() 返回日期的时间戳，从 1970-1-1 00:00:00 UTC+0 到现在所经过的毫秒数；</li>
<li>getTimezoneOffset() 返回 UTC 与本地时区之间的时差，以分钟为单位；</li>
</ol>
<p>getTimezoneOffset()<br>返回 UTC 与本地时区之间的时差，以分钟为单位</p>
<blockquote>
<p>Note: 很多 JavaScript 引擎都实现了一个非标准化的方法 <code>getYear()</code>，不推荐使用这个方法，直接使用 <code>getFullYear()</code>；</p>
</blockquote>
<blockquote>
<p>Tips: <code>get*</code> （除上述最后两个） 这类方法都是基于当地时区的；可以在 “get” 之后插入 “UTC”，使用 <code>getUTC*</code> 以获取与当地时区的 UTC 对应项；</p>
</blockquote>
<blockquote>
<p>Tips: <code>new Date().getUTCHours() - new Date().getHours()</code> 可得到当地时区相对于 UTC 的偏移；UTC 也即非夏令时的伦敦时间；</p>
</blockquote>
<p><strong>设置日期</strong></p>
<ol>
<li>setFullYear(year, [month], [date])</li>
<li>setMonth(month, [date])</li>
<li>setDate(date)</li>
<li>setHours(hour, [min], [sec], [ms])</li>
<li>setMinutes(min, [sec], [ms])</li>
<li>setSeconds(sec, [ms])</li>
<li>setMilliseconds(ms)</li>
<li>setTime(milliseconds)</li>
</ol>
<p>以上方法除了 setTime() 都有 UTC 变体；</p>
<blockquote>
<p>Tips: 自动校准 是 <code>Date</code> 对象的一个非常方便的特性，当设置超范围的数值，会被自动校准；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动考虑闰年情况</span></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">28</span>);</span><br><span class="line">date.setDate(date.getDate() + <span class="number">2</span>); <span class="comment">// 2016.03.01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 2016.01.02</span></span><br><span class="line"><span class="comment">// 设置为当月的第一天</span></span><br><span class="line">date.setDate(<span class="number">1</span>); <span class="comment">// 2016.01.01</span></span><br><span class="line"><span class="comment">// 天数最小可以设置为 1，所以这里设置的是上一月的最后一天</span></span><br><span class="line">date.setDate(<span class="number">0</span>); <span class="comment">// 2015.12.31</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 利用 Date 对象转数字可快速获取时间戳；<code>+new Date()</code> 即当前时间戳；此外日期可以相减，相减的结果是以毫秒为单位时间差；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// 1646360860388</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">28</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>() - date); <span class="comment">// 31919237496</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 当只需要时间戳而不需要创建日期对象时，可以使用 Date.now() 获取当前时间戳；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测量时间间隔</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now(); <span class="comment">// 从 1 Jan 1970 至今的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> doSomething = i * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> end = <span class="built_in">Date</span>.now(); <span class="comment">// 完成</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">`The loop took <span class="subst">$&#123;end - start&#125;</span> ms`</span> ); <span class="comment">// 相减的是时间戳，而不是日期</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 直接使用日期对象相减得到时间差比使用 <code>getTime()</code> 方法慢，因为 JavaScript 引擎还要做类型转换的额外工作；</p>
</blockquote>
<p>为了得到更加可靠的度量，整个度量测试包应该重新运行多次，现代的 JavaScript 引擎的先进优化策略只对执行很多次的 “hot code” 有效，即对于执行很少次数的代码没有必要优化；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffSubtract</span>(<span class="params">date1, date2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> date2 - date1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffGetTime</span>(<span class="params">date1, date2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> date2.getTime() - date1.getTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bench</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) f(date1, date2);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Date</span>.now() - start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> time1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> time2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主循环中增加“升温”环节</span></span><br><span class="line">bench(diffSubtract);</span><br><span class="line">bench(diffGetTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始度量，交替运行 10 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  time1 += bench(diffSubtract);</span><br><span class="line">  time2 += bench(diffGetTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( <span class="string">&#x27;Total time for diffSubtract: &#x27;</span> + time1 );</span><br><span class="line">alert( <span class="string">&#x27;Total time for diffGetTime: &#x27;</span> + time2 );</span><br></pre></td></tr></table></figure>

<p><strong>Date.parse</strong></p>
<p>Date.parse(str) 方法可以从一个字符串中读取日期；字符串的格式应该为：YYYY-MM-DDTHH:mm:ss.sssZ，其中：</p>
<ol>
<li>YYYY-MM-DD 日期：年-月-日；</li>
<li>字符 “T” 是一个分隔符；</li>
<li>HH:mm:ss.sss 时间：小时，分钟，秒，毫秒；</li>
<li>可选字符 ‘Z’ 为 +-hh:mm 格式的时区，单个字符 Z 代表 UTC+0 时区；</li>
</ol>
<p>Date.parse(str) 调用会解析给定格式的字符串，并返回时间戳，如果给定字符串的格式不正确，则返回 NaN；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ms = <span class="built_in">Date</span>.parse(<span class="string">&#x27;2012-01-26T13:51:50.417-07:00&#x27;</span>); <span class="comment">// 1327611110417</span></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>( <span class="built_in">Date</span>.parse(<span class="string">&#x27;2012-01-26T13:51:50.417-07:00&#x27;</span>) );</span><br></pre></td></tr></table></figure>

<p><strong>其他例子</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取某月的最后一天</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLastDayOfMonth</span>(<span class="params">year, month</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(year, month + <span class="number">1</span>, <span class="number">0</span>).getDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算今天过去了多少秒</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSecondsToday</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Date</span>.now() % (<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>) / <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>相关拓展</strong></p>
<blockquote>
<p>1884 年，华盛顿的国际经度会议规定，将全球按经线从东到西划分为 24 个时区，其中东、西各 12 个时区，同时规定英国（格林尼治天文台旧址）为零时区，这就诞生了第一个世界时：格林尼治标准时间（Greenwich Mean Time，缩写为GMT，又称格林尼治平时）；中国跨 5 个时区，实际上只用东八时区的标准时即北京时间为准；</p>
</blockquote>
<blockquote>
<p>1972 年诞生了：协调世界时（Universal Time Coordinated，缩写为UTC）；UTC 是当前的世界标准时间；UTC 与 GMT 基本上等同，误差不超过 0.9 秒；UTC 的标准格式为 2019-11-11T00:00:00.000Z，T 代表使用 UTC 时间，Z 是 UTC 偏移量，表示 UTC 时间与本地时的差别、即时差，可用以下形式表示: ±[hh]:[mm]、±[hh][mm]、±[hh]，例如北京时间比 GMT 要早 8 小时，写作 2019-11-11T08:00:00.000+0800</p>
</blockquote>
<blockquote>
<p>Unix 时间(Unix Time)，也叫做 POSIX 时间或纪元时间(Epoch Time)，是用来记录时间的流逝，所以也常被叫做时间戳，定义为从 1970-01-01T00:00:00 开始流逝的秒数，不考虑闰秒；之后的时间是正数，之前的是负数；</p>
</blockquote>
<p><a href="https://blog.csdn.net/zgdwxp/article/details/102728563">时区是怎么划分的？世界各时区的时间如何统一表达？GMT、UTC、UNIX有什么区别？</a></p>
<h4 id="JSON-方法，toJSON"><a href="#JSON-方法，toJSON" class="headerlink" title="JSON 方法，toJSON"></a>JSON 方法，toJSON</h4><p>JSON（JavaScript Object Notation）是表示值和对象的通用格式；</p>
<p><strong>JSON.stringify</strong></p>
<p>该方法将对象转换为 JSON；得到的 json 字符串是一个被称为 JSON 编码（JSON-encoded） 或 序列化（serialized） 或 字符串化（stringified） 或 编组化（marshalled） 的对象；</p>
<p>JSON 中没有单引号或反引号，JSON 格式字符串都使用双引号，包括对象属性名称也强制使用双引号；</p>
<p>JSON 支持以下数据类型：</p>
<ul>
<li>Objects { … }</li>
<li>Arrays [ … ]</li>
<li>strings</li>
<li>numbers</li>
<li>boolean true/false</li>
<li>null</li>
</ul>
<p>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过；</p>
<ul>
<li>函数属性（方法）</li>
<li>Symbol 类型的键和值</li>
<li>存储 undefined 的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 被忽略</span></span><br><span class="line">    alert(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>)]: <span class="number">123</span>, <span class="comment">// 被忽略</span></span><br><span class="line">  something: <span class="literal">undefined</span> <span class="comment">// 被忽略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( <span class="built_in">JSON</span>.stringify(user) ); <span class="comment">// &#123;&#125;（空对象）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>JSON.strinify</code> 支持嵌套对象转换，并且可以自动对其进行转换，但有重要的限制：不得有循环引用；</p>
</blockquote>
<p>JSON.stringify 完整语法是 JSON.stringify(value[, replacer, space])；其中 value 是要编码的值，replacer 是要编码的属性数组或映射函数 function(key, value)，space 是用于格式化的空格数量，或者字符串占位符；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">  number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">  participants: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">  place: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; <span class="comment">// room 引用了 meetup</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性数组</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(meetup, [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;participants&#x27;</span>]) );</span><br><span class="line"><span class="comment">// &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[&#123;&#125;,&#123;&#125;]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造 Object.prototype.toString 方法方便查看 replacer 调用过程</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + <span class="built_in">Object</span>.keys(<span class="built_in">this</span>).join(<span class="string">&quot;, &quot;</span>) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;result:&quot;</span>, <span class="built_in">JSON</span>.stringify(meetup, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> key == <span class="string">&quot;occupiedBy&quot;</span> ? <span class="literal">undefined</span> : value;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 根据输出结果可以看出 stringify 是递归调用的；</span></span><br><span class="line"><span class="comment">// 第一个调用是使用特殊的“包装对象”制作的：&#123;&quot;&quot;: meetup&#125;，</span></span><br><span class="line"><span class="comment">// 该键为空，值是整个目标对象；</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">: [title, participants, place]</span></span><br><span class="line"><span class="comment">title: Conference</span></span><br><span class="line"><span class="comment">participants: [name],[name]</span></span><br><span class="line"><span class="comment">0: [name]</span></span><br><span class="line"><span class="comment">name: John</span></span><br><span class="line"><span class="comment">1: [name]</span></span><br><span class="line"><span class="comment">name: Alice</span></span><br><span class="line"><span class="comment">place: [number, occupiedBy]</span></span><br><span class="line"><span class="comment">number: 23</span></span><br><span class="line"><span class="comment">occupiedBy: [title, participants, place]</span></span><br><span class="line"><span class="comment">result: &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[&#123;&quot;name&quot;:&quot;John&quot;&#125;,&#123;&quot;name&quot;:&quot;Alice&quot;&#125;],&quot;place&quot;:&#123;&quot;number&quot;:23&#125;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义 “toJSON”</strong></p>
<p>像 toString 进行字符串转换，对象也可以提供 toJSON 方法来进行 JSON 转换，如果可用，JSON.stringify 会自动调用它；</p>
<blockquote>
<p>Tips: 所有日期都有一个内建的 <code>toJSON</code> 方法来返回 UTC 格式类型的字符串；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>&#125;) </span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;date&quot;:&quot;2022-03-04T04:05:05.467Z&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: <code>toJSON</code> 既可以用于直接调用 <code>JSON.stringify</code> 也可以用于当对象嵌套在另一个编码对象中时；</p>
</blockquote>
<p><strong>JSON.parse</strong></p>
<p>该方法用于解码 JSON 字符串，完整语法：JSON.parse(str, [reviver])；其中 str 是要解析的 JSON reviver 是可选的函数 function(key,value) 该函数将为每个 (key, value) 对调用，并可以对值进行转换；</p>
<blockquote>
<p>Note: JSON 不支持注释，向 JSON 添加注释无效；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#123;&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = <span class="built_in">JSON</span>.parse(str, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="string">&#x27;date&#x27;</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert( meetup.date.getDate() ); <span class="comment">// 正常运行</span></span><br></pre></td></tr></table></figure>

<p>排除反向引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">  number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">  occupiedBy: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">  place: room</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环引用</span></span><br><span class="line">room.occupiedBy = meetup;</span><br><span class="line">meetup.self = meetup;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排除第一个调用时 value 是 meetup 的情况</span></span><br><span class="line">alert( <span class="built_in">JSON</span>.stringify(meetup, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (key != <span class="string">&quot;&quot;</span> &amp;&amp; value == meetup) ? <span class="literal">undefined</span> : value;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;title&quot;:&quot;Conference&quot;,</span></span><br><span class="line"><span class="comment">  &quot;occupiedBy&quot;:[&#123;&quot;name&quot;:&quot;John&quot;&#125;,&#123;&quot;name&quot;:&quot;Alice&quot;&#125;],</span></span><br><span class="line"><span class="comment">  &quot;place&quot;:&#123;&quot;number&quot;:23&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="递归和堆栈"><a href="#递归和堆栈" class="headerlink" title="递归和堆栈"></a>递归和堆栈</h4><p>递归是一种编程模式，在一个任务可以自然地拆分成多个相同类型但更简单的任务的情况下非常有用；简单来说，函数会调用自身就是所谓的递归；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个递归例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n == <span class="number">1</span>) ? x : (x * pow(x, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最大的嵌套调用次数（包括首次）被称为递归深度，最大递归深度受限于 JavaScript 引擎；通常，引擎在最大迭代深度为 10000 及以下时是可靠的；</p>
<p>在底层，有关正在运行的函数的执行过程的相关信息被存储在其执行上下文中；执行上下文是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置（代码位置），当前的变量，this 的值，以及其它的一些内部细节；</p>
<p>当一个函数进行嵌套调用时，当前函数被暂停，关联的执行上下文被一个叫做执行上下文堆栈的特殊数据结构保存；然后开始执行嵌套调用，嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数；因此，递归深度等于堆栈中上下文的最大数量；</p>
<blockquote>
<p>Note: 任何递归都可以用循环来重写，通常循环变体更有效，且更节省内存；</p>
</blockquote>
<blockquote>
<p>Tips: 一些引擎支持“尾调用（tail call）”优化：如果递归调用是函数中的最后一个调用，那么外部的函数就不再需要恢复执行，因此引擎也就不再需要记住他的执行上下文；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组转单链表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayToList</span>(<span class="params">arr, index = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; arr.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: arr[index],</span><br><span class="line">      next: arrayToList(arr, index + <span class="number">1</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: arr[index],</span><br><span class="line">      next: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> list = arrayToList(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">  value: 1,</span></span><br><span class="line"><span class="comment">  next: &#123;</span></span><br><span class="line"><span class="comment">    value: 2,</span></span><br><span class="line"><span class="comment">    next: &#123;</span></span><br><span class="line"><span class="comment">      value: 3,</span></span><br><span class="line"><span class="comment">      next: &#123;</span></span><br><span class="line"><span class="comment">        value: 4,</span></span><br><span class="line"><span class="comment">        next: null</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波那契</span></span><br><span class="line"><span class="comment">// 递归版本，受限于递归深度，n 较大时，计算时间很长；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n &gt; <span class="number">1</span> ? Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>) : n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进版本 1，使用数组存储中间计算值，避免重复计算；</span></span><br><span class="line"><span class="keyword">let</span> record = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; record.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> record[n];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (record[n] = Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进版本 2，使用对象存储中间计算值，并用闭包封装；</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> caches = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n <span class="keyword">in</span> caches ? caches[n] : (caches[n] = _fib(n - <span class="number">1</span>) + _fib(n - <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _fib(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进版本 3，使用变量存储前两个值，循环计算，速度最快；</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> lastOne = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> lastTwo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">    [lastTwo, lastOne] = [lastOne, lastOne + lastTwo];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lastOne + lastTwo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Rest-参数与-Spread-语法"><a href="#Rest-参数与-Spread-语法" class="headerlink" title="Rest 参数与 Spread 语法"></a>Rest 参数与 Spread 语法</h4><p>在 JavaScript 中，无论函数是如何定义的，你都可以使用任意数量的参数调用函数，未使用的参数会被函数忽略掉；</p>
<p><strong>Rest 参数</strong></p>
<p>Rest 参数可以通过使用三个点 … 并在后面跟着包含剩余参数的数组名称，来将它们包含在函数定义中，这些点的字面意思是“将剩余参数收集到一个数组中”；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个任意个数参数的累加函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumAll</span>(<span class="params">...args</span>) </span>&#123; <span class="comment">// 数组名为 args</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> args) sum += arg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>Rest</code> 参数必须放到参数列表的末尾，因为放在其他参数前面或中间就失去了其意义；</p>
</blockquote>
<p><strong>“arguments” 变量</strong></p>
<p>函数中还有一个名为 arguments 的特殊的类数组对象，该对象按参数索引包含所有参数；arguments 也是可迭代对象；</p>
<blockquote>
<p>Note: 箭头函数没有 <code>arguments</code> 对象；</p>
</blockquote>
<p><strong>Spread 语法</strong></p>
<p>当在函数调用中使用 spread 语法 …arr 时，它会把可迭代对象 arr “展开”到参数列表中；spread 语法也可以与常规值结合使用；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">8</span>, <span class="number">3</span>, -<span class="number">8</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>, ...arr, <span class="number">2</span>, ...arr2, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">let</span> merged = [<span class="number">0</span>, ...arr, <span class="number">2</span>, ...arr2];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转数组</span></span><br><span class="line">[...<span class="string">&quot;hello&quot;</span>]; <span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新对象或数组</span></span><br><span class="line"><span class="keyword">let</span> objCopy = &#123; ...obj &#125;;</span><br><span class="line"><span class="keyword">let</span> arrCopy = [...arr];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: <code>Spread</code> 语法只适用于可迭代对象；而 <code>Array.from</code> 既可以用于类数组对象也可用于可迭代对象，因此，对于转换为数组的任务，<code>Array.from</code> 往往更通用；</p>
</blockquote>
<blockquote>
<p>Tips: <code>Spread</code> 语法可以实现 <code>Object.assign()</code> 一样的浅拷贝效果，且更简介；</p>
</blockquote>
<!-- Object.assign会调用[[Setter]]，Spread语法不会，待验证 -->

<h4 id="变量作用域，闭包"><a href="#变量作用域，闭包" class="headerlink" title="变量作用域，闭包"></a>变量作用域，闭包</h4><p><strong>变量</strong></p>
<p>如果在代码块 {…} 内声明（使用 let 或 const）了一个变量，那么这个变量只在该代码块内可见；该规则也适用于 if，for 和 while 等，以及函数体中；ES6 之前没有块级作用域；</p>
<p>在 JavaScript 中，每个运行的函数，代码块 {…} 以及整个脚本，都有一个被称为词法环境（Lexical Environment） 的内部（隐藏）的关联对象；</p>
<p>其中，词法环境对象由两部分组成：一个存储所有局部变量作为其属性（包括一些其他信息，如 this 的值）的对象，也称为环境记录（Environment Record）；另一个是对外部词法环境的引用，与外部代码相关联；全局词法环境没有外部引用（其引用为 null）；</p>
<blockquote>
<p>Note: “词法环境”是一个规范对象（specification object）：它仅仅是存在于编程语言规范中的“理论上”存在的，用于描述事物如何运作的对象，无法在代码中获取该对象并直接对其进行操作；</p>
</blockquote>
<blockquote>
<p>Note: 一个“变量”只是环境记录这个特殊的内部对象的一个属性；“获取或修改变量”意味着“获取或修改词法环境的一个属性”；</p>
</blockquote>
<blockquote>
<p>Environment Record is an abstract class with three concrete subclasses: declarative Environment Record, object Environment Record, and global Environment Record. Function Environment Records and module Environment Records are subclasses of declarative Environment Record.<br>Every Environment Record has an [[OuterEnv]] field, which is either null or a reference to an outer Environment Record.<br>A var statement declares variables that are scoped to the running execution context’s VariableEnvironment. Within the scope of any VariableEnvironment a common BindingIdentifier may appear in more than one VariableDeclaration but those declarations collectively define only one variable.</p>
</blockquote>
<blockquote>
<p>A function Environment Record is a declarative Environment Record that is used to represent the top-level scope of a function and, if the function is not an ArrowFunction, provides a this binding. [[ThisBindingStatus]] filed value should be lexical, initialized, or uninitialized, If the value is lexical, this is an ArrowFunction and does not have a local this value.</p>
</blockquote>
<blockquote>
<p>The value of the Function component of the running execution context is also called the <code>active function object</code>.</p>
</blockquote>
<blockquote>
<p>The LexicalEnvironment and VariableEnvironment components of an execution context are always Environment Records.</p>
</blockquote>
<p>执行上下文主要包括，Realm、code evaluation state、Function、ScriptOrModule 和词法环境、变量环境（var 关键字声明的变量）、私有环境（包含 class 私有变量）；</p>
<p><strong>函数声明</strong></p>
<p>函数其实也是一个值，就像变量一样，不同之处在于函数声明的初始化会被立即完成（函数声明提升），当创建了一个词法环境时，函数声明会立即变为即用型函数，因此可以在（函数声明）的定义之前调用函数声明；正常来说，这种行为仅适用于函数声明，而不适用于将函数分配给变量的函数表达式；</p>
<p><strong>内部和外部词法环境</strong></p>
<p>当代码要访问一个变量时首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境；这也是内部变量覆盖外部同名变量的原因；</p>
<p>如果在任何地方都找不到这个变量，那么在严格模式下就会报错，在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量；</p>
<p>函数将从内到外依次在对应的词法环境中寻找目标变量，它使用最新的值；旧变量值不会保存在任何地方；当一个函数想要一个变量时，它会从自己的词法环境或外部词法环境中获取当前值；</p>
<p><strong>返回函数</strong></p>
<p>所有的函数在“诞生”时都会记住创建它们的词法环境，从技术上讲，所有函数都有名为 [[Environment]] 的隐藏属性，该属性保存了对创建该函数的词法环境的引用；</p>
<blockquote>
<p>Tips: 函数记住它创建于何处的方式，与函数被在哪儿调用无关；<code>[[Environment]]</code> 引用在函数创建时被设置并永久保存，并且不会改变；只有遇到调用函数时，函数词法环境才会被创建，这也是函数中 this 是动态绑定的原因；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解释阶段</span></span><br><span class="line"><span class="comment">// 1. 脚本开始执行，创建全局执行上下文；</span></span><br><span class="line"><span class="comment">// 2. 创建一个全局词法环境填充所有（let、const、function）声明的变量（未初始化）以及函数；</span></span><br><span class="line"><span class="comment">// 3. 创建一个全局变量环境，填充所有 var 关键字定义的变量，并初始化为 undefined</span></span><br><span class="line"><span class="comment">// 4. 将外部环境置为 null；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line"><span class="comment">// 5. 此时，先定义 counter，值为 undefined；</span></span><br><span class="line"><span class="comment">// 6. 然后执行 makeCounter 后，为 counter 赋值；</span></span><br><span class="line"><span class="keyword">let</span> counter = makeCounter();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 创建新的执行上下文函数，创建函数的词法环境，并存储这个调用的局部变量和参数；</span></span><br><span class="line"><span class="comment">// 8. 同时将外部环境指向全局词法环境；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. 返回时，创建一个嵌套函数，并将嵌套函数的外部词法环境指向 makeCounter；</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 11. 执行 count++ 时，从自身词法环境中查找 count，然后查找 makeCounter 词法环境中的变量，完成修改后返回；</span></span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 执行 counter 函数，创建一个新的词法环境，并从 [[Environment]] 中获取其外部词法环境引用；</span></span><br><span class="line">counter();</span><br></pre></td></tr></table></figure>

<p>闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后；</p>
<blockquote>
<p>Note: 在 JavaScript 中，所有函数都是天生闭包的（除 “new Function” 语法）；也就是说：JavaScript 中的函数会自动通过隐藏的 <code>[[Environment]]</code> 属性记住创建它们的位置，所以它们都可以访问外部变量；</p>
</blockquote>
<p>通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除，但当有一个嵌套函数在外部函数结束后仍可达，则它将具有引用词法环境的 [[Environment]] 属性；因此词法环境仍会被保留在内存；</p>
<p><strong>实践</strong></p>
<blockquote>
<p>Note: 理论上当函数可达时，它外部的所有变量也都将存在；但在实际中，JavaScript 引擎会试图优化它，它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除；</p>
</blockquote>
<blockquote>
<p>Note: 在 <code>V8</code>（Chrome，Edge，Opera）中的一个重要的副作用是，此类变量在调试中将不可用（未定义），或者得到一个同名的外部变量；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// “不存在”的变量和“未初始化”的变量之间的特殊差异</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一个变量从技术的角度来讲是存在的，但是在 let 之前还不能使用，该区域也称死区</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError: Cannot access &#x27;x&#x27; before initialization</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>AO</code> 类似于是函数被调用时创建的一个特殊 <code>VO</code>，它在 <code>VO</code> 的基础上添加了实际调用函数时传入的参数和 <code>arguments</code> 对象，还有添加 <code>this</code> 对象；<code>VO</code> 和 <code>AO</code> 被创建时会先后执行著名的函数声明提升和变量声明提升，提升上来的变量和函数挂载到 <code>VO / AO</code> 对象的上，其实是作为它的属性存在的；</p>
</blockquote>
<blockquote>
<p>Tips: 在调试函数时，<code>Scope</code> 的最上层是 <code>Local</code>，也就是当前执行上下文的变量对象，下面就是函数的<code>[[Scopes]]</code> 属性里保存的父级层级链；点击 <code>Call Stack</code> 栏中的函数，还可以切换当前执行上下文，观察下面 <code>Scope</code> 的变化；</p>
</blockquote>
<blockquote>
<p>Tips: 使用 <code>console.dir</code> 可以打印出函数的 <code>length</code>、<code>name</code>，甚至作用域链 [[Scopes]] 等隐藏属性；严格模式下无法获取 <code>caller</code>，<code>callee</code>，<code>arguments</code> 等属性；</p>
</blockquote>
<ul>
<li><a href="https://zh.javascript.info/closure">JavaScript 现代教程-变量作用域，闭包文档</a></li>
<li><a href="https://juejin.cn/post/6844904050824052744">深入 js——作用域链</a></li>
<li><a href="https://www.zhihu.com/question/51336888">JS 规范中的 Execution Context 和 Scope 概念有什么区别？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/311196297">了解 JS 中的ECStack、EC、VO 和 AO</a></li>
<li><a href="https://juejin.cn/post/6844904145372053511">JS夯实之执行上下文与词法环境</a></li>
<li><a href="https://stackoverflow.com/questions/12599965/lexical-environment-and-function-scope">Lexical environment and function scope</a></li>
<li><a href="https://tc39.es/ecma262/#sec-executable-code-and-execution-contexts">Executable Code and Execution Contexts</a></li>
</ul>
<h4 id="旧时的-var"><a href="#旧时的-var" class="headerlink" title="旧时的 var"></a>旧时的 var</h4><p>在 JavaScript 中，有三种声明变量的方式：let，const（现代方式），var（过去留下来的方式）；</p>
<p><strong>var 没有块级作用域</strong></p>
<p>用 var 声明的变量，不是函数作用域就是全局作用域；它们在代码块外也是可见的也就是说，var 声明的变量只有函数作用域和全局作用域，没有块级作用域；</p>
<p>这就导致 if 语句或循环语句外可以访问在 {…} 中使用 var 定义的变量；var 穿透了 if，for 和其它代码块，这是因为在早期的 JavaScript 中，块没有词法环境，而 var 就是这个时期的代表之一；</p>
<p><strong>var 允许重新声明</strong></p>
<p>使用 var，可以重复声明一个变量，不管多少次都行；如果对一个已经声明的变量使用 var，这条新的声明语句会被忽略：</p>
<p><strong>var 提升变量声明</strong></p>
<p>var 声明的变量会在函数开头被定义，与它在代码中定义的位置无关；声明被提升，但是赋值不会；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// phrase 实际声明处</span></span><br><span class="line"></span><br><span class="line">  alert(phrase); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// phrase 赋值</span></span><br><span class="line">  phrase = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代码块会被忽略，phrase 仍然会被声明</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> phrase;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure>

<p><strong>立即执行函数</strong></p>
<p>在之前，JavaScript 中只有 var 这一种声明变量的方式，并且这种方式声明的变量没有块级作用域，于是就有了一种模仿块级作用域的方法，这种方法被称为“立即调用函数表达式”（immediately-invoked function expressions，IIFE）；</p>
<p>通常需要使用圆括号把该函数表达式包起来，以告诉 JavaScript，这个函数是在另一个表达式的上下文中创建的，因此它是一个函数表达式：它不需要函数名，可以立即调用；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 IIFE 的方法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Parentheses around the function&quot;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Parentheses around the whole thing&quot;</span>);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Bitwise NOT operator starts the expression&quot;</span>);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Unary plus starts the expression&quot;</span>);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">~(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Unary plus starts the expression&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h4><p>全局对象提供可在任何地方使用的变量和函数，且其所有属性都可以被直接访问；默认情况下，这些全局变量内建于语言或环境中；在浏览器中，它的名字是 “window”，对 Node.js 而言，它的名字是 “global”，其它环境可能用的是别的名字；</p>
<blockquote>
<p>Tips: 最近，<code>globalThis</code> 被作为全局对象的标准名称加入到了 JavaScript 中，所有环境都应该支持该名称，所有主流浏览器都支持它；</p>
</blockquote>
<blockquote>
<p>Note: 在浏览器中，使用 <code>var</code> 声明的全局函数和变量会成为全局对象的属性；</p>
</blockquote>
<p>如果一个值非常重要，且需要在全局范围内可用，可以直接将其作为属性写入；但一般不建议使用全局变量，全局变量应尽可能的少；与使用外部变量或全局变量相比，函数获取“输入”变量并产生特定“输出”的代码设计更加清晰，不易出错且更易于测试；</p>
<p>另外，一般还使用全局对象来测试对现代语言功能的支持；对于没有某些现代功能的旧版浏览器，可以创建 “polyfills”：添加环境不支持但在现代标准中存在的功能；</p>
<h4 id="函数对象，NFE"><a href="#函数对象，NFE" class="headerlink" title="函数对象，NFE"></a>函数对象，NFE</h4><p>在 JavaScript 中，函数就是对象，可以把函数理解成可被调用的“行为对象（action object）”；我们不仅可以调用它们，还能把它们当作对象来处理：增/删属性，按引用传递等；</p>
<p><strong>name 属性</strong></p>
<p>一个函数的名字可以通过属性 “name” 来访问；名称赋值的逻辑很智能，即使是函数表达式，被创建时没有名字，名称赋值的逻辑也能给它赋予一个正确的名字，然后进行赋值；</p>
<blockquote>
<p>Note: 规范中把这种特性叫做上下文命名，如果函数自己没有提供，那么在赋值中，会根据上下文来推测一个；但当 JavaScript 引擎无法推测名字时，属性 name 就会是空；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">alert(sayHi.name); <span class="comment">// sayHi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象中的方法也有 name 属性</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">alert(user.sayHi.name); <span class="comment">// sayHi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组中创建的匿名函数没有名称</span></span><br><span class="line"><span class="keyword">let</span> funcArr = [<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引擎无法设置正确的名字，所以没有值</span></span><br><span class="line"><span class="built_in">console</span>.warn(funcArr[<span class="number">0</span>].name); <span class="comment">// &lt;空字符串&gt;</span></span><br><span class="line"><span class="built_in">console</span>.warn(funcArr[<span class="number">1</span>].name); <span class="comment">// func</span></span><br></pre></td></tr></table></figure>

<p><strong>length 属性</strong></p>
<p>length 是函数的另一个内建属性，它返回函数入参的个数；</p>
<blockquote>
<p>Tips: rest 参数不参与计数，属性 length 有时在操作其它函数的函数中用于做内省/运行时检查（introspection）；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据函数参数个数的不同做不同处理，也属于多态的一种</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">...handlers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> handler <span class="keyword">of</span> handlers) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(handler.length); <span class="comment">// 1 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handler(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="function">(<span class="params">param</span>) =&gt;</span> param, <span class="function">(<span class="params">...rest</span>) =&gt;</span> rest);</span><br></pre></td></tr></table></figure>

<p><strong>自定义属性</strong></p>
<p>在函数内可以使用函数名为函数添加自定义的属性；可以函数当作对象，在函数里存储属性，这对函数的执行没有任何影响；但变量不是函数属性，反之亦然；</p>
<blockquote>
<p>Tips: 函数属性有时会用来替代闭包；区别在于，闭包的属性外部无法访问；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counter.count++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  counter.count = <span class="number">0</span>;</span><br><span class="line">  counter.set = <span class="function"><span class="params">value</span> =&gt;</span> count = value;</span><br><span class="line">  counter.decrease = <span class="function">() =&gt;</span> count--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = makeCounter();</span><br><span class="line">alert( counter() ); <span class="comment">// 0</span></span><br><span class="line">alert( counter() ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>命名函数表达式</strong></p>
<p>命名函数表达式（NFE，Named Function Expression），指带有名字的函数表达式的术语；但它仍是一个函数表达式，不会成为一个函数声明；NFE 在函数内部可以应用自己，且该函数名在函数外部不可见；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (who) &#123;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    func(<span class="string">&quot;Guest&quot;</span>); <span class="comment">// 使用 func 再次调用函数自身</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sayHi(); <span class="comment">// Hello, Guest</span></span><br><span class="line">func(); <span class="comment">// Error, func is not defined（在函数外不可见）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>jQuery，lodash 等很多 JavaScript 库都充分利用了这个功能，实际上，这么做是为了减少对全局空间的污染，这样一个库就只会有一个全局变量，也降低了命名冲突的可能性；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任意数量的括号求和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  sum.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _add.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.count;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_add</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    sum.count += p;</span><br><span class="line">    <span class="keyword">return</span> _add;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _add(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 升级版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function">(<span class="params">b</span>) =&gt;</span> sum(a + b);</span><br><span class="line">  next.valueOf = <span class="function">() =&gt;</span> a;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="new-Function-语法"><a href="#new-Function-语法" class="headerlink" title="new Function 语法"></a>new Function 语法</h4><p>还有一种很少见的函数创建方法；使用 Function 创建函数：<code>new Function ([arg1, arg2, ...argN], functionBody);</code>，由于历史原因，参数也可以按逗号分隔符的形式给出，这种方法实际上是通过运行时通过参数传递过来的字符串创建的；</p>
<p>另外，如果使用 new Function 创建一个函数，那么该函数的 [[Environment]] 并不指向当前的词法环境，而是指向全局环境；</p>
<h4 id="调度：setTimeout-和-setInterval"><a href="#调度：setTimeout-和-setInterval" class="headerlink" title="调度：setTimeout 和 setInterval"></a>调度：setTimeout 和 setInterval</h4><blockquote>
<p>Note: 这两个方法并不在 JavaScript 的规范中，但是大多数运行环境都有内建的调度程序，并且提供了这些方法；目前来讲，所有浏览器以及 Node.js 都支持这两个方法；</p>
</blockquote>
<p><strong>setTimeout</strong></p>
<p>setTimeout 允许我们将函数推迟到一段时间间隔之后再执行；<code>let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)</code>，setTimeout 在调用时会返回一个“定时器标识符（timer identifier）”，可以将它传入 clearTimeout 方法来取消执行；</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">func|code</td>
<td align="left">要执行的函数或代码字符串，一般传入的都是函数；由于历史原因，支持传入代码字符串</td>
</tr>
<tr>
<td align="left">delay</td>
<td align="left">执行前的延时，以毫秒为单位，默认值是 0</td>
</tr>
<tr>
<td align="left">arg1，arg2…</td>
<td align="left">要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">phrase, who</span>) </span>&#123;</span><br><span class="line">  alert( phrase + <span class="string">&#x27;, &#x27;</span> + who );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(sayHi, <span class="number">1000</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;John&quot;</span>); <span class="comment">// Hello, John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果第一个参数位传入的是字符串，JavaScript 会自动为其创建一个函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>, <span class="number">1000</span>); <span class="comment">// 不建议使用，可用箭头函数代替</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定时器</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timerId);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 在浏览器中，定时器标识符是一个数字；在 <code>Node.js</code> 中返回的是一个定时器对象，这个对象包含一系列方法；</p>
</blockquote>
<blockquote>
<p>Tips: <code>setTimeout</code> 有一个特殊用法：<code>setTimeout(func, 0)</code>，或者仅仅是 <code>setTimeout(func)</code>；这样调度可以让 <code>func</code> 尽快执行，该函数被调度在当前脚本执行完成“之后”立即执行；</p>
</blockquote>
<blockquote>
<p>Note: 浏览器环境下，零延时实际上不为零，嵌套定时器的运行频率是受限制的；根据 HTML5 标准 所讲：“经过 <code>5</code> 重嵌套定时器之后，时间间隔被强制设定为至少 <code>4</code> 毫秒”；</p>
</blockquote>
<p><strong>setInterval</strong></p>
<p>setInterval 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数；该方法与 setTimeout 用法相同，所有参数的意义也相同；使用 clearInterval(timerId) 方法清除；</p>
<blockquote>
<p>Note: 在大多数浏览器中，包括 Chrome 和 Firefox，在显示 <code>alert/confirm/prompt</code> 弹窗时，内部的定时器仍旧会继续“嘀嗒”；因此如果未及时关闭弹窗，可能会出现关闭弹窗后立即弹出新的弹窗；</p>
</blockquote>
<p>使用 setInterval 时，函数的实际调用间隔要比代码中设定的时间间隔要短；极端情况下，如果函数执行时间远大于预设时间间隔段时，JavaScript 引擎会等待函数执行完成，然后检查调度程序之后，立即再次执行函数；</p>
<blockquote>
<p>Tips: 相较而言，嵌套的 <code>setTimeout</code> 能够精确地设置两次执行之间的延时，而 <code>setInterval</code> 却不能；并且嵌套的 <code>setTimeout</code> 要比 <code>setInterval</code> 灵活得多；采用这种方式可以根据当前执行结果来调度下一次调用，因此下一次调用可以与当前这一次不同；</p>
</blockquote>
<blockquote>
<p>Tips: 当一个函数传入 <code>setInterval/setTimeout</code> 时，将为其创建一个内部引用，并保存在调度程序中；这样，即使这个函数没有其他引用，也能防止垃圾回收器（GC）将其回收；同时该函数引用的外部变量也会被保留，因此，当我们不再需要调度函数时，最好取消它，即使这是个（占用内存）很小的函数；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任何 setTimeout 都只会在当前代码执行完毕之后才会执行</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> alert(i), <span class="number">100</span>); <span class="comment">// 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这段代码的运行时间 &gt;100ms</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">100000000</span>; j++) &#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>setTimeout()</code> 和 <code>setInterval()</code> 共用一个编号池，技术上，<code>clearTimeout()</code> 和 <code>clearInterval()</code> 可以互换；但是，为了避免混淆，不要混用取消定时函数；</p>
</blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout">window.setTimeout MDN 中文参考文档</a></li>
</ul>
<h4 id="装饰器模式和转发，call-apply"><a href="#装饰器模式和转发，call-apply" class="headerlink" title="装饰器模式和转发，call/apply"></a>装饰器模式和转发，call/apply</h4><p><strong>装饰器</strong></p>
<p>装饰器（decorator）：一个特殊的函数，可以被看作是可以添加到函数的 “features” 或 “aspects”，可以添加一个或添加多个装饰器；装饰器是可重用的，逻辑独立的；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里可能会有重负载的 CPU 密集型工作</span></span><br><span class="line">  alert(<span class="string">`Called with <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.has(x)) &#123;    <span class="comment">// 如果缓存中有对应的结果</span></span><br><span class="line">      <span class="keyword">return</span> cache.get(x); <span class="comment">// 从缓存中读取结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let result = func(x);</span></span><br><span class="line">    <span class="keyword">let</span> result = func.call(<span class="built_in">this</span>, x);  <span class="comment">// 否则就调用 func</span></span><br><span class="line"></span><br><span class="line">    cache.set(x, result);  <span class="comment">// 然后将结果缓存（记住）下来</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newSlow = cachingDecorator(slow);</span><br></pre></td></tr></table></figure>

<p>特殊的内建函数方法 func.call(context, arg1, arg2, …)，它允许调用一个显式设置 this 的函数；另一个内建方法 func.apply(context, args)，它与 func.call 区别在第二个参数使用类数组对象 args 作为参数列表（arguments）；</p>
<blockquote>
<p>Note: <code>func.call</code> 在 <code>func</code> 函数运行时使用的 <code>this</code> 值可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 <code>null</code> 或 <code>undefined</code>（缺省时） 时会自动替换为指向全局对象，原始值会被包装；</p>
</blockquote>
<blockquote>
<p>Note: <code>Spread</code> 语法 <code>...</code> 允许将可迭代对象 <code>args</code> 作为列表传递给 <code>func.call</code>，而 <code>func.apply</code> 只接受类数组 <code>args</code>；</p>
</blockquote>
<blockquote>
<p>Tips: 即可迭代又是类数组的对象，使用 call 或 apply 均可，但是 apply 可能会更快，因为大多数 JavaScript 引擎在内部对其进行了优化；</p>
</blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">Function.prototype.call MDN 中文参考文档</a></li>
</ul>
<p><strong>呼叫转移</strong></p>
<p>将所有参数连同上下文一起传递给另一个函数被称为“呼叫转移（call forwarding）”；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个呼叫转移的最简单形式</span></span><br><span class="line"><span class="keyword">let</span> wrapper = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方法借用</strong></p>
<p>方法借用（method borrowing）：从一个对象中获取一个方法，并在另一个对象的上下文中“调用”它；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( [].join.call(<span class="built_in">arguments</span>) ); <span class="comment">// 1,2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hash(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 采用数组方法并将它们应用于参数 <code>arguments</code> 是很常见的，另一种方法是使用 Rest 参数对象，该对象是一个真正的数组；</p>
</blockquote>
<p><strong>防抖和节流</strong></p>
<p>debounce 会在“冷却（cooldown）”期后运行函数一次，适用于处理最终结果；throttle 运行函数的频率不会大于所给定的时间 ms 毫秒，适用于不应该经常进行的定期更新；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防抖装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 刷新计时器</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>), ms);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="keyword">return</span>; <span class="comment">// 忽略执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h4><p>浏览器中的 setTimeout 方法有些特殊：它为函数调用设定了 this=window（对于 Node.js，this 则会变为计时器（timer）对象；即使是在严格模式下，setTimeout() 的回调函数里面的 this 仍然默认指向 window 对象，并不是 undefined；</p>
<p>函数提供了一个内建方法 bind，可以绑定 this；func.bind(context) 的结果是一个特殊的类似于函数的“外来对象（exotic object）”，它可以像函数一样被调用，并且透明地（transparently）将调用传递给 func 并设定 this=context；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在没有对象（译注：与对象分离）的情况下运行它</span></span><br><span class="line">sayHi(); <span class="comment">// Hello, John!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还是会使用预先绑定（pre-bound）的值，该值是对旧的 user 对象的引用</span></span><br><span class="line"><span class="built_in">setTimeout</span>(user.sayHi.bind(user), <span class="number">1000</span>); <span class="comment">// Hello, John!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用了最新的 sayHi 方法；</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> user.sayHi(), <span class="number">1000</span>); <span class="comment">// Another user in setTimeout!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user 的值在不到 1 秒内发生了改变</span></span><br><span class="line">user = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; alert(<span class="string">&quot;Another user in setTimeout!&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 如果一个对象有很多方法，并且我们都打算将它们都传递出去，那么我们可以在一个循环中完成所有方法的绑定；或者也可以使用 lodash 中的 <code>_.bindAll(object, methodNames)</code> 方法；</p>
</blockquote>
<p>此外，func.bind(context, [arg1], [arg2], …) 不仅可以绑定 this，还可以绑定参数（arguments）；可以通过绑定先有函数的一些参数来创建一个新函数，被称为偏函数应用程序（partial function application）；</p>
<p>使用偏函数可以创建一个具有可读性高的名字（double，triple）的独立函数；另一方面，当我们有一个非常通用的函数，并希望有一个通用型更低的该函数的变体时，偏函数会非常有用；lodash 库有现成的 _.partial 实现；</p>
<blockquote>
<p>Note: 绑定函数的上下文是硬绑定（hard-fixed）的，无法再修改它；因此被绑定函数内部的 this 指向，或者对象的属性值会被固定，即会使用预先绑定（pre-bound）的值；</p>
</blockquote>
<blockquote>
<p>Note: 一个函数不能被重绑定（re-bound），二次绑定的值无效；在非严格模式下，ES5 标准会将值为 <code>null</code> 或 <code>undefined</code> 的 <code>this</code> 绑定到全局对象，也就是 <code>this=window</code>；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个偏函数的例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> double = mul.bind(<span class="literal">null</span>, <span class="number">2</span>); <span class="comment">// 第一个参数必填</span></span><br><span class="line">double(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏函数装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">func, ...argsBound</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用时，获取当前 this，即不关心绑定对象；</span></span><br><span class="line">    <span class="keyword">return</span> func.call(<span class="built_in">this</span>, ...argsBound, ...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = f.bind( &#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125; ).bind( &#123;<span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125; );</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<h4 id="深入理解箭头函数"><a href="#深入理解箭头函数" class="headerlink" title="深入理解箭头函数"></a>深入理解箭头函数</h4><p>箭头函数是针对那些没有自己的“上下文”，但在当前上下文中起作用的短代码的；箭头函数具有以下特点：</p>
<ul>
<li>没有 this；</li>
<li>没有 arguments；</li>
<li>不能使用 new 进行调用；</li>
<li>也没有 super；</li>
</ul>
<blockquote>
<p>Note: 箭头函数不具有 <code>this</code> 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor），因此不能用 <code>new</code> 调用它们；</p>
</blockquote>
<blockquote>
<p>Note: 箭头函数 <code>=&gt;</code> 没有创建任何绑定，箭头函数只是没有 <code>this</code>；<code>this</code> 的查找与常规变量的搜索方式完全相同：在外部词法环境中查找；ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数；箭头函数内部的 this 会指向声明箭头函数时所在作用域的 this；</p>
</blockquote>
<blockquote>
<p>Note: In modules, like <code>&lt;script type=&quot;module&quot;&gt;</code> or <code>node</code>, the value of <code>this</code> is always <code>undefined</code> in the global context. Modules are implicitly in <code>strict mode</code>.</p>
</blockquote>
<p><strong>this 绑定</strong></p>
<p>在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定），this 不能在执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同；在不同情况下，this 值的表现有所不同；</p>
<blockquote>
<p>A regular declarative Environment Record (i.e., one that is neither a function Environment Record nor a module Environment Record) does not provide a this binding.<br>Function Environment Records if envRec.[[ThisBindingStatus]] is not lexical, then Return envRec.[[ThisValue]].<br>Object Environment Records do not provide a this binding.<br>Module Environment Records always provide a this binding.<br>Global Environment Record Return envRec.[[GlobalThisValue]].</p>
</blockquote>
<p>规范环境记录中的 this：</p>
<ol>
<li>全局环境记录，返回 envRec.[[GlobalThisValue]]；</li>
<li>对象环境记录，没有 this；</li>
<li>声明环境记录，<ul>
<li>常规声明环境记录，没有 this；</li>
<li>函数环境记录，非箭头函数返回 envRec.[[ThisValue]]；</li>
<li>模块环境记录，返回 undefined；</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">环境</th>
<th align="left">非严格模式</th>
<th align="left">严格模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">全局上下文</td>
<td align="left">全局对象</td>
<td align="left">全局对象</td>
</tr>
<tr>
<td align="left">函数上下文</td>
<td align="left">全局对象</td>
<td align="left">undefined</td>
</tr>
<tr>
<td align="left">对象上下文</td>
<td align="left">调用的对象</td>
<td align="left">调用的对象</td>
</tr>
<tr>
<td align="left">模块上下文</td>
<td align="left">自动开启严格模式</td>
<td align="left">在浏览器端 ES6 模块（<code>&lt;script type=&quot;module&quot;&gt;</code>）中为 undefined，在 Node CommonJS 模块中为当前模块</td>
</tr>
<tr>
<td align="left">bind, call, apply</td>
<td align="left">传入的 thisArg，非对象 thisArg 会被转为对象</td>
<td align="left">传入的 thisArg，不会进行对象转换</td>
</tr>
<tr>
<td align="left">箭头函数</td>
<td align="left">从创建的执行上下文获取，顶级为全局变量</td>
<td align="left">从创建的执行上下文获取，顶级为 undefined</td>
</tr>
<tr>
<td align="left">eval</td>
<td align="left">直接调用同箭头函数；间接调用为全局对象</td>
<td align="left">直接调用同箭头函数，间接调用为全局对象</td>
</tr>
<tr>
<td align="left">setTimeout, setInterval</td>
<td align="left">将普通函数的 this 绑定为 window 或 Timeout 对象</td>
<td align="left">同非严格模式</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局环境中</span></span><br><span class="line"><span class="comment">// 无论是否在严格模式下，在任何函数体外部的 this 都指向全局对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === globalThis); <span class="comment">// true</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;<span class="built_in">console</span>.log(<span class="built_in">this</span> === globalThis); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数环境中，this 的值取决于函数被调用的方式</span></span><br><span class="line"><span class="comment">// 1. 直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window / global</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;<span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"><span class="comment">// 2. 作为对象方法调用，无关严格模式与否</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.say(); <span class="comment">// user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数绑定和转移 bind, call, apply</span></span><br><span class="line"><span class="comment">// 如果 thisArg 不是对象，则会被尝试转换为对象；null 和 undefined 被转换为全局对象；</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span> &#125;;</span><br><span class="line">user.say.bind()(); <span class="comment">// window / global</span></span><br><span class="line">user.say.bind(<span class="literal">null</span>)(); <span class="comment">// window / global</span></span><br><span class="line">user.say.bind(<span class="string">&quot;str&quot;</span>)(); <span class="comment">// String &#123;&#x27;str&#x27;&#125; / [String: &#x27;str&#x27;]</span></span><br><span class="line">user.say.bind(obj); <span class="comment">// &#123; name: &quot;obj&quot; &#125;</span></span><br><span class="line">user.say.call(); <span class="comment">// window / global</span></span><br><span class="line">user.say.call(<span class="literal">null</span>); <span class="comment">// window / global</span></span><br><span class="line">user.say.call(<span class="number">1234</span>); <span class="comment">// Number &#123;1234&#125; / [Number: 1234]</span></span><br><span class="line">user.say.call(obj); <span class="comment">// &#123; name: &quot;obj&quot; &#125;</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">user.say.bind()(); <span class="comment">// undefined</span></span><br><span class="line">user.say.bind(<span class="literal">null</span>)(); <span class="comment">// null</span></span><br><span class="line">user.say.bind(<span class="string">&quot;str&quot;</span>)(); <span class="comment">// str</span></span><br><span class="line">user.say.bind(obj); <span class="comment">// &#123; name: &quot;obj&quot; &#125;</span></span><br><span class="line">user.say.call(); <span class="comment">// undefined</span></span><br><span class="line">user.say.call(<span class="literal">null</span>); <span class="comment">// null</span></span><br><span class="line">user.say.call(<span class="number">1234</span>); <span class="comment">// 1234</span></span><br><span class="line">user.say.call(obj); <span class="comment">// &#123; name: &quot;obj&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数中</span></span><br><span class="line"><span class="comment">// this 与封闭词法环境的 this 保持一致；在全局代码中，它将被设置为全局对象；</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;</span><br><span class="line"><span class="comment">// return by function</span></span><br><span class="line"><span class="keyword">let</span> returnFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// inside function</span></span><br><span class="line"><span class="keyword">let</span> outerFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _f = <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;;</span><br><span class="line">  _f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// inside object</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  myFun: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCls</span></span>&#123;</span><br><span class="line">  arrow = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span> === MyCls, <span class="built_in">this</span> <span class="keyword">instanceof</span> MyCls)</span><br><span class="line">  <span class="keyword">static</span> staticArrow = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span> === MyCls, <span class="built_in">this</span> <span class="keyword">instanceof</span> MyCls)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// window / global</span></span><br><span class="line">returnFunc()(); <span class="comment">// window / global</span></span><br><span class="line">outerFunc(); <span class="comment">// window / global</span></span><br><span class="line">obj.myFun(); <span class="comment">// window / global</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">fn(); <span class="comment">// window / global</span></span><br><span class="line">returnFunc()(); <span class="comment">// undefined</span></span><br><span class="line">outerFunc(); <span class="comment">// undefined</span></span><br><span class="line">obj.myFun(); <span class="comment">// window / global</span></span><br><span class="line"><span class="comment">// class auto use strict mode</span></span><br><span class="line"><span class="keyword">new</span> MyCls().arrow(); <span class="comment">// false true (instance)</span></span><br><span class="line">MyCls.staticArrow(); <span class="comment">// true false (MyCls)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eval</span></span><br><span class="line"><span class="comment">// 1. 直接调用，eval 代码段中的 this 取决于当前执行上下文</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line">(<span class="built_in">eval</span>)(<span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;!(() =&gt; &#123;console.log(this)&#125;)()&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;!function() &#123;console.log(this)&#125;()&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evalOuter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&quot;console.log(this)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">evalOuter(); <span class="comment">// window / global</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  evalOuter,</span><br><span class="line">&#125;;</span><br><span class="line">obj.evalOuter(); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 其余例子结果相同，略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evalOuter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&quot;console.log(this)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">evalOuter(); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  evalOuter,</span><br><span class="line">&#125;;</span><br><span class="line">obj.evalOuter(); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 间接调用，eval 代码段中的 this 指向全局执行上下文，严格模式同</span></span><br><span class="line"><span class="built_in">eval</span>?.(<span class="string">&quot;console.log(this)&quot;</span>) <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">window</span>.eval(<span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// window</span></span><br><span class="line"><span class="built_in">global</span>.eval(<span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// global</span></span><br><span class="line"><span class="built_in">eval</span>.call(<span class="literal">null</span>, <span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">eval</span>.bind(<span class="literal">null</span>, <span class="string">&quot;console.log(this)&quot;</span>)(); <span class="comment">// window / global</span></span><br><span class="line"><span class="keyword">let</span> originalEval = <span class="function">(<span class="params">code</span>) =&gt;</span> <span class="built_in">eval</span>(code);</span><br><span class="line">originalEval(<span class="string">&quot;console.log(this)&quot;</span>); <span class="comment">// window / global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout, setInterval</span></span><br><span class="line"><span class="comment">// 将传入的普通函数 this 设为全局对象，对箭头函数或 bind 生成的函数无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arrowFunc = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  arrowFunc : <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(func, <span class="number">100</span>); <span class="comment">// window / Timeout</span></span><br><span class="line"><span class="built_in">setTimeout</span>(arrowFunc, <span class="number">100</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.func, <span class="number">100</span>); <span class="comment">// window / Timeout</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.arrowFunc, <span class="number">100</span>); <span class="comment">// window / global</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;func(); obj.func()&#125;, <span class="number">100</span>); <span class="comment">// window + obj / global</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;arrowFunc(); obj.arrowFunc();&#125;, <span class="number">100</span>); <span class="comment">// window + window / global + global</span></span><br><span class="line"><span class="built_in">setTimeout</span>(func.bind(<span class="literal">null</span>), <span class="number">100</span>); <span class="comment">// window + window / global + global</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;func(); obj.func()&#125;, <span class="number">100</span>); <span class="comment">// undefined + obj / undefined + obj</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;arrowFunc(); obj.arrowFunc();&#125;, <span class="number">100</span>); <span class="comment">// window + window / global + global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用丢失</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">refFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="function">(<span class="params">f</span>) =&gt;</span> f();</span><br><span class="line"><span class="keyword">const</span> h = obj.refFunc;</span><br><span class="line"><span class="keyword">const</span> j = <span class="function">() =&gt;</span> obj.refFunc;</span><br><span class="line">g(obj.refFunc); <span class="comment">// No base ref.</span></span><br><span class="line">h(); <span class="comment">// No base ref.</span></span><br><span class="line">j()(); <span class="comment">// No base ref.</span></span><br><span class="line">(<span class="number">0</span>, obj.refFunc)(); <span class="comment">// Another common pattern to remove the base ref.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/57204184">ES6 箭头函数的 this 指向详解</a></li>
<li><a href="https://www.jianshu.com/p/59be0fc4f4a6">箭头函数和 this 指向</a></li>
<li><a href="https://cnblogs.com/jeodeng/p/10658590.html">浅谈箭头函数和 setTimeout 中的 this</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html">JavaScript 的 this 原理</a></li>
<li><a href="https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work?rq=1">How does the “this” keyword work?</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">this MDN 中文参考文档</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval">eval() MDN 中文参考文档</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout">window.setTimeout MDN 中文参考文档</a></li>
</ul>
<h4 id="属性标志和属性描述符"><a href="#属性标志和属性描述符" class="headerlink" title="属性标志和属性描述符"></a>属性标志和属性描述符</h4><p>对象属性（properties），除 value 外，还有三个特殊的特性（attributes），也就是所谓的“标志”；默认都为 true；</p>
<ul>
<li>writable 表示是否值可以被修改；</li>
<li>enumerable 表示是否会被在循环中列出；</li>
<li>configurable 表示是否此特性可以被删除，这些属性也可以被修改；</li>
</ul>
<p><strong>writable</strong></p>
<p>通过更改 writable 标志来把对象属性设置为只读，不能被重新赋值；</p>
<blockquote>
<p>Note: 在非严格模式下，在对不可写的属性等进行写入操作时，不会出现错误，但是操作仍然不会成功；因为在非严格模式下，违反标志的行为（flag-violating action）只会被默默地忽略掉；</p>
</blockquote>
<p><strong>enumerable</strong></p>
<p>通过更改 enumerable 标志来把对象属性设置为不可枚举，不会显示在 for..in 中；也会被 Object.keys 排除；</p>
<p><strong>configurable</strong></p>
<p>通过设置 configurable 标志把对象属性标志设置为不能被删除（delete），它的特性（attribute）不能被修改；</p>
<p>configurable: false 防止更改和删除属性标志，但是允许更改对象的值，不可配置标志（configurable:false）有时会预设在内建对象和属性中；</p>
<blockquote>
<p>Note: 对于不可配置的属性，我们可以将 <code>writable: true</code> 更改为  <code>false</code>，从而防止其值被修改（以添加另一层保护），但无法反向行之；</p>
</blockquote>
<p><strong>Object.getOwnPropertyDescriptor / Object.getOwnPropertyDescriptors</strong></p>
<p>可以通过 Object.getOwnPropertyDescriptor(obj, propertyName) 方法获取，返回一个“属性描述符”对象：包含值和所有的标志；</p>
<p>或者可以使用 Object.getOwnPropertyDescriptors(obj) 方法一次获取对象所有包含 symbol 类型的和不可枚举的属性在内的属性描述符；</p>
<p><strong>Object.defineProperty / Object.defineProperties</strong></p>
<p>可以使用 Object.defineProperty(obj, propertyName, descriptor) 方法修改标志；如果该属性存在，defineProperty 会更新其标志，否则它会使用给定的值和标志创建属性；在这种情况下，如果没有提供标志，则会假定它是 false；</p>
<p>或者使用 Object.defineProperties(obj, descriptors) 方法同时定义多个属性；</p>
<blockquote>
<p>Tips: 克隆对象的“标志感知”方式，但无法克隆原型链：<code>let clone = Object.defineProperties(&#123;&#125;, Object.getOwnPropertyDescriptors(obj))</code>，</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;Coley48&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规方式定义的属性，标志默认全为 true</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(user, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;value: &#x27;Coley48&#x27;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改旧属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&quot;toString&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// 只更新 enumerable 标志</span></span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过不可枚举的属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) <span class="built_in">console</span>.warn(key); <span class="comment">// name</span></span><br><span class="line"><span class="built_in">Object</span>.keys(user); <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义新属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&quot;important&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// value 默认 undefined</span></span><br><span class="line">  <span class="comment">// enumerable 未显式给出，默认为 false</span></span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改不可配置属性 Cannot redefine property: important</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&quot;important&quot;</span>, &#123;</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取全部属性的标志对象</span></span><br><span class="line"><span class="keyword">let</span> descriptors = <span class="built_in">Object</span>.getOwnPropertyDescriptors(user);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptors);</span><br></pre></td></tr></table></figure>

<p><strong>全局封闭对象</strong></p>
<p>属性描述符在单个属性的级别上工作，以下方法可以限制整个对象访问，但在实际开发中较少用到；</p>
<ul>
<li>Object.preventExtensions(obj) 禁止向对象添加新属性</li>
<li>Object.seal(obj) 禁止添加/删除属性；为所有现有的属性设置 configurable: false；</li>
<li>Object.freeze(obj) 禁止添加/删除/更改属性；为所有现有的属性设置 configurable: false, writable: false；</li>
<li>Object.isExtensible(obj) 如果添加属性被禁止，则返回 false，否则返回 true；</li>
<li>Object.isSealed(obj) 如果添加/删除属性被禁止，并且所有现有的属性都具有 configurable: false则返回 true；</li>
<li>Object.isFrozen(obj) 如果添加/删除/更改属性被禁止，并且所有当前属性都是 configurable: false, writable: false，则返回 true；</li>
</ul>
<h4 id="属性的-getter-和-setter"><a href="#属性的-getter-和-setter" class="headerlink" title="属性的 getter 和 setter"></a>属性的 getter 和 setter</h4><p>对象属性分为两种，一种是数据属性，另一种是访问器属性（accessor properties）；本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性；</p>
<p><strong>getter 和 setter</strong></p>
<p>访问器属性由 “getter” 和 “setter” 方法表示，在对象字面量中，它们用 get 和 set 表示；</p>
<p>从外表看，访问器属性看起来就像一个普通属性，这就是访问器属性的设计思想；不以函数的方式调用 getter / setter 属性，当读取 / 设置属性时，getter / setter 会在幕后运行；</p>
<blockquote>
<p>Getters 给你一种方法来定义一个对象的属性，但是在访问它们之前不会计算属性的值。 getter 延迟计算值的成本，直到需要此值，如果不需要，您就不用支付成本；</p>
</blockquote>
<blockquote>
<p>一种额外的优化技术是用智能(或称记忆化)getters 延迟属性值的计算并将其缓存以备以后访问。该值是在第一次调用getter 时计算的，然后被缓存，因此后续访问返回缓存值而不重新计算它。这在以下情况下很有用：</p>
</blockquote>
<p><strong>访问器描述符</strong></p>
<p>访问器属性的描述符与数据属性的不同，没有 value 和 writable，但是有 get 和 set 函数；</p>
<ul>
<li>get 一个没有参数的函数，在读取属性时工作；</li>
<li>set 带有一个参数的函数，当属性被设置时调用；</li>
<li>enumerable 与数据属性的相同；</li>
<li>configurable 与数据属性的相同；</li>
</ul>
<blockquote>
<p>Note: 一个属性要么是访问器（具有 <code>get/set</code> 方法），要么是数据属性（具有 <code>value</code>），但不能两者都是；如果试图在同一个描述符中同时提供 <code>get</code> 和 <code>value</code>，则会出现错误；</p>
</blockquote>
<p>访问器的一大用途是，它们允许随时通过使用 getter 和 setter 替换“正常的”数据属性，来控制和调整这些属性的行为；例如为旧代码添加一个 getter 以实现兼容；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  _name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">      alert(<span class="string">&quot;Name is too short, need at least 4 characters&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> user) alert(key); <span class="comment">// _name</span></span><br><span class="line"></span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br><span class="line">user.name = <span class="string">&quot;&quot;</span>; <span class="comment">// alert ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get">getter MDN 中文参考文档</a></li>
</ul>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><p>在 JavaScript 中，对象有一个特殊的隐藏属性 [[Prototype]]（如规范中所命名的），它要么为 null，要么就是对另一个对象的引用，该对象被称为“原型”；</p>
<p>当从 object 中读取一个缺失的属性时，JavaScript 会自动从原型中获取该属性；在编程中，这被称为“原型继承”（Prototypal inheritance）；</p>
<p>原型链有两个限制：一是引用不能形成闭环，否则 JavaScript 会抛出错误；另一个是忽略对象类型，null 之外的其他类型；</p>
<blockquote>
<p>Note: <code>__proto__</code> 是 <code>[[Prototype]]</code> 因历史原因保留下来的 <code>getter / setter</code>；虽然已经过时，但实际上，包括服务端在内的所有环境都支持它，因此使用它是非常安全的；现代编程语言建议应该使用函数 <code>Object.getPrototypeOf/Object.setPrototypeOf</code> 来取代 <code>__proto__</code> 去 <code>get/set</code> 原型；</p>
</blockquote>
<p>原型仅用于读取属性，对于写入/删除操作可以直接在对象上进行；访问器（accessor）属性有点特殊，因为分配（assignment）操作是由 setter 函数处理的；因此，写入此类属性实际上与调用函数相同；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  surname: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    [<span class="built_in">this</span>.name, <span class="built_in">this</span>.surname] = value.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  __proto__: user,</span><br><span class="line">  isAdmin: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(admin.fullName); <span class="comment">// John Smith (*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setter triggers!</span></span><br><span class="line"><span class="comment">// admin.fullName = &quot;Alice Cooper&quot;; // (**)</span></span><br><span class="line">admin.name = <span class="string">&quot;Coley48&quot;</span>;</span><br><span class="line"></span><br><span class="line">alert(admin.fullName); <span class="comment">// Coley48 Cooper，admin 的内容被修改了</span></span><br><span class="line">alert(user.fullName);  <span class="comment">// John Smith，user 的内容被保护了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for..in</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> admin) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// isAdmin, surname, name, fullName</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 过滤继承属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(admin, key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(key); <span class="comment">// isAdmin, name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.keys 只返回自己的 key</span></span><br><span class="line">alert(<span class="built_in">Object</span>.keys(admin)); <span class="comment">// [&#x27;isAdmin&#x27;, &#x27;name&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> admin.fullName <span class="comment">// 无效，无法通过 admin 删除原型中的属性</span></span><br><span class="line"><span class="keyword">delete</span> user.fullName <span class="comment">// user，admin 中 fullName 均被删除</span></span><br></pre></td></tr></table></figure>

<p>无论在一个对象还是在原型中获取到的方法；在一个方法调用中，this 始终是点符号 . 前面的对象；因此可以实现不同对象共享方法，并且私有状态；</p>
<blockquote>
<p>Tips: <code>obj.hasOwnProperty(key)</code> 方法可以判断 <code>key</code> 是否是 <code>obj</code> 具有自己的（非继承的）属性；一般使用转发调用方式 <code>Object.hasOwnProperty.call(obj, key)</code>；</p>
</blockquote>
<blockquote>
<p>Note: <code>for..in</code> 循环也会迭代继承的属性；而几乎所有键/值获取方法，例如 <code>Object.keys</code> 和 <code>Object.values</code> 等，都会忽略继承的属性；它们只会对对象自身进行操作，不考虑继承自原型的属性；</p>
</blockquote>
<blockquote>
<p>在现代引擎中，从性能的角度来看，从对象还是从原型链获取属性都是没区别的；引擎会记住在哪里找到的该属性，并在下一次请求中重用它；并且一旦有内容更改，它们就会自动更新内部缓存；</p>
</blockquote>
<h4 id="F-prototype"><a href="#F-prototype" class="headerlink" title="F.prototype"></a>F.prototype</h4><p>如果 F.prototype 是一个对象或者 null（赋以其他值会被忽略），那么 new 操作符会使用它为新对象设置 [[Prototype]]；</p>
<blockquote>
<p>Note: 如果在创建之后，F.prototype 属性有了变化（F.prototype = <another object>），那么通过 new F 创建的新对象也将随之拥有新的对象作为 [[Prototype]]，但已经存在的对象将保持旧有的值；</p>
</blockquote>
<p>每个函数都有 prototype 属性，即使我们没有提供它；默认的 prototype 是一个只有属性 constructor 的对象，属性 constructor 指向函数自身；可以使用 constructor 属性来创建一个新对象，该对象使用与现有对象相同的构造器；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造器指向自身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">F.prototype <span class="comment">// &#123;constructor: ƒ&#125;</span></span><br><span class="line">F.prototype.constructor === F <span class="comment">// true</span></span><br><span class="line">F.prototype.constructor.name <span class="comment">// F</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> F();</span><br><span class="line"><span class="keyword">let</span> ff = <span class="keyword">new</span> f.constructor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对原型相关操作的结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Rabbit.prototype = &#123;</span><br><span class="line">  eats: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用了上面的 prototype</span></span><br><span class="line"><span class="keyword">let</span> rabbit1 = <span class="keyword">new</span> Rabbit();</span><br><span class="line"></span><br><span class="line">Rabbit.prototype = &#123;</span><br><span class="line">  eats: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用了新定义的的 prototype</span></span><br><span class="line"><span class="keyword">let</span> rabbit2 = <span class="keyword">new</span> Rabbit();</span><br><span class="line"><span class="comment">// 然后删除新定义的 prototype 的 eats</span></span><br><span class="line"><span class="keyword">delete</span> Rabbit.prototype.eats; </span><br><span class="line"></span><br><span class="line">alert(rabbit1.eats); <span class="comment">// 从之前引用的 prototype 取值 true</span></span><br><span class="line">alert(rabbit2.eats); <span class="comment">// 从新的 prototype 取值 undefined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 为了确保正确的 <code>constructor</code>，我们可以选择添加/删除属性到默认 <code>prototype</code>，而不是将其整个覆盖；</p>
</blockquote>
<h4 id="原生的原型"><a href="#原生的原型" class="headerlink" title="原生的原型"></a>原生的原型</h4><p>所有的内建对象都遵循相同的模式（pattern）：方法都存储在 prototype 中，同时对象本身只存储数据；</p>
<p><strong>Object 和 Object.prototype</strong></p>
<p>Object 是 JavaScript 的一种数据类型，它用于存储各种键值集合和更复杂的实体；Objects 可以通过 Object() 构造函数或者使用对象字面量的方式创建；Object 构造函数为给定的参数创建一个包装类对象（object wrapper），具体有以下情况：</p>
<ul>
<li>如果给定值是 null 或 undefined，将会创建并返回一个空对象；</li>
<li>如果传进去的是一个基本类型的值，则会构造其包装类型的对象；</li>
<li>如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址；</li>
<li>当以非构造函数形式被调用时，Object 的行为等同于 new Object()，返回一个空对象；</li>
</ul>
<blockquote>
<p>Note: 按照规范，所有的内建原型顶端都是 <code>Object.prototype</code>，这就是为什么说“一切都从对象继承而来”；<code>Object.prototype</code> 上方的链中没有更多的 <code>[[Prototype]]</code>；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.__proto__.__proto__.__proto__; <span class="comment">// String Object null</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">Object MDN 中文参考文档</a></li>
</ul>
<p><strong>基础类型</strong></p>
<p>如果试图访问基本数据类型的属性，那么临时包装器对象将会通过内建的构造器 String、Number 和 Boolean 被创建，提供给我们操作字符串、数字和布尔值的方法然后消失；</p>
<blockquote>
<p>Note: null 和 undefined 比较特殊，它们没有对象包装器，所以它们没有方法和属性，并且它们也没有相应的原型；</p>
</blockquote>
<p>在现代编程中，只有一种情况下允许修改原生原型，那就是 polyfilling；但因为原型是全局的，所以很容易造成冲突；</p>
<p><strong>借用原型方法</strong></p>
<p>除了通过复制借用原生原型的方法之外，还可以通过将 <code>obj.__proto__</code> 设置为对应内置对象的 prototype，然后可以使用该原型下的所有方法；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;world!&quot;</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只复制某个方法</span></span><br><span class="line">obj.join = <span class="built_in">Array</span>.prototype.join;</span><br><span class="line"><span class="comment">// 或者指定原型</span></span><br><span class="line">obj.__proto__ = <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line">alert( obj.join(<span class="string">&#x27;,&#x27;</span>) ); <span class="comment">// Hello,world!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装器 + prototype 原型方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.defer = <span class="function"><span class="keyword">function</span> (<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// undefined [1, 2]</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      context.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或使用箭头函数 </span></span><br><span class="line">  <span class="comment">// return (...args) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   setTimeout(this.apply(this, args), ms);</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.defer(<span class="number">1000</span>)(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1 秒后显示 3</span></span><br></pre></td></tr></table></figure>

<h4 id="原型方法，没有-proto-的对象"><a href="#原型方法，没有-proto-的对象" class="headerlink" title="原型方法，没有 __proto__ 的对象"></a>原型方法，没有 <code>__proto__</code> 的对象</h4><p>JavaScript 规范中规定，proto 必须仅在浏览器环境下才能得到支持，因此 <code>__proto__</code> 被认为是过时且不推荐使用的（deprecated）；应该使用以下现代方法代替 <code>__proto__</code>：</p>
<ul>
<li>Object.create(proto, [descriptors]) 利用给定的 proto 作为 [[Prototype]] 和可选的属性描述来创建一个空对象；</li>
<li>Object.getPrototypeOf(obj) 返回对象 obj 的 [[Prototype]]；</li>
<li>Object.setPrototypeOf(obj, proto) 将对象 obj 的 [[Prototype]] 设置为 proto；</li>
</ul>
<p>使用 Object.create 来实现比复制 for..in 循环中的属性更强大的对象克隆方式；以对 obj 进行真正准确地拷贝，包括所有的属性：可枚举和不可枚举的，数据属性和 setters/getters —— 包括所有内容，并带有正确的 [[Prototype]]；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clone = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: JavaScript 引擎对此进行了高度优化，用 <code>Object.setPrototypeOf</code> 或对 <code>obj.__proto__</code> 赋值，“即时”更改原型是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化；</p>
</blockquote>
<p><strong>very plain object</strong></p>
<p>在对象中 <code>__proto__</code> 属性很特别：它必须是对象或者 null，其他原始类型的赋值会被忽略；而使用 Object.create(null) 创建了一个空对象，这个对象没有原型（[[Prototype]] 是 null），所以 <code>__proto__</code> 没有继承 Object.prototype 的 getter/setter，因此可以被赋以任何原始类型值；这样的对象称为 “very plain” 或 “pure dictionary” 对象；</p>
<p><strong>其他静态方法</strong></p>
<ul>
<li>Object.keys(obj) / Object.values(obj) / Object.entries(obj) 返回一个可枚举的由自身的字符串属性名/值/键值对组成的数组；</li>
<li>Object.getOwnPropertySymbols(obj) 返回一个由自身所有的 symbol 类型的键组成的数组；</li>
<li>Object.getOwnPropertyNames(obj) 返回一个由自身所有的字符串键组成的数组；</li>
<li>Reflect.ownKeys(obj) 返回一个由自身所有键组成的数组；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">&quot;Rabbit&quot;</span>);</span><br><span class="line"></span><br><span class="line">rabbit.sayHi(); <span class="comment">// Rabbit</span></span><br><span class="line">Rabbit.prototype.sayHi(); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rabbit).sayHi(); <span class="comment">// undefined</span></span><br><span class="line">rabbit.__proto__.sayHi(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="Class-基本语法"><a href="#Class-基本语法" class="headerlink" title="Class 基本语法"></a>Class 基本语法</h4><p>在现代 JavaScript 中，还有一个更高级的“类（class）”构造方式；而 new 操作符会自动调用 constructor() 方法，因此我们可以在 constructor() 中初始化对象；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的定义实际上声明了一个函数，然后存储类中的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">      alert(<span class="string">&quot;Name is too short.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">user.sayHi();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类其实是一个 constructor 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> User); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(User.prototype.constructor.name); <span class="comment">// User</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(User.prototype)); <span class="comment">// [&#x27;constructor&#x27;, &#x27;sayHi&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class 类与 function 类的差异</span></span><br><span class="line">User(); <span class="comment">// Cannot call a class as a function</span></span><br><span class="line"><span class="comment">// 打印 User 方法的标识符对象</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(User.prototype);</span><br></pre></td></tr></table></figure>

<p>class 不是语法糖，class 与直接使用 function 定义的类有很大差异：</p>
<ol>
<li>通过 class 创建的函数具有特殊的内部属性标记 [[IsClassConstructor]]: true；</li>
<li>类方法不可枚举，类定义将 “prototype” 中的所有方法的 enumerable 标志设置为 false；</li>
<li>类总是使用 use strict；在类构造中的所有代码都将自动进入严格模式；</li>
</ol>
<!-- class类是方法，原型是对象；构造器是方法类；原型对象用于存储实例方法和属性，class类用于存储静态方法和属性； -->

<p><strong>类表达式</strong></p>
<p>就像函数一样，类可以在另外一个表达式中被定义，被传递，被返回，被赋值等；类似于命名函数表达式（Named Function Expressions），类表达式也可以有一个名字，如果类表达式有名字，那么该名字仅在类内部可见；</p>
<p>同对象字面量，类可能包括 getters/setters，计算属性（computed properties）等；</p>
<p>“类字段”是一种允许添加任何属性的语法，与类方法不同，类字段在每个独立对象中被设好，而不是设在 User.prototype；类字段还可以解决丢失 this 的问题；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  click = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> Button(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(button.click, <span class="number">1000</span>); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h4><p>类继承是一个类扩展另一个类的一种方式，可以在现有功能之上创建新功能；</p>
<p>在内部，关键字 extends 使用了旧的原型机制进行工作；它将子类的 prototype.[[Prototype]] 设置为父类的 prototype；</p>
<blockquote>
<p>Tips: 类语法不仅允许指定一个类，在 <code>extends</code> 后可以指定任意表达式，例如一个生成父类的函数调用；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">phrase</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; alert(phrase); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User extends f(&quot;Hello&quot;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi(); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>在子类中可以重写父类同名方法，然后可以使用 super 关键字调用父类方法；箭头函数没有 super，有则会从外部获取；</p>
<p>根据规范，如果一个类扩展了另一个类并且没有 constructor，那么将生成一个只调用 super 的“空” constructor；继承类的 constructor 必须调用 super(…)，并且 (!) 一定要在使用 this 之前调用；</p>
<blockquote>
<p>在 JavaScript 中，继承类（所谓的“派生构造器”，英文为 “derived constructor”）的构造函数与其他函数之间是有区别的；派生构造器具有特殊的内部属性 [[ConstructorKind]]:”derived”；当通过 new 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 this；但是当继承的 constructor 执行时，它不会执行此操作，而是期望父类的 constructor 来完成这项工作；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, earLength</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// super(name);</span></span><br><span class="line">    <span class="built_in">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.earLength = earLength;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">&quot;White Rabbit&quot;</span>, <span class="number">10</span>); <span class="comment">// Error: this is not defined.</span></span><br></pre></td></tr></table></figure>

<p>字段初始化的顺序是基类（还未继承任何东西的那种），在构造函数调用前初始化；派生类，在 super() 后立刻初始化；</p>
<p>父类构造器总是会使用它自己字段的值，而不是被子类重写的那一个类字段；可以通过使用方法或者 getter/setter 替代类字段，来修复这个问题；</p>
<p>JavaScript 为函数添加了一个特殊的内部属性：[[HomeObject]]；当一个函数被定义为类或者对象方法时，它的 [[HomeObject]] 属性就成为了该对象；[[HomeObject]] 不能被更改，所以这个绑定是永久的，[[HomeObject]] 是为类和普通对象中的方法定义的，但是对于对象而言，方法必须确切指定为 method()，而不是 “method: function()”；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  name: <span class="string">&quot;Animal&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// animal.eat.[[HomeObject]] == animal</span></span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  jump: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> jump.`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  __proto__: animal,</span><br><span class="line">  name: <span class="string">&quot;Rabbit&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// rabbit.eat.[[HomeObject]] == rabbit</span></span><br><span class="line">    <span class="built_in">super</span>.eat();</span><br><span class="line">  &#125;,</span><br><span class="line">  jump: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// super.jump(); // &#x27;super&#x27; is only allowed in object methods and classes.</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> longEar = &#123;</span><br><span class="line">  __proto__: rabbit,</span><br><span class="line">  name: <span class="string">&quot;Long Ear&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// longEar.eat.[[HomeObject]] == longEar</span></span><br><span class="line">    <span class="built_in">super</span>.eat();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确执行</span></span><br><span class="line">longEar.eat(); <span class="comment">// Long Ear eats.</span></span><br><span class="line"><span class="comment">// rabbit.jump();</span></span><br></pre></td></tr></table></figure>

<h4 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h4><p>可以把一个方法赋值给类的函数本身，而不是赋给它的 “prototype”，这样的方法被称为 静态的（static）；静态方法和属性可以被继承；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> staticProperty = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="built_in">this</span> === User);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">User.staticMethod(); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果相同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; &#125;</span><br><span class="line">User.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span> === User);</span><br><span class="line">&#125;;</span><br><span class="line">User.staticProperty = <span class="number">10</span>;</span><br><span class="line">User.staticMethod(); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extends 创建两个 [[prototype]]，一个是类本身的，另一个是类原型的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VipUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.warn(VipUser.__proto__ === User); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.warn(VipUser.prototype.__proto__ === User.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="私有的和受保护的属性和方法"><a href="#私有的和受保护的属性和方法" class="headerlink" title="私有的和受保护的属性和方法"></a>私有的和受保护的属性和方法</h4><p>在面向对象的编程中，属性和方法分为两组：</p>
<ul>
<li>内部接口：可以通过该类的其他方法访问，但不能从外部访问的方法和属性；</li>
<li>外部接口：也可以从类的外部访问的方法和属性；</li>
</ul>
<p>为了隐藏内部接口，我们使用受保护的或私有的属性；</p>
<ul>
<li>受保护的字段以 _ 开头，这是一个众所周知的约定，不是在语言级别强制执行的；</li>
<li>私有字段以 # 开头，JavaScript 确保我们只能从类的内部访问它们；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义私有变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  _name = <span class="string">&quot;any&quot;</span>;</span><br><span class="line">  #age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">static</span> #secret = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> <span class="title">secret</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.#secret;</span><br><span class="line">  &#125;</span><br><span class="line">  #<span class="function"><span class="title">whisper</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(User.secret); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// console.log(User.#secret); // Property &#x27;#secret&#x27; is not accessible outside class &#x27;User&#x27; because it has a private identifier</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展内建类"><a href="#扩展内建类" class="headerlink" title="扩展内建类"></a>扩展内建类</h4><p>通常使用 extends 继承内建类，可以扩展内建类的一些方法，或者可以在内建类的原型对象上添加自定义的字段以实现扩展；</p>
<blockquote>
<p>Note: 内建类相互间不继承静态方法；</p>
</blockquote>
<h4 id="类检查：instanceof"><a href="#类检查：instanceof" class="headerlink" title="类检查：instanceof"></a>类检查：instanceof</h4><p>instanceof 操作符用于检查一个对象是否属于某个特定的 class，通常，instanceof 在检查中会将原型链考虑在内；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit();</span><br><span class="line"><span class="built_in">console</span>.log( rabbit <span class="keyword">instanceof</span> Rabbit ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是构造函数，而不是 class</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">new</span> Rabbit() <span class="keyword">instanceof</span> Rabbit ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Symbol.hasInstance</strong></p>
<p>自定义 instanceof，可以在静态方法 Symbol.hasInstance 中设置自定义逻辑；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 instanceOf 检查</span></span><br><span class="line"><span class="comment">// 并假设具有 canEat 属性的都是 animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">canEat</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">alert(obj <span class="keyword">instanceof</span> Animal); <span class="comment">// true：Animal[Symbol.hasInstance](obj) 被调用</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.prototype.isPrototypeOf()</strong></p>
<p>另一个方法：objA.isPrototypeOf(objB) 判断 objA 处在 objB 的原型链中，返回布尔值；但如果中途修改了原型，则之前创建的实例无法被正确判断；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(obj); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变原型指向</span></span><br><span class="line">obj.__proto__ = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(obj); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/object/isPrototypeOf">Object.prototype.isPrototypeOf() MDN 中文参考文档</a></p>
<p><strong>Object.prototype.toString()</strong></p>
<p>使用 Object.prototype.toString 方法来可以揭示类型：按照规范，内建的 toString 方法可以被从对象中提取出来，并在任何其他值的上下文中执行，其结果取决于该值；如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 {}.toString.call 替代 instanceof；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方便起见，将 toString 方法复制到一个变量中</span></span><br><span class="line"><span class="keyword">let</span> objectToString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">alert( objectToString.call(arr) ); <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>

<p>对象的 toString 方法可以使用特殊的对象属性 Symbol.toStringTag 被自定义；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&quot;User&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( &#123;&#125;.toString.call(user) ); <span class="comment">// [object User]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特定于环境的对象和类的 toStringTag：</span></span><br><span class="line">alert( <span class="built_in">window</span>[<span class="built_in">Symbol</span>.toStringTag]); <span class="comment">// Window</span></span><br><span class="line">alert( XMLHttpRequest.prototype[<span class="built_in">Symbol</span>.toStringTag] ); <span class="comment">// XMLHttpRequest</span></span><br><span class="line"></span><br><span class="line">alert( &#123;&#125;.toString.call(<span class="built_in">window</span>) ); <span class="comment">// [object Window]</span></span><br><span class="line">alert( &#123;&#125;.toString.call(<span class="keyword">new</span> XMLHttpRequest()) ); <span class="comment">// [object XMLHttpRequest]</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">类型检查</th>
<th align="left">用于</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">typeof</td>
<td align="left">原始数据类型</td>
<td align="left">string</td>
</tr>
<tr>
<td align="left">instanceof</td>
<td align="left">对象</td>
<td align="left">true/false</td>
</tr>
<tr>
<td align="left">{}.toString</td>
<td align="left">原始数据类型，内建对象，包含 Symbol.toStringTag 属性的对象</td>
<td align="left">string</td>
</tr>
</tbody></table>
<h4 id="Mixin-模式"><a href="#Mixin-模式" class="headerlink" title="Mixin 模式"></a>Mixin 模式</h4><p>Mixin 是一个通用的面向对象编程术语：一个包含可被其他类使用而无需继承的方法的类；Mixin 提供了实现特定行为的方法，但是我们不单独使用它，而是使用它来将这些行为添加到其他类中；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHiBase = &#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHiMixin = &#123;</span><br><span class="line">  <span class="comment">// 设置原型</span></span><br><span class="line">  __proto__: sayHiBase,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.say();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">`Hello <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">sayBye</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">`Bye <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mixin</span></span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, sayHiMixin);</span><br><span class="line"><span class="keyword">new</span> User(<span class="string">&#x27;Coley&#x27;</span>).sayHi(); <span class="comment">// coley</span></span><br><span class="line"><span class="keyword">new</span> User(<span class="string">&#x27;Hush&#x27;</span>).say(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 在 <code>sayHiMixin</code> 内部对父类方法 <code>super.say()</code> 的调用会在 <code>mixin</code> 的原型中查找方法，而不是在 class 中查找；因为方法 <code>say</code> 最初是在 <code>sayHiMixin</code> 中创建的，因此，即使复制了它们，但是 <code>say</code> 的 <code>[[HomeObject]]</code> 内部属性仍引用的是 sayHiMixin；当 <code>super</code> 在 <code>[[HomeObject]].[[Prototype]]</code> 中寻找父方法时，意味着它搜索的是 <code>sayHiMixin.[[Prototype]]</code>，而不是 <code>User.[[Prototype]]</code>；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> eventMixin = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 订阅事件，用法：</span></span><br><span class="line"><span class="comment">   *  menu.on(&#x27;select&#x27;, function(item) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">eventName, handler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers) <span class="built_in">this</span>._eventHandlers = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers[eventName]) &#123;</span><br><span class="line">      <span class="built_in">this</span>._eventHandlers[eventName] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._eventHandlers[eventName].push(handler);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 取消订阅，用法：</span></span><br><span class="line"><span class="comment">   *  menu.off(&#x27;select&#x27;, handler)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">eventName, handler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> handlers = <span class="built_in">this</span>._eventHandlers?.[eventName];</span><br><span class="line">    <span class="keyword">if</span> (!handlers) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handlers.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (handlers[i] === handler) &#123;</span><br><span class="line">        handlers.splice(i--, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成具有给定名称和数据的事件</span></span><br><span class="line"><span class="comment">   *  this.trigger(&#x27;select&#x27;, data1, data2);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">trigger</span>(<span class="params">eventName, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers?.[eventName]) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 该事件名称没有对应的事件处理程序（handler）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用事件处理程序（handler）</span></span><br><span class="line">    <span class="built_in">this</span>._eventHandlers[eventName].forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler.apply(<span class="built_in">this</span>, args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://zh.javascript.info/mixins">JavaScript 现代教程-Mixin 模式</a></li>
</ul>
<h4 id="错误处理，try…catch"><a href="#错误处理，try…catch" class="headerlink" title="错误处理，try…catch"></a>错误处理，try…catch</h4><p>try…catch 仅对运行时的 error 有效；这类错误被称为“运行时的错误（runtime errors）”，有时被称为“异常（exceptions）”；</p>
<p>如果在“计划的（scheduled）”代码中发生异常，例如在 setTimeout 中，则 try…catch 不会捕获到异常：为了捕获到计划的（scheduled）函数中的异常，那么 try…catch 必须在这个函数内；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    noSuchVariable; <span class="comment">// try...catch 处理 error 了！</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    alert( <span class="string">&quot;error is caught here!&quot;</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>对于所有内建的 error，error 对象具有两个主要属性和其他非标准的属性：</p>
<ul>
<li>name：Error 名称；</li>
<li>message：关于 error 的详细文字描述；</li>
<li>stack：当前的调用栈：用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息；</li>
</ul>
<p>使用 throw <error object> 会生成一个 error 对象；技术上讲，我们可以将任何东西用作 error 对象。甚至可以是一个原始类型数据，例如数字或字符串，但最好使用对象，最好使用具有 name 和 message 属性的对象（某种程度上保持与内建 error 的兼容性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完整语法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//  ... 尝试执行的代码 ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">//  ... 处理 error ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">//  ... 总是会执行的代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>finally</code> 子句适用于 <code>try...catch</code> 的任何出口，这包括显式的 <code>return</code>；</p>
</blockquote>
<p>规范中没有全局 catch 的相关内容，但是代码的执行环境一般会提供这种机制；Node.JS 有 process.on(“uncaughtException”)；在浏览器中，可以将一个函数赋值给特殊的 window.onerror 属性，该函数将在发生未捕获的 error 时执行；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, url, line, col, error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// message：Error 信息；</span></span><br><span class="line">  <span class="comment">// url；发生 error 的脚本的 URL；</span></span><br><span class="line">  <span class="comment">// line，col：发生 error 处的代码的行号和列号；</span></span><br><span class="line">  <span class="comment">// error：Error 对象；</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>全局错误处理程序 window.onerror 的作用通常不是恢复脚本的执行，如果发生编程错误，那这几乎是不可能的，它的作用是将错误信息发送给开发者；</p>
<h4 id="自定义-Error，扩展-Error"><a href="#自定义-Error，扩展-Error" class="headerlink" title="自定义 Error，扩展 Error"></a>自定义 Error，扩展 Error</h4><p>JavaScript 允许将 throw 与任何参数一起使用，所以从技术上讲，我们自定义的 error 不需要从 Error 中继承。但是，如果我们继承，那么就可以使用 obj instanceof Error 来识别 error 对象；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">message</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="built_in">this</span>.constructor.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationError</span> <span class="keyword">extends</span> <span class="title">MyError</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyRequiredError</span> <span class="keyword">extends</span> <span class="title">ValidationError</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">property</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;No property: &quot;</span> + property);</span><br><span class="line">    <span class="built_in">this</span>.property = property;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name 是对的</span></span><br><span class="line">alert( <span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;field&quot;</span>).name ); <span class="comment">// PropertyRequiredError</span></span><br></pre></td></tr></table></figure>

<p>包装异常是一项广泛应用的技术：用于处理低级别异常并创建高级别 error 而不是各种低级别 error 的函数，低级别异常有时会成为该对象的属性；</p>
<h4 id="回调简介"><a href="#回调简介" class="headerlink" title="回调简介"></a>回调简介</h4><p>异步执行某项功能的函数应该提供一个 callback 参数用于在相应事件完成时调用，这被称为“基于回调”的异步编程风格；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态加载脚本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 &lt;script&gt; 标签，并将其附加到页面</span></span><br><span class="line">  <span class="comment">// 这将使得具有给定 src 的脚本开始加载，并在加载完成后运行</span></span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  script.onload = <span class="function">() =&gt;</span> callback(script);</span><br><span class="line">  script.onerror = <span class="function">() =&gt;</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error for <span class="subst">$&#123;src&#125;</span>`</span>));</span><br><span class="line">  <span class="built_in">document</span>.head.append(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>传递给 new Promise 的函数被称为 executor，当 new Promise 被创建，executor 会自动运行；它的参数 resolve 和 reject 是由 JavaScript 自身提供的回调；</p>
<ul>
<li>resolve(value) 如果任务成功完成并带有结果 value；</li>
<li>reject(error) 如果出现了 error，error 即为 error 对象；</li>
</ul>
<p>由 new Promise 构造器返回的 promise 对象具有以下内部属性：</p>
<ul>
<li>state 最初是 “pending”，然后在 resolve 被调用时变为 “fulfilled”，或者在 reject 被调用时变为 “rejected”；</li>
<li>result 最初是 undefined，然后在 resolve(value) 被调用时变为 value，或者在 reject(error) 被调用时变为 error；</li>
</ul>
<p>Promise 可以通过使用 .then、.catch 和 .finally 方法接收处理结果：</p>
<ul>
<li>.then 的第一个参数是一个函数，该函数将在 promise resolved 后运行并接收结果；.then 的第二个参数也是一个函数，该函数将在 promise rejected 后运行并接收 error；</li>
<li>.catch(f) 调用是 .then(null, f) 的完全的模拟，它只是一个简写形式；如果错误在前面以及被处理，该部分不会执行；</li>
<li>.finally(f) 处理程序（handler）没有参数，在某种意义上，f 总是在 promise 被 settled 时运行：即 promise 被 resolve 或 reject；finally 处理程序将结果和 error 传递给下一个处理程序；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// executor</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>));</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;).then(</span><br><span class="line">          (result) =&gt; &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(result); <span class="comment">// Done.</span></span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Unexpected error.&quot;</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">          (error) =&gt; &#123;</span><br><span class="line">              <span class="built_in">console</span>.warn(error); <span class="comment">// Whoops!</span></span><br><span class="line">          &#125;</span><br><span class="line">      ).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 可以接收之前 .then 中的错误</span></span><br><span class="line">          <span class="built_in">console</span>.warn(err); <span class="comment">// Unexpected error.</span></span><br><span class="line">      &#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;Finished.&quot;</span>);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>executor</code> 只能调用一个 <code>resolve</code> 或一个 <code>reject</code>，任何状态的更改都是最终的；所有其他的再对 <code>resolve</code> 和 <code>reject</code> 的调用都会被忽略；此外，直接受一个参数，多余的参数也会被忽略；</p>
</blockquote>
<blockquote>
<p>Note: 通常以 <code>Error</code> 对象 <code>reject</code>；实际上，<code>executor</code> 中还可以立即调用 <code>resolve</code> 或 <code>reject</code>；</p>
</blockquote>
<blockquote>
<p>Tips: 如果 <code>promise</code> 为 <code>pending</code> 状态，<code>.then/catch/finally</code> 处理程序（handler）将等待它。否则，如果 <code>promise</code> 已经是 <code>settled</code> 状态，它们就会立即运行；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">3000</span>).then(<span class="function">() =&gt;</span> alert(<span class="string">&#x27;runs after 3 seconds&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="Promise-链"><a href="#Promise-链" class="headerlink" title="Promise 链"></a>Promise 链</h4><p>每个对 .then 的调用都会返回了一个新的 promise，因此我们可以在其之上调用下一个 .then；形成一个 .then 处理程序（handler）链，也即 Promise 链；</p>
<p>同时 .then(handler) 中所使用的处理程序（handler）可以创建并返回一个 promise，其后的处理程序（handler）将等待它 settled 后再获得其结果（result）；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(result); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// (*)</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(result); <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 确切地说，处理程序（handler）返回的不完全是一个 <code>promise</code>，而是返回的被称为 <code>thenable</code> 对象 — 一个具有方法 <code>.then</code> 的任意对象，它会被当做一个 <code>promise</code> 来对待；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thenable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">num</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现 .then 方法</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    alert(resolve); <span class="comment">// function() &#123; native code &#125;</span></span><br><span class="line">    <span class="comment">// 1 秒后使用 this.num*2 进行 resolve</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="built_in">this</span>.num * <span class="number">2</span>), <span class="number">1000</span>); <span class="comment">// (**)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-promise-进行错误处理"><a href="#使用-promise-进行错误处理" class="headerlink" title="使用 promise 进行错误处理"></a>使用 promise 进行错误处理</h4><p>Promise 的执行者（executor）和 promise 的处理程序（handler）周围有一个“隐式的 try..catch”；如果发生异常，就会被捕获，并被视为 rejection 进行处理；控制权移交至最近的 error 处理程序（handler）；</p>
<p>在浏览器中，我们可以使用 unhandledrejection 事件来捕获这类 error；这个事件是 HTML 标准 的一部分；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unhandledrejection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个事件对象有两个特殊的属性：</span></span><br><span class="line">  alert(event.promise); <span class="comment">// [object Promise] - 生成该全局 error 的 promise</span></span><br><span class="line">  alert(event.reason); <span class="comment">// Error: Whoops! - 未处理的 error 对象</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>);</span><br><span class="line">&#125;); <span class="comment">// 没有用来处理 error 的 catch</span></span><br></pre></td></tr></table></figure>

<p>有一个浏览器技巧，是从 finally 返回零延时（zero-timeout）的 promise；这是因为一些浏览器（比如 Chrome）需要“一点时间”的 promise 处理程序来绘制文档的更改；因此它确保在进入链下一步之前，指示在视觉上是停止的；</p>
<p>函数代码周围有个“隐式的 try..catch”，所以，所有同步错误都会得到处理，但是无法捕获异步的错误；try…catch 是同步工作的；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// throw new Error(&quot;Sync error.&quot;) // 可以捕获</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// reject(new Error(&quot;No&quot;)); // 可以处理</span></span><br><span class="line">        <span class="comment">// throw new Error(&quot;Async error.&quot;); // 无法捕获</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;).catch(alert);</span><br></pre></td></tr></table></figure>

<h4 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h4><p>在 Promise 类中，有 6 种静态方法；</p>
<p><strong>Promise.all</strong></p>
<p>并行执行多个 promise，并等待所有 promise 都准备就绪；Promise.all 接受一个 promise 数组作为参数（从技术上讲，它可以是任何可迭代对象，但通常是一个数组）并返回一个新的 promise；</p>
<p>结果数组中元素的顺序与其在源 promise 中的顺序相同，即使第一个 promise 花费了最长的时间才 resolve，但它仍是结果数组中的第一个；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">3000</span>)), <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">2</span>), <span class="number">2000</span>)), <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">3</span>), <span class="number">1000</span>)) <span class="comment">// 3</span></span><br><span class="line">]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;); <span class="comment">// 1,2,3 当上面这些 promise 准备好时：每个 promise 都贡献了数组中的一个元素</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 一个常见的技巧是，将一个任务数据数组映射（map）到一个 <code>promise</code> 数组，然后将其包装到 <code>Promise.all</code>；</p>
</blockquote>
<p>如果任意一个 promise 被 reject，由 Promise.all 返回的 promise 就会立即 reject，并且带有的就是这个 error；Promise.all 也会立即被 reject，完全忽略列表中其他的 promise，它们的结果也被忽略；</p>
<p>Promise.all(iterable) 允许在 iterable 中使用 non-promise 的“常规”值；常规值将被“按原样”传递给结果数组；</p>
<p><strong>Promise.allSettled</strong></p>
<p>Promise.allSettled 等待所有的 promise 都被 settle，无论结果如何；结果数组有两种数据：</p>
<ul>
<li>{status:”fulfilled”, value:result} 对于成功的响应；</li>
<li>{status:”rejected”, reason:error} 对于 error；</li>
</ul>
<p><strong>Promise.race</strong></p>
<p>与 Promise.all 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）；第一个 settled 的 promise “赢得了比赛”之后，所有进一步的 result/error 都会被忽略；</p>
<p><strong>Promise.any</strong></p>
<p>与 Promise.race 类似，区别在于 Promise.any 只等待第一个 fulfilled 的 promise，并将这个 fulfilled 的 promise 返回；如果给出的 promise 都 rejected，那么则返回 rejected 的 promise 和 AggregateError（一个特殊的 error 对象），在其 errors 属性中存储着所有 promise error；</p>
<p><strong>Promise.resolve</strong></p>
<p>Promise.resolve(value) 用结果 value 创建一个 resolved 的 promise；当可以直接从缓存中获取了当前操作的结果 value，但是期望返回的是一个 promise 时，可以使用 Promise.resolve(value) 将 value “封装”进 promise，以满足期望返回一个 promise 的这个需求；</p>
<p><strong>Promise.reject</strong></p>
<p>与 Promise.resolve 类似 Promise.reject(error) 用 error 创建一个 rejected 的 promise；</p>
<h4 id="Promisification"><a href="#Promisification" class="headerlink" title="Promisification"></a>Promisification</h4><p>promisify(f)：接受一个需要被 promisify 的函数 f，并返回一个包装（wrapper）函数；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123; <span class="comment">// 返回一个包装函数（wrapper-function） (*)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err, result</span>) </span>&#123; <span class="comment">// 我们对 f 的自定义的回调 (**)</span></span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      args.push(callback); <span class="comment">// 将我们的自定义的回调附加到 f 参数（arguments）的末尾</span></span><br><span class="line"></span><br><span class="line">      f.call(<span class="built_in">this</span>, ...args); <span class="comment">// 调用原始的函数</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">let</span> loadScriptPromise = promisify(loadScript);</span><br><span class="line">loadScriptPromise(...).then(...);</span><br></pre></td></tr></table></figure>

<h4 id="微任务（Microtask）"><a href="#微任务（Microtask）" class="headerlink" title="微任务（Microtask）"></a>微任务（Microtask）</h4><p>Promise 的处理程序（handlers）.then、.catch 和 .finally 都是异步的；而异步任务需要适当的管理，为此，ECMA 标准规定了一个内部队列 PromiseJobs，通常被称为“微任务队列（microtask queue）”（V8 术语）；</p>
<p>如规范中所述：队列（queue）是先进先出的：首先进入队列的任务会首先运行；同时，只有在 JavaScript 引擎中没有其它任务在运行时，才开始执行任务队列中的任务；</p>
<p>如果一个 promise 的 error 未被在微任务队列的末尾进行处理，则会出现“未处理的 rejection”；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Promise Failed!&quot;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> promise.catch(<span class="function"><span class="params">err</span> =&gt;</span> alert(<span class="string">&#x27;caught&#x27;</span>)), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Promise Failed!</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unhandledrejection&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> alert(event.reason));</span><br></pre></td></tr></table></figure>

<h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>async 函数总是返回一个 promise，其他值将自动被包装在一个 resolved 的 promise 中；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(alert); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>await 的关键词，只在 async 函数内工作；await 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果；</p>
<p>await 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行；这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等；</p>
<blockquote>
<p>Tips: 在现代浏览器中，当我们处于一个 <code>module</code> 中时，那么在顶层使用 <code>await</code> 也是被允许的；实测只在 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签中可用；或者可以使用立即执行函数；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/promise-chaining/user.json&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> response.json();</span><br><span class="line">  ...</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>await 允许使用 thenable 对象；如果 await 接收了一个非 promise 的 Thenable 对象，它就会调用这个 .then 方法，并将内建的函数 resolve 和 reject 作为参数传入（就像它对待一个常规的 Promise executor 时一样）；然后 await 等待直到这两个函数中的某个被调用，然后使用得到的结果继续执行后续任务；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thenable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">num</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    alert(resolve);</span><br><span class="line">    <span class="comment">// 1000ms 后使用 this.num*2 进行 resolve</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="built_in">this</span>.num * <span class="number">2</span>), <span class="number">1000</span>); <span class="comment">// (*)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 等待 1 秒，之后 result 变为 2</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> Thenable(<span class="number">1</span>);</span><br><span class="line">  alert(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p>如果一个 promise 正常 resolve，await promise 返回的就是其结果。但是如果 promise 被 reject，它将 throw 这个 error；这时可以在 async 函数中用 try..catch 来捕获上面提到的那个 error，与常规的 throw 使用的是一样的方式；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>));</span><br><span class="line">  <span class="comment">// 等价于 throw new Error(&quot;Whoops!&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://no-such-url&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    alert(err); <span class="comment">// TypeError: failed to fetch</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: <code>async/await</code> 可以和 <code>Promise.all</code> 一起使用；</p>
</blockquote>
<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p> Generator 可以按需一个接一个地返回（“yield”）多个值；它们可与 iterable 完美配合使用，从而可以轻松地创建数据流；在此类函数被调用时，它不会运行其代码，而是返回一个被称为 “generator object” 的特殊对象，来管理执行流程；</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"><span class="built_in">console</span>.log(generator); <span class="comment">// Generator &#123;_invoke: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> one = generator.next();</span><br><span class="line"><span class="keyword">let</span> two = generator.next();</span><br><span class="line"><span class="keyword">let</span> three = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(one, two, three);</span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125; &#123;value: 2, done: false&#125; &#123;value: 3, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p> 一个 generator 的主要方法就是 next()，当 next 被调用时，它会恢复上图所示的运行，执行直到最近的 yield <value> 语句（value 可以被省略，默认为 undefined），然后函数执行暂停，并将产出的（yielded）值返回到外部代码；</p>
<p>Generator 是可迭代的，但当 done: true 时，for..of 循环会忽略最后一个 value；因此，如果我们想要通过 for..of 循环显示所有的结果，必须使用 yield 返回它们；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> generator) &#123;</span><br><span class="line">  alert(value); <span class="comment">// 1，然后是 2，然后是 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sequence = [<span class="number">0</span>, ...generateSequence()];</span><br><span class="line">alert(sequence); <span class="comment">// 0, 1, 2, 3</span></span><br></pre></td></tr></table></figure>

<p>可以通过提供一个 generator 函数作为 Symbol.iterator，来使用 generator 进行迭代；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [Symbol.iterator]: function*() 的简写形式</span></span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> value = <span class="built_in">this</span>.from; value &lt;= <span class="built_in">this</span>.to; value++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( [...range] ); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<p>对于 generator 而言，我们可以使用 yield* 这个特殊的语法来将一个 generator “嵌入”（组合）到另一个 generator 中；yield* 指令将执行委托给另一个 generator，这个术语意味着 yield* gen 在 generator gen 上进行迭代，并将其产出（yield）的值透明地（transparently）转发到外部；执行结果与我们内联嵌套 generator 中的代码获得的结果相同；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) <span class="keyword">yield</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatePasswordCodes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0..9</span></span><br><span class="line">  <span class="keyword">yield</span>* generateSequence(<span class="number">48</span>, <span class="number">57</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A..Z</span></span><br><span class="line">  <span class="keyword">yield</span>* generateSequence(<span class="number">65</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a..z</span></span><br><span class="line">  <span class="keyword">yield</span>* generateSequence(<span class="number">97</span>, <span class="number">122</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> code <span class="keyword">of</span> generatePasswordCodes()) &#123;</span><br><span class="line">  str += <span class="built_in">String</span>.fromCharCode(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(str); <span class="comment">// 0..9A..Za..z</span></span><br></pre></td></tr></table></figure>

<p>与常规函数不同，generator 和调用 generator 的代码可以通过在 next/yield 中传递值来交换结果；yield 不仅可以向外返回结果，而且还可以将外部的值传递到 generator 内；调用 generator.next(arg)，就能将参数 arg 传递到 generator 内部，这个 arg 参数会变成 yield 的结果；</p>
<p>此外，调用 generator.throw(err) 向 yield 传递一个 error，在这种情况下，err 将被抛到对应的 yield 所在的那一行；如果我们没有在那里捕获这个 error，那么，通常，它会掉入外部调用代码（如果有），如果在外部也没有被捕获，则会杀死脚本；</p>
<p>还可以通过 generator.return(value) 完成 generator 的执行并返回给定的 value；如果我们在已完成的 generator 上再次使用 generator.return()，它将再次返回该值；通常只用于在特定条件下停止 generator；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 向外部代码传递一个问题并等待答案</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> <span class="string">&quot;2 + 2 = ?&quot;</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">  alert(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = gen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> question = generator.next().value; <span class="comment">// &lt;-- yield 返回的 value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果传递到 generator 中</span></span><br><span class="line">generator.next(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">generator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;The answer is not found in my database&quot;</span>));</span><br><span class="line"><span class="comment">// 主动返回</span></span><br><span class="line">g.return(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="异步迭代和-generator"><a href="#异步迭代和-generator" class="headerlink" title="异步迭代和 generator"></a>异步迭代和 generator</h4><p>异步迭代允许我们对按需通过异步请求而得到的数据进行迭代：</p>
<ul>
<li>使用 Symbol.asyncIterator 取代 Symbol.iterator；next() 方法；</li>
<li>应该返回一个 promise（带有下一个值，并且状态为 fulfilled），关键字 async 也可以实现这一点，我们可以简单地使用 async next()；</li>
<li>我们应该使用 for await (let item of iterable) 循环来迭代这样的对象；</li>
</ul>
<blockquote>
<p>Note: 需要常规的同步 <code>iterator</code> 的功能，无法与异步 <code>iterator</code> 一起使用，因为它期望找到 <code>Symbol.iterator</code>，而不是 <code>Symbol.asyncIterator</code>；因此 <code>Spread</code> 语法 <code>...</code> 和 <code>for..of</code> 无法异步工作；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步 generator</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">    <span class="comment">// 可以使用 await 了！</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> generator = generateSequence(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> value <span class="keyword">of</span> generator) &#123;</span><br><span class="line">    alert(value); <span class="comment">// 1，然后 2，然后 3，然后 4，然后 5（在每个 alert 之间有延迟）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>常规的 generator 可用作 Symbol.iterator 以使迭代代码更短，异步 generator 可用作 Symbol.asyncIterator 来实现异步迭代；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line">  <span class="comment">// 这一行等价于 [Symbol.asyncIterator]: async function*() &#123;</span></span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> value = <span class="built_in">this</span>.from; value &lt;= <span class="built_in">this</span>.to; value++) &#123;</span><br><span class="line">      <span class="comment">// 在 value 之间暂停一会儿，等待一些东西</span></span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">      <span class="keyword">yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> value <span class="keyword">of</span> range) &#123;</span><br><span class="line">    alert(value); <span class="comment">// 1，然后 2，然后 3，然后 4，然后 5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块 Module"></a>模块 Module</h4><p>简单讲，一个模块（module）就是一个文件，一个脚本就是一个模块；一个模块可以包含用于特定目的的类或函数库；</p>
<ul>
<li>AMD 最古老的模块系统之一，最初由 require.js 库实现；</li>
<li>CommonJS 为 Node.js 服务器创建的模块系统；</li>
<li>UMD 另外一个模块系统，建议作为通用的模块系统，它与 AMD 和 CommonJS 都兼容；</li>
</ul>
<p>语言级的模块系统在 2015 年的时候出现在了标准（ES6）中，此后逐渐发展，现在已经得到了所有主流浏览器和 Node.js 的支持；</p>
<p>模块可以相互加载，并可以使用特殊的指令 export 和 import 来交换功能，从另一个模块调用一个模块的函数；</p>
<ul>
<li>export 关键字标记了可以从当前模块外部访问的变量和函数；</li>
<li>import 关键字允许从其他模块导入功能；</li>
</ul>
<blockquote>
<p>Note: 由于模块支持特殊的关键字和功能，因此我们必须通过使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 特性（attribute）来告诉浏览器，此脚本应该被当作模块（module）来对待；同时模块只通过 <code>HTTP(s)</code> 工作，而非本地；</p>
</blockquote>
<p>对浏览器和服务端的 JavaScript 来说都有效的模块<strong>核心功能</strong>：</p>
<ul>
<li>模块始终在严格模式下运行，始终使用 “use strict”；</li>
<li>每个模块都有自己的顶级作用域（top-level scope）；一个模块中的顶级作用域变量和函数在其他脚本中是不可见的；模块应该 export 想要被外部访问的内容，并 import 所需要的内容；</li>
<li>模块代码仅在第一次导入时被解析，如果同一个模块被导入到多个其他位置，那么它的代码只会执行一次，即在第一次被导入时，然后将其导出（export）的内容提供给进一步的导入（importer）；</li>
<li>import.meta 对象包含关于当前模块的信息，其内容取决于其所在的环境；在浏览器环境中，它包含当前脚本的 URL，或者如果它是在 HTML 中的话，则包含当前页面的 URL；</li>
<li>在一个模块中，顶级 this 是 undefined；非模块脚本的顶级 this 是全局对象；</li>
</ul>
<blockquote>
<p>Note: 在浏览器中，可以通过将变量显式地分配给 <code>window</code> 的一个属性，使其成为窗口级别的全局变量，无论脚本是否带有 <code>type=&quot;module&quot;</code>；但对于模块，应该使用导入/导出而不是依赖全局变量；</p>
</blockquote>
<blockquote>
<p>Note: 顶层模块代码应该用于初始化，创建模块特定的内部数据结构；如果需要多次调用某些东西，则应该将其以函数的形式导出；</p>
</blockquote>
<p>只对浏览器中拥有 type=”module” 标识脚本有效的<strong>特定功能</strong>：</p>
<ul>
<li>模块脚本总是被延迟的，与 defer 特性对外部脚本和内联脚本的影响相同；</li>
<li>对于非模块脚本，async 特性（attribute）仅适用于外部脚本；异步脚本会在准备好后立即运行，独立于其他脚本或 HTML 文档；对于模块脚本，它也适用于内联脚本；</li>
<li>具有 type=”module” 的外部脚本（external script），相同 src 的外部脚本仅运行一次；且从另一个源获取的脚本，远程服务器必须提供表示允许获取的 header Access-Control-Allow-Origin；</li>
<li>在浏览器中，import 必须给出相对或绝对的 URL 路径，import 中不允许没有任何路径的模块，这种模块被称为“裸（bare）”模块；</li>
<li>旧时的浏览器不理解 type=”module”，未知类型的脚本会被忽略；</li>
</ul>
<blockquote>
<p>Note: 下载外部模块脚本 <code>&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt;</code> 不会阻塞 <code>HTML</code> 的处理，它们会与其他资源并行加载；模块脚本会等到 <code>HTML</code> 文档完全准备就绪（即使它们很小并且比 <code>HTML</code> 加载速度更快），然后才会运行；</p>
</blockquote>
<blockquote>
<p>Note: 使用 nomodule 特性来提供一个后备：<code>&lt;script nomodule&gt;...&lt;/script&gt;</code>；</p>
</blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/60a8a74f5eee">Cannot use import statement outside a module</a></li>
<li><a href="https://juejin.cn/post/6844904067651600391">CommonJS和ES6模块的区别</a></li>
</ul>
<h4 id="导出和导入"><a href="#导出和导入" class="headerlink" title="导出和导入"></a>导出和导入</h4><p>通常要明确列出需要导入的内容：</p>
<ul>
<li>打包工具中优化器（optimizer）就会从打包好的代码中删除那些未被使用的函数，从而使构建更小，这就是所谓的摇树（tree-shaking）；</li>
<li>导入的显式列表可以更好地概述代码结构：使用的内容和位置；使得代码支持重构，并且重构起来更容易；</li>
<li>明确列出要导入的内容会使得名称较短；</li>
</ul>
<p>模块提供了一个特殊的默认导出 export default 语法，以使“一个模块只做一件事”的方式看起来更好；每个文件最多只能有一个默认的导出，因此导出的实体可能没有名称；</p>
<table>
<thead>
<tr>
<th align="left">命名的导出</th>
<th align="left">默认的导出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">export class User {…}</td>
<td align="left">export default class User {…}</td>
</tr>
<tr>
<td align="left">import {User} from …</td>
<td align="left">import User from …</td>
</tr>
</tbody></table>
<p>从技术上讲，我们可以在一个模块中同时有默认的导出和命名的导出，但是通常不会混合使用它们，模块要么是命名的导出要么是默认的导出；</p>
<p>在某些情况下，default 关键词被用于引用默认的导出；默认引入可以使用不同的名称来导入相同的内容；</p>
<p>“重新导出（Re-export）”语法 export … from … 允许导入内容，并立即将其导出；export … from 与 import/export 相比的显著区别是重新导出的模块在当前文件中不可用；</p>
<blockquote>
<p>Note: 重新导出时，默认导出需要单独处理；</p>
</blockquote>
<blockquote>
<p>Note: 在代码块 <code>&#123;...&#125;</code> 中的 <code>import/export</code> 语句无效；</p>
</blockquote>
<p>导出方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="comment">// 导出数组</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> months = [<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>,<span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 const 声明的变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MODULES_YEAR = <span class="number">2015</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者统一导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; months, MODULES_YEAR, User &#125;; <span class="comment">// 导出变量列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出为其他名字</span></span><br><span class="line"><span class="keyword">export</span> &#123; sayHi <span class="keyword">as</span> hi, sayBye <span class="keyword">as</span> bye &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sayHi;</span><br><span class="line"><span class="keyword">export</span> &#123; sayHi <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; sayHi &#125; <span class="keyword">from</span> <span class="string">&#x27;./say.js&#x27;</span>; <span class="comment">// 重新导出 sayHi</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> User &#125; <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>; <span class="comment">// 重新导出 default</span></span><br><span class="line"><span class="comment">// 效果同，区别是在当前模块下重新导出无法使用</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; User <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新导出含有默认导出的模块</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>; <span class="comment">// 重新导出命名的导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>; <span class="comment">// 重新导出默认的导出</span></span><br></pre></td></tr></table></figure>

<p>导入方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; months, User &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有内容导入为一个对象</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> say <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 as 让导入具有不同的名字</span></span><br><span class="line"><span class="keyword">import</span> &#123; sayHi <span class="keyword">as</span> hi, sayBye <span class="keyword">as</span> bye &#125; <span class="keyword">from</span> <span class="string">&#x27;./say.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> User, sayHi &#125; <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有默认导入时导入为对象</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> user <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> User = user.default; <span class="comment">// 默认的导出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入模块（其代码，并运行），但不要将其任何导出赋值给变量</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;module&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>动态导入</strong></p>
<p>import(module) 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象，可以在代码中的任意位置调用这个表达式；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(modulePath)</span><br><span class="line">  .then(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> err);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 await</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(modulePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 含默认导出</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./say.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> say = obj.default;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 动态导入在常规脚本中工作时，它们不需要 script type=”module”；import 不是一个函数，只是一种特殊语法，恰好使用了括号；</p>
</blockquote>
<h4 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h4><p>一个 Proxy 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<ul>
<li>target 是要包装的对象，可以是任何东西，包括函数；</li>
<li>handler 代理配置：带有“捕捉器”（“traps”，即拦截操作的方法）的对象；</li>
</ul>
<p>对 proxy 进行操作，如果在 handler 中存在相应的捕捉器，则它将运行，并且 Proxy 有机会对其进行处理，否则将直接对 target 进行处理；Proxy 是一种特殊的“奇异对象（exotic object）”，它没有自己的属性；如果 handler 为空，则透明地将操作转发给 target；</p>
<p>对于对象的大多数操作，JavaScript 规范中有一个所谓的“内部方法”，它描述了最底层的工作方式，对于每个内部方法，此表中都有一个捕捉器，Proxy 捕捉器会拦截这些方法的调用；</p>
<table>
<thead>
<tr>
<th align="left">内部方法</th>
<th align="left">Handler 方法</th>
<th align="left">何时触发</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[[Get]]</td>
<td align="left">get</td>
<td align="left">读取属性</td>
</tr>
<tr>
<td align="left">[[Set]]</td>
<td align="left">set</td>
<td align="left">写入属性</td>
</tr>
<tr>
<td align="left">[[HasProperty]]</td>
<td align="left">has</td>
<td align="left">in 操作符</td>
</tr>
<tr>
<td align="left">[[Delete]]</td>
<td align="left">deleteProperty</td>
<td align="left">delete 操作符</td>
</tr>
<tr>
<td align="left">[[Call]]</td>
<td align="left">apply</td>
<td align="left">函数调用</td>
</tr>
<tr>
<td align="left">[[Construct]]</td>
<td align="left">construct</td>
<td align="left">new 操作符</td>
</tr>
<tr>
<td align="left">[[GetPrototypeOf]]</td>
<td align="left">getPrototypeOf</td>
<td align="left">Object.getPrototypeOf</td>
</tr>
<tr>
<td align="left">[[SetPrototypeOf]]</td>
<td align="left">setPrototypeOf</td>
<td align="left">Object.setPrototypeOf</td>
</tr>
<tr>
<td align="left">[[IsExtensible]]</td>
<td align="left">isExtensible</td>
<td align="left">Object.isExtensible</td>
</tr>
<tr>
<td align="left">[[PreventExtensions]]</td>
<td align="left">preventExtensions</td>
<td align="left">Object.preventExtensions</td>
</tr>
<tr>
<td align="left">[[DefineOwnProperty]]</td>
<td align="left">defineProperty</td>
<td align="left">Object.defineProperty, Object.defineProperties</td>
</tr>
<tr>
<td align="left">[[GetOwnProperty]]</td>
<td align="left">getOwnPropertyDescriptor</td>
<td align="left">Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries</td>
</tr>
<tr>
<td align="left">[[OwnPropertyKeys]]</td>
<td align="left">ownKeys</td>
<td align="left">Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys/values/entries</td>
</tr>
</tbody></table>
<p><strong>get 捕获器</strong></p>
<p>要拦截读取操作，可以添加 get(target, property, receiver) 捕获器；</p>
<ul>
<li>target 是目标对象，该对象被作为第一个参数传递给 new Proxy；</li>
<li>property 目标属性名；</li>
<li>receiver 如果目标属性是一个 getter 访问器属性，则 receiver 就是本次读取属性所在的 this 对象，通常是 proxy 对象本身；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">numbers = <span class="keyword">new</span> <span class="built_in">Proxy</span>(numbers, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[prop];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert( numbers[<span class="number">1</span>] ); <span class="comment">// 1</span></span><br><span class="line">alert( numbers[<span class="number">123</span>] ); <span class="comment">// 0（没有这个数组项）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 代理应该在所有地方都完全替代目标对象，目标对象被代理后，任何人都不应该再引用目标对象；</p>
</blockquote>
<p><strong>set 捕获器</strong></p>
<p>set(target, property, value, receiver)，当写入属性时 set 捕捉器被触发，其中 value 为目标属性的值；如果写入操作（setting）成功，set 捕捉器应该返回 true，否则返回 false（触发 TypeError）；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> onlyNumbers = [];</span><br><span class="line"></span><br><span class="line">onlyNumbers = <span class="keyword">new</span> <span class="built_in">Proxy</span>(onlyNumbers, &#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, prop, val</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 拦截写入属性操作</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> val == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">            target[prop] = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">onlyNumbers.push(<span class="number">1</span>); <span class="comment">// 添加成功</span></span><br><span class="line">onlyNumbers.push(<span class="number">2</span>); <span class="comment">// 添加成功</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Length is: &quot;</span> + onlyNumbers.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: &#x27;set&#x27; on proxy: trap returned falsish for property &#x27;2</span></span><br><span class="line">onlyNumbers.push(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>ownKeys 和 getOwnPropertyDescriptor 捕获器</strong></p>
<p>Object.keys，for..in 循环和大多数其他遍历对象属性的方法都使用内部方法 [[OwnPropertyKeys]]（由 ownKeys 捕捉器拦截) 来获取属性列表；</p>
<ul>
<li>Object.getOwnPropertyNames(obj) 返回非 Symbol 键；</li>
<li>Object.getOwnPropertySymbols(obj) 返回 Symbol 键；</li>
<li>Object.keys/values() 返回带有 enumerable 标志的非 Symbol 键/值；</li>
<li>for..in 循环遍历所有带有 enumerable 标志的非 Symbol 键，以及原型对象的键；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;Coley&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">    <span class="comment">// 使用 ownKeys 捕捉器拦截 for..in 对 user 的遍历</span></span><br><span class="line">    <span class="comment">// 一旦要获取属性列表就会被调用，可以返回不相干的属性</span></span><br><span class="line">    <span class="function"><span class="title">ownKeys</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// return Object.keys(target).filter(key =&gt; !key.startsWith(&#x27;_&#x27;));</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line">        <span class="comment">// 返回没有的属性，其描述符为空，没有 enumerable 标志，会被略过，需要 getOwnPropertyDescriptor 返回 enumerable 为 true；</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getOwnPropertyDescriptor</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 被每个属性调用</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>, <span class="comment">// false 屏蔽，使属性不可迭代</span></span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">            <span class="comment">/* ...其他标志，可能是 &quot;value:...&quot; */</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(user)); <span class="comment">// a, b, c</span></span><br></pre></td></tr></table></figure>

<p><strong>deleteProperty 捕获器</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    _password: <span class="string">&quot;***&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">checkPassword</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//对象方法必须能读取 _password</span></span><br><span class="line">        <span class="keyword">return</span> value === <span class="built_in">this</span>._password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop.startsWith(<span class="string">&quot;_&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Access denied&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> value = target[prop];</span><br><span class="line">        <span class="comment">// 内部方法可以读取内部属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&quot;function&quot;</span> ? value.bind(target) : value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 拦截属性删除</span></span><br><span class="line">        <span class="keyword">if</span> (prop.startsWith(<span class="string">&quot;_&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Access denied&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">delete</span> target[prop];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;get&quot; 不允许读取 _password</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(user._password); <span class="comment">// Error: Access denied</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;deleteProperty&quot; 不允许删除 _password</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> user._password; <span class="comment">// Error: Access denied</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>has 捕获器</strong></p>
<p>has 捕捉器会拦截 in 调用，因此可以实现 in 操作符来检查一个数字是否在 range 范围内；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">    start: <span class="number">1</span>,</span><br><span class="line">    end: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">range = <span class="keyword">new</span> <span class="built_in">Proxy</span>(range, &#123;</span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prop &gt;= target.start &amp;&amp; prop &lt;= target.end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> <span class="keyword">in</span> range); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">50</span> <span class="keyword">in</span> range); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>apply 捕获器</strong></p>
<p>apply(target, thisArg, args) 捕捉器能使代理以函数的方式被调用；</p>
<ul>
<li>target 是目标对象（函数也是对象）；</li>
<li>thisArg 是 this 的值；</li>
<li>args 是参数列表；</li>
</ul>
<p>普通的包装函数不会转发属性读取/写入操作或者任何其他操作；进行包装后，就失去了对原始函数属性的访问，例如 name，length 和其他属性；使用 Proxy 可以将所有操作都能被转发到原始函数；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">f, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(f, &#123;</span><br><span class="line">        <span class="function"><span class="title">apply</span>(<span class="params">target, thisArg, args</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> target.apply(thisArg, args), ms);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;user&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi = delay(sayHi, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sayHi.length); <span class="comment">// 1 (*) proxy 将“获取 length”的操作转发给目标对象</span></span><br><span class="line"></span><br><span class="line">sayHi(<span class="string">&quot;John&quot;</span>); <span class="comment">// Hello, John!（3 秒后）</span></span><br></pre></td></tr></table></figure>

<p>Reflect 是一个内建对象，可简化 Proxy 的创建；Reflect 对象使调用这些内部方法成为了可能，它的方法是内部方法的最小包装；</p>
<p>尤其是，Reflect 允许我们将操作符（new，delete，……）作为函数（Reflect.construct，Reflect.deleteProperty，……）执行调用；</p>
<p>此外，对于每个可被 Proxy 捕获的内部方法，在 Reflect 中都有一个对应的方法，其名称和参数与 Proxy 捕捉器相同；所以，如果一个捕捉器想要将调用转发给对象，则只需使用相同的参数调用 <code>Reflect.&lt;method&gt;</code> 就足够了；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">age</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(user, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.name); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(user, <span class="string">&quot;no-such-prop&quot;</span>);</span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(user, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">`GET <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver); <span class="comment">// (1)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, prop, val, receiver</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">`SET <span class="subst">$&#123;prop&#125;</span>=<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, val, receiver); <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = user.name; <span class="comment">// 显示 &quot;GET name&quot;</span></span><br><span class="line">user.name = <span class="string">&quot;Pete&quot;</span>; <span class="comment">// 显示 &quot;SET name=Pete&quot;</span></span><br></pre></td></tr></table></figure>

<p>当存在原型继承时，特别是访问继承对象的 get 访问器属性时，需要用到 receiver 参数，保证将正确的 this 传递给 getter；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  _name: <span class="string">&quot;Guest&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123; <span class="comment">// receiver = admin</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver); <span class="comment">// (*)</span></span><br><span class="line">    <span class="comment">// 或者 return Reflect.get(...arguments);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  __proto__: userProxy,</span><br><span class="line">  _name: <span class="string">&quot;Admin&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(admin.name); <span class="comment">// Admin</span></span><br></pre></td></tr></table></figure>

<p>Proxy 存在一些局限性：</p>
<ul>
<li>内建对象具有“内部插槽”，对这些对象的访问无法被代理；</li>
<li>私有类字段也是如此，因为它们也是在内部使用插槽实现的；因此，代理方法的调用必须具有目标对象作为 this 才能访问它们；</li>
<li>对象的严格相等性检查 === 无法被拦截；</li>
<li>性能：基准测试（benchmark）取决于引擎，但通常使用最简单的代理访问属性所需的时间也要长几倍；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用了“内部插槽”存储数据，而不通过 [[Get]]/[[Set]] 内部方法</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(map, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">    <span class="comment">// 会将将原始对象暴露给该方法，可能使其进一步传递并破坏其他代理功能；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value == <span class="string">&#x27;function&#x27;</span> ? value.bind(target) : value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.set(<span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">alert(proxy.get(<span class="string">&#x27;test&#x27;</span>)); <span class="comment">// 1（工作了！）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 出于历史原因，内建 <code>Array</code> 没有使用内部插槽，所以，代理数组时没有这种问题；</p>
</blockquote>
<p>一个可撤销的代理是可以被禁用的代理，<code>let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler)</code>；该调用返回一个带有 proxy 和 revoke 函数的对象以将其禁用；这样的代理会将操作转发给对象，并且我们可以随时将其禁用；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  data: <span class="string">&quot;Valuable data&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(object, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 proxy 传递到其他某处，而不是对象...</span></span><br><span class="line">alert(proxy.data); <span class="comment">// Valuable data</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍后，在我们的代码中</span></span><br><span class="line">revoke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy 不再工作（revoked）</span></span><br><span class="line">alert(proxy.data); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...<span class="string">&quot;abcde&quot;</span>];</span><br><span class="line"></span><br><span class="line">arr = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            prop = +prop + target.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy MDN 中文参考文档</a></li>
<li><a href="https://zh.javascript.info/proxy">JavaScript 现代教程-Proxy 和 Reflect</a></li>
</ul>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>调用 eval(code) 会运行代码字符串，并返回最后一条语句的结果；</p>
<p>严格模式下，eval 有属于自己的词法环境，因此我们不能从外部访问在 eval 中声明的函数和变量；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// script 中</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&quot;this&quot;</span>)); <span class="comment">// window</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(this); let x = 6&quot;</span>); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&quot;this&quot;</span>)); <span class="comment">// obj</span></span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">&quot;console.log(this); let x = 8;&quot;</span>); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">window</span>.eval(<span class="string">&quot;this&quot;</span>)); <span class="comment">// window</span></span><br><span class="line">        <span class="built_in">window</span>.eval(<span class="string">&quot;console.log(this); let x = 10;&quot;</span>); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.func();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>

<p>不建议使用 eval：</p>
<ul>
<li>如果 eval 中的代码没有使用外部变量，请以 window.eval(…) 的形式调用 eval；</li>
<li>如果 eval 中的代码需要访问局部变量，我们可以使用 new Function 替代 eval，并将它们作为参数传递；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;alert(a)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">f(<span class="number">5</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="柯里化（Currying）"><a href="#柯里化（Currying）" class="headerlink" title="柯里化（Currying）"></a>柯里化（Currying）</h4><p>柯里化（Currying）是一种关于函数的高阶技术，柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)；柯里化不会调用函数，它只是对函数进行转换；</p>
<p>柯里化更高级的实现，如 lodash 库的 <a href="https://lodash.com/docs#curry">_.curry</a>，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高级柯里化实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(args2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> curriedSum = curry(sum);</span><br><span class="line"></span><br><span class="line">alert( curriedSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) ); <span class="comment">// 6，仍然可以被正常调用</span></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>) ); <span class="comment">// 6，对第一个参数的柯里化</span></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) ); <span class="comment">// 6，全柯里化</span></span><br></pre></td></tr></table></figure>

<h4 id="Reference-Type"><a href="#Reference-Type" class="headerlink" title="Reference Type"></a>Reference Type</h4><p>为确保 obj.methed() 调用正常运行，JavaScript 中点 ‘.’ 返回的不是一个函数，而是一个特殊的 Reference Type 的值；</p>
<p>Reference Type 是 ECMA 中的一个“规范类型”，被用在 JavaScript 语言内部，因此不能直接使用它；</p>
<p>Reference Type 的值是一个三个值的组合 (base, name, strict)，其中：</p>
<ul>
<li>base 是对象；</li>
<li>name 是属性名；</li>
<li>strict 在 use strict 模式下为 true；</li>
</ul>
<p>当 () 被在 Reference Type 上调用时，它们会接收到关于对象和对象的方法的完整信息，然后可以设置正确的 this；Reference Type 是一个特殊的“中间人”内部类型，目的是从 . 传递信息给 () 调用；</p>
<p>任何例如赋值 func = obj.func 等其他的操作，都会将 Reference Type 作为一个整体丢弃掉，而会取 obj.func（一个函数）的值并继续传递，所以任何后续操作都“丢失”了 this；</p>
<p>this 的值仅在函数直接被通过点符号 obj.method() 或方括号 obj<a href="">‘method’</a> 语法（此处它们作用相同）调用时才被正确传递；除了方法调用之外的任何操作（如赋值 = 或 ||），都会把它转换为一个不包含允许设置 this 信息的普通值；</p>
<h4 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h4><p>BigInt 是一种特殊的数字类型，它提供了对任意长度整数的支持；创建 bigint 的方式有两种：在一个整数字面量后面加 n 或者调用 BigInt 函数，该函数从字符串、数字等中生成 bigint；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bigint = <span class="number">1234567890123456789012345678901234567890n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sameBigint = <span class="built_in">BigInt</span>(<span class="string">&quot;1234567890123456789012345678901234567890&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bigintFromNumber = <span class="built_in">BigInt</span>(<span class="number">10</span>); <span class="comment">// 与 10n 相同</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 对 <code>bigint</code> 的所有操作，返回的结果也是 <code>bigint</code>；不可以把 <code>bigint</code> 和常规数字类型混合使用；<code>BigInt</code> 不支持一元加法；</p>
</blockquote>
<blockquote>
<p>Note: 转换操作始终是静默的，绝不会报错，但是如果 <code>bigint</code> 太大而数字类型无法容纳，则会截断多余的位，因此我们应该谨慎进行此类转换；</p>
</blockquote>
<blockquote>
<p>Note: 由于 <code>number</code> 和 <code>bigint</code> 属于不同类型，它们可能在进行 <code>==</code> 比较时相等，但在进行 <code>===</code>（严格相等）比较时不相等；</p>
</blockquote>
<p>当在 if 或其他布尔运算中时，bigint 的行为类似于 number，在 if 中，bigint 0n 为假，其他值为 true；</p>
<p>目前并没有一个众所周知的好用的 polyfill，不过，<a href="https://github.com/GoogleChromeLabs/jsbi">JSBI</a> 库提出了另一种解决方案，该库使用自己的方法实现了大的数字，可以使用它们替代原生的 bigint；</p>
<h4 id="浏览器环境，规格"><a href="#浏览器环境，规格" class="headerlink" title="浏览器环境，规格"></a>浏览器环境，规格</h4><p>JavaScript 规范将能运行 JavaScript 的环境称为主机环境，每个环境都提供了特定于平台的功能；</p>
<p>文档对象模型（Document Object Model），简称 DOM，将所有页面内容表示为可以修改的对象；document 对象是页面的主要“入口点”，我们可以使用它来更改或创建页面上的任何内容；</p>
<p>另外也有一份针对 CSS 规则和样式表的、单独的规范 CSS Object Model (CSSOM)，这份规范解释了如何将 CSS 表示为对象，以及如何读写这些对象；</p>
<p>浏览器对象模型（Browser Object Model），简称 BOM，表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象；</p>
<h4 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h4><p>根据文档对象模型（DOM），每个 HTML 标签都是一个对象，嵌套的标签是闭合标签的“子标签（children）”，标签内的文本也是一个对象；</p>
<p>标签被称为 元素节点（或者仅仅是元素），并形成了树状结构：<code>&lt;html&gt;</code> 在根节点；元素内的文本形成 文本节点，被标记为 <code>＃text</code>；一个文本节点只包含一个字符串，它没有子项，并且总是树的叶子；</p>
<blockquote>
<p>Note: 由于历史原因，<code>&lt;head&gt;</code> 之前的空格和换行符均被忽略，如果我们在 <code>&lt;/body&gt;</code> 之后放置一些东西，那么它会被自动移动到 body 内，并处于 body 中的最下方，因为 HTML 规范要求所有内容必须位于 <code>&lt;body&gt;</code> 内；</p>
</blockquote>
<p>如果浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它；</p>
<ul>
<li>将文档中纯文本内容包装到 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code>，并添加<code>&lt;head&gt;</code>；</li>
<li>自动添加关闭标签；</li>
<li>自动为 <code>&lt;table&gt;</code> 创建缺失的 <code>&lt;tbody&gt;</code>；</li>
</ul>
<blockquote>
<p>Note: <code>HTML</code> 中的所有内容，包括注释，都会成为 <code>DOM</code> 的一部分，甚至 <code>HTML</code> 开头的 <code>&lt;!DOCTYPE...&gt;</code> 指令也是一个 <code>DOM</code> 节点；</p>
</blockquote>
<p>常用的4中 DOM 节点：</p>
<ul>
<li>document：DOM 的“入口点”；</li>
<li>元素节点：HTML 标签，树构建块；</li>
<li>文本节点：包含文本；</li>
<li>注释：有时我们可以将一些信息放入其中，它不会显示，但 JS 可以从 DOM 中读取它；</li>
</ul>
<blockquote>
<p>Tips: 浏览器开发者工具中，可以通过 <code>$0</code> 来进行操作最后选中的元素，先前选择的是 <code>$1</code>，<code>$2</code>…以此类推；如果存在引用 <code>DOM</code> 节点的变量，那么我们可以在控制台（Console）中使用命令 <code>inspect(node)</code>，来在元素（Elements）选项卡中查看它；</p>
</blockquote>
<ul>
<li><a href="http://software.hixie.ch/utilities/js/live-dom-viewer/">查看 DOM 结构在线工具</a></li>
</ul>
<h4 id="遍历-DOM"><a href="#遍历-DOM" class="headerlink" title="遍历 DOM"></a>遍历 DOM</h4><p>最顶层的 document 节点是 document.documentElement，这是对应 <code>&lt;html&gt;</code> 标签的 DOM 节点；document.body 对应 <code>&lt;body&gt;</code>，document.head 对应 <code>&lt;head&gt;</code>；</p>
<p><strong>访问子节点</strong></p>
<p>childNodes 集合列出了所有子节点，包括文本节点和注释节点；childNodes 实际上并不是一个数组，而是一个类数组的可迭代对象，成为 DOM 集合；</p>
<blockquote>
<p>Note: DOM 集合是只读的，且几乎所有的 DOM 集合都是实时的，即它们反映了 DOM 的当前状态；</p>
</blockquote>
<p>firstChild 和 lastChild 属性是访问第一个和最后一个子元素的快捷方式，还有一个特别的函数 elem.hasChildNodes() 用于检查节点是否有子节点；</p>
<p><strong>访问兄弟节点和父节点</strong></p>
<p>下一个兄弟节点在 nextSibling 属性中，上一个是在 previousSibling 属性中；通过 parentNode 来访问父节点；</p>
<p><strong>纯元素导航</strong></p>
<p>但希望操纵的是代表标签的和形成页面结构的元素节点时，使用：</p>
<ul>
<li>使用 children 访问那些作为元素节点的子代的节点；</li>
<li>firstElementChild，lastElementChild 访问标签子元素；</li>
<li>previousElementSibling，nextElementSibling 访问标签子元素；</li>
<li>parentElement 访问标签父节点；</li>
</ul>
<blockquote>
<p>Note: <code>parentElement</code> 属性返回的是“元素类型”的父节点，而 <code>parentNode</code> 返回的是“任何类型”的父节点，这些属性通常来说是一样的：它们都是用于获取父节点；除了 <code>document.documentElement</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="built_in">document</span>.documentElement.parentNode ); <span class="comment">// document</span></span><br><span class="line">alert( <span class="built_in">document</span>.documentElement.parentElement ); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意节点 elem</span></span><br><span class="line"><span class="keyword">while</span>(elem = elem.parentElement) &#123; <span class="comment">// 向上，直到 &lt;html&gt;</span></span><br><span class="line">  alert( elem );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="搜索：getElement，querySelector"><a href="#搜索：getElement，querySelector" class="headerlink" title="搜索：getElement，querySelector"></a>搜索：getElement<em>，querySelector</em></h4><p><strong>getElementById</strong></p>
<p>如果一个元素有 id 特性（attribute），那我们就可以使用 document.getElementById(id) 方法获取该元素；</p>
<blockquote>
<p>Note: 通过 <code>id</code> 命名的全局变量来访问元素，这是规范中考虑到兼容性描述的一种标准；但是这可能会造成命名冲突，不建议使用；</p>
</blockquote>
<p><strong>querySelector 和 querySelectorAll</strong></p>
<p>elem.querySelector(css) 调用会返回给定 CSS 选择器的第一个元素，elem.querySelectorAll(css)，返回 elem 中与给定 CSS 选择器匹配的所有元素，都支持 css 伪类；</p>
<p><strong>matches</strong></p>
<p>elem.matches(css) 不会查找任何内容，它只会检查 elem 是否与给定的 CSS 选择器匹配，它返回 true 或 false；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> <span class="built_in">document</span>.body.children) &#123;</span><br><span class="line">  <span class="keyword">if</span> (elem.matches(<span class="string">&#x27;a[href$=&quot;zip&quot;]&#x27;</span>)) &#123;</span><br><span class="line">    alert(<span class="string">&quot;The archive reference: &quot;</span> + elem.href );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>closest</strong></p>
<p>elem.closest(css) 方法会查找与 CSS 选择器匹配的最近的祖先，包括 elem 本身；</p>
<p><strong>getElementsBy*</strong></p>
<ul>
<li>elem.getElementsByTagName(tag) 查找具有给定标签的元素，并返回它们的集合，tag 参数也可以是对于任何标签的通配符 <code>*</code>；</li>
<li>elem.getElementsByClassName(className) 返回具有给定CSS类的元素；</li>
<li>document.getElementsByName(name) 返回在文档范围内具有给定 name 特性的元素；</li>
</ul>
<blockquote>
<p>Note: 所有的 <code>getElementsBy*</code> 方法都会返回一个 实时的（live）集合，这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”；而 <code>querySelectorAll</code> 返回的是一个静态的集合；</p>
</blockquote>
<h4 id="节点属性：type，tag-和-content"><a href="#节点属性：type，tag-和-content" class="headerlink" title="节点属性：type，tag 和 content"></a>节点属性：type，tag 和 content</h4><p>EventTarget 是根的“抽象（abstract）”类，该类的对象从未被创建；它作为一个基础，以便让所有 DOM 节点都支持所谓的“事件（event）”；</p>
<p>Node 也是一个“抽象”类，充当 DOM 节点的基础；它提供了树的核心功能：parentNode，nextSibling，childNodes 等（它们都是 getter）；Node 类的对象从未被创建，但是有一些继承自它的具体的节点类，例如：文本节点的 Text，元素节点的 Element，注释节点的 Comment；</p>
<p>Element 是 DOM 元素的基本类；它提供了元素级的导航（navigation），例如 nextElementSibling，children，以及像 getElementsByTagName 和 querySelector 这样的搜索方法；浏览器中不仅有 HTML，还会有 XML 和 SVG，Element 类充当更多特定类的基本类：SVGElement，XMLElement 和 HTMLElement；</p>
<blockquote>
<p>Note: <code>document</code> 是 <code>HTMLDocument</code> 类的一个实例；</p>
</blockquote>
<p><strong>nodeType 属性</strong></p>
<p>nodeType 属性提供了另一种“过时的”用来获取 DOM 节点类型的方法；该属性是一个只读的数值型值：</p>
<ul>
<li>对于元素节点 elem.nodeType == 1；</li>
<li>对于文本节点 elem.nodeType == 3；</li>
<li>对于 document 对象 elem.nodeType == 9；</li>
</ul>
<p><strong>标签：nodeName 和 tagName</strong></p>
<p>可以从 nodeName 或者 tagName 属性中读取一个 DOM 节点的标签名；tagName 属性仅适用于 Element 节点；nodeName 是为任意 Node 定义的，对于元素，它的意义与 tagName 相同，对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="built_in">document</span>.body.nodeName ); <span class="comment">// BODY</span></span><br><span class="line">alert( <span class="built_in">document</span>.body.tagName ); <span class="comment">// BODY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for comment</span></span><br><span class="line">alert( <span class="built_in">document</span>.body.firstChild.tagName ); <span class="comment">// undefined（不是一个元素）</span></span><br><span class="line">alert( <span class="built_in">document</span>.body.firstChild.nodeName ); <span class="comment">// #comment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for document</span></span><br><span class="line">alert( <span class="built_in">document</span>.tagName ); <span class="comment">// undefined（不是一个元素）</span></span><br><span class="line">alert( <span class="built_in">document</span>.nodeName ); <span class="comment">// #document</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>浏览器有两种处理文档（document）的模式：HTML 和 XML；通常，HTML 模式用于网页，只有在浏览器接收到带有 header Content-Type: application/xml+xhtml 的 XML-document 时，XML 模式才会被启用；</p>
</blockquote>
<p><strong>innerHTML：内容</strong></p>
<p>innerHTML 属性允许将元素中的 HTML 获取为字符串形式；innerHTML 属性仅对元素节点有效；</p>
<blockquote>
<p>Note: 如果 <code>innerHTML</code> 将一个 <code>&lt;script&gt;</code> 标签插入到 <code>document</code> 中，它会成为 <code>HTML</code> 的一部分，但是不会执行；</p>
</blockquote>
<blockquote>
<p>Note: <code>innerHTML+=</code> 会进行完全重写，该操作会先移除旧内容，然后写入新内容，因此其内部的图片和其他资源都将重写加载；同时大多浏览器在 innerHTML 内容改变后会取消文字选中状态；</p>
</blockquote>
<p><strong>outerHTML：元素的完整 HTML</strong></p>
<p>outerHTML 属性包含了元素的完整 HTML，就像 innerHTML 加上元素本身一样；与 innerHTML 不同，写入 outerHTML 不会改变元素，而是在 DOM 中替换它；</p>
<p><strong>nodeValue/data：文本节点内容</strong></p>
<p>对于元素节点以外的其他节点类型，例如文本节点，具有它们的对应项：nodeValue 和 data 属性，这两者在实际使用中几乎相同，只有细微规范上的差异；因此可以将信息或模板说明嵌入到 HTML 中的注释中，然后从 data 属性中读取它，并处理嵌入的指令；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  Hello</span><br><span class="line">  <span class="comment">&lt;!-- Comment --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> text = <span class="built_in">document</span>.body.firstChild;</span></span><br><span class="line"><span class="javascript">    alert(text.data); <span class="comment">// Hello</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> comment = text.nextSibling;</span></span><br><span class="line"><span class="javascript">    alert(comment.data); <span class="comment">// Comment</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>textContent：纯文本</strong></p>
<p>textContent 提供了对元素内的 文本 的访问权限：仅文本，去掉所有 <code>&lt;tags&gt;</code>；textContent 允许以安全方式写入文本，所有符号（symbol）均按字面意义处理；</p>
<p><strong>hidden 属性</strong></p>
<p>“hidden” 特性（attribute）和 DOM 属性（property）指定元素是否可见，从技术上来说，hidden 与 style=”display:none” 做的是相同的事，但 hidden 写法更简洁；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Both divs below are hidden<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span>With the attribute &quot;hidden&quot;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>JavaScript assigned the property &quot;hidden&quot;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  elem.hidden = <span class="literal">true</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="特性和属性（Attributes-and-properties）"><a href="#特性和属性（Attributes-and-properties）" class="headerlink" title="特性和属性（Attributes and properties）"></a>特性和属性（Attributes and properties）</h4><p>当浏览器加载页面时，它会“读取”（或者称之为：“解析”）HTML 并从中生成 DOM 对象；对于元素节点，大多数标准的 HTML 特性（attributes）会自动变成 DOM 对象的属性（properties）；</p>
<blockquote>
<p>Note: <code>DOM</code> 节点是常规的 JavaScript 对象，<code>DOM</code> 属性和方法的行为就像常规的 Javascript 对象一样；</p>
</blockquote>
<p>在 HTML 中，标签可能拥有特性（attributes），当浏览器解析 HTML 文本，并根据标签创建 DOM 对象时，浏览器会辨别 标准的 特性并以此创建 DOM 属性；</p>
<p>如果一个特性不是标准的，那么就没有相对应的 DOM 属性，所有特性都可以通过使用以下方法进行访问：</p>
<ul>
<li>elem.hasAttribute(name) 检查特性是否存在；</li>
<li>elem.getAttribute(name) 获取这个特性值；</li>
<li>elem.setAttribute(name, value) 设置这个特性值；</li>
<li>elem.removeAttribute(name) 移除这个特性；</li>
</ul>
<p>或者也可以使用 elem.attributes 读取所有特性：属于内建 Attr 类的对象的集合，attributes 集合是可迭代对象，该对象将所有元素的特性（标准和非标准的）作为 name 和 value 属性存储在对象中；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span> <span class="attr">about</span>=<span class="string">&quot;Elephant&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    alert( elem.getAttribute(<span class="string">&#x27;About&#x27;</span>) ); <span class="comment">// (1) &#x27;Elephant&#x27;，读取</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    elem.setAttribute(<span class="string">&#x27;Test&#x27;</span>, <span class="number">123</span>); <span class="comment">// (2) 写入</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    alert( elem.outerHTML ); <span class="comment">// (3) 查看特性是否在 HTML 中（在）</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">of</span> elem.attributes) &#123; <span class="comment">// (4) 列出所有</span></span></span><br><span class="line"><span class="javascript">      alert( <span class="string">`<span class="subst">$&#123;attr.name&#125;</span> = <span class="subst">$&#123;attr.value&#125;</span>`</span> );</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外 HTML 特性的名字是大小写不敏感的，其次特性的值总是字符串类型的；</p>
<p>当一个标准的特性或者属性被改变，对应的属性或者特性也会自动更新；</p>
<blockquote>
<p>Note: 但也有例外，如 <code>input.value</code> 只能从特性同步到属性，可用于用户行为导致 <code>value</code> 的更改，然后在这些操作之后，从 <code>HTML</code> 的特性中恢复“原始”值；</p>
</blockquote>
<p>其他特例：</p>
<ul>
<li>input.checked 属性（对于 checkbox 的）是布尔型的；</li>
<li>style 特性是字符串类型的，但 style 属性是一个对象；</li>
<li>href DOM 属性一直是一个 完整的 URL，即使该特性包含一个相对路径或者包含一个 #hash；</li>
</ul>
<p><strong>非标准的特性，dataset</strong></p>
<p>非标准的特性常常用于将自定义的数据从 HTML 传递到 JavaScript，或者用于为 JavaScript “标记” HTML 元素；</p>
<p>以 “data-” 开头的特性均被保留供开发者使用，并且它们可在 dataset 属性中使用；多个单词组合的特性，会转成对应的驼峰命名的属性；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">data-about</span>=<span class="string">&quot;Elephants&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  alert(<span class="built_in">document</span>.body.dataset.about); <span class="comment">// Elephants</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改文档（document）"><a href="#修改文档（document）" class="headerlink" title="修改文档（document）"></a>修改文档（document）</h4><p><strong>创建元素</strong></p>
<ul>
<li>document.createElement(tag) 用给定的标签创建一个新 元素节点（element node）；</li>
<li>document.createTextNode(text) 用给定的文本创建一个 文本节点；</li>
</ul>
<p><strong>插入元素</strong></p>
<p>字符串被以一种安全的方式插入到页面中，特殊符号都会被作转义处理来保证正确显示；</p>
<ul>
<li>node.append(…nodes or strings) 在 node 末尾插入节点或字符串；</li>
<li>node.prepend(…nodes or strings) 在 node 开头插入节点或字符串；</li>
<li>node.before(…nodes or strings) 在 node 前面插入节点或字符串；</li>
<li>node.after(…nodes or strings) 在 node 后面插入节点或字符串；</li>
<li>node.replaceWith(…nodes or strings) 将 node 替换为给定的节点或字符串；</li>
</ul>
<p>旧方法都会返回插入/删除的节点：</p>
<ul>
<li>parentElem.appendChild(node) 将 node 附加为 parentElem 的最后一个子元素；</li>
<li>parentElem.insertBefore(node, nextSibling) 在 parentElem 的 nextSibling 前插入 node；</li>
<li>parentElem.replaceChild(node, oldChild) 将 parentElem 的后代中的 oldChild 替换为 node；</li>
<li>parentElem.removeChild(node) 从 parentElem 中删除 node（假设 node 为 parentElem 的后代）；</li>
</ul>
<p><strong>插入代码块</strong></p>
<p>elem.insertAdjacentHTML(where, html) 方法第一个参数是代码字（code word），指定相对于 elem 的插入位置，第二个参数是 HTML 字符串，该字符串会被“作为 HTML” 插入；</p>
<ul>
<li>“beforebegin” 将 html 插入到 elem 前插入；</li>
<li>“afterbegin” 将 html 插入到 elem 开头；</li>
<li>“beforeend” 将 html 插入到 elem 末尾；</li>
<li>“afterend” 将 html 插入到 elem 后；</li>
</ul>
<p>elem.insertAdjacentText(where, text) 语法一样，但是将 text 字符串“作为文本”插入而不是作为 HTML；elem.insertAdjacentElement(where, elem) 语法一样，但是插入的是一个元素；</p>
<p><strong>移除节点</strong></p>
<p>可以使用 node.remove() 移除一个节点；或者通过插入方法移动节点；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span>&gt;</span>First<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;second&quot;</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 无需调用 remove</span></span></span><br><span class="line"><span class="javascript">  second.after(first); <span class="comment">// 获取 #second，并在其后面插入 #first</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>克隆节点</strong></p>
<p>调用 elem.cloneNode(true) 来创建元素的一个“深”克隆，具有所有特性（attribute）和子元素，如果我们调用 elem.cloneNode(false)，那克隆就不包括子元素；</p>
<p><strong>DocumentFragment</strong></p>
<p>DocumentFragment 是一个特殊的 DOM 节点，用作来传递节点列表的包装器（wrapper）；</p>
<p><strong>document.write</strong></p>
<p>调用 document.write(html) 意味着将 html “就地马上”写入页面，html 字符串可以是动态生成的，所以它很灵活，可以使用 JavaScript 创建一个完整的页面并对其进行写入；</p>
<p>document.write 调用只在页面加载时工作，如果页面加载完成后调用，则现有文档内容将被擦除；</p>
<p>从技术上讲，当在浏览器正在读取（“解析”）传入的 HTML 时调用 document.write 方法来写入一些东西，浏览器会像它本来就在 HTML 文本中那样使用它，因为不涉及 DOM 修改，所以运行起来出奇的快；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除元素内子元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (elem.firstChild) &#123;</span><br><span class="line">    elem.firstChild.remove();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">  elem.innerHTML = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 根据规范，<code>&lt;table&gt;</code> 只允许特定于表格的标签，浏览器会把 <code>&lt;table&gt;</code> 内的文本添加到了表格前面；</p>
</blockquote>
<h4 id="样式和类"><a href="#样式和类" class="headerlink" title="样式和类"></a>样式和类</h4><p>通常有两种设置元素样式的方式：</p>
<ul>
<li>在 CSS 中创建一个类，并添加它：<code>&lt;div class=&quot;...&quot;&gt;</code>；</li>
<li>将属性直接写入 style：<code>&lt;div style=&quot;...&quot;&gt;</code>；</li>
</ul>
<p>属性 className 对应于 “class” 特性；如果对 elem.className 进行赋值，它将替换类中的整个字符串；classList 是一个特殊的对象，它具有 add/remove/toggle 单个类的方法；</p>
<ul>
<li>elem.classList.add/remove(class) 添加/移除类；</li>
<li>elem.classList.toggle(class) 如果类不存在就添加类，存在就移除它；</li>
<li>elem.classList.contains(class) 检查给定类，返回 true/false；</li>
</ul>
<p>elem.style 属性是一个对象，它对应于 “style” 特性（attribute）中所写的内容，对于多词（multi-word）属性，使用驼峰式 camelCase；</p>
<blockquote>
<p>Note: 像 <code>-moz-border-radius</code> 和 <code>-webkit-border-radius</code> 这样的浏览器前缀属性，也遵循同样的规则：连字符 <code>-</code> 表示大写；</p>
</blockquote>
<p>我们使用 style.* 来对各个样式属性进行赋值，使用特殊属性 style.cssText 以字符串的形式设置完整的样式；</p>
<h4 id="计算样式：getComputedStyle"><a href="#计算样式：getComputedStyle" class="headerlink" title="计算样式：getComputedStyle"></a>计算样式：getComputedStyle</h4><p>style 属性仅对 “style” 特性（attribute）值起作用，而没有任何 CSS 级联（cascade）；</p>
<p>使用 getComputedStyle(element, [pseudo]) 方法获取元素的计算属性；其中 element 是需要被读取样式值的元素，pseudo 伪元素（如果需要），空字符串或无参数则意味着元素本身，结果是一个具有样式属性解析值的对象；</p>
<blockquote>
<p>Note: 计算 (computed) 样式值是所有 CSS 规则和 CSS 继承都应用后的值，这是 CSS 级联（cascade）的结果；解析 (resolved) 样式值是最终应用于元素的样式值值，浏览器将使用计算（computed）值，并使所有单位均为固定的，且为绝对单位；</p>
</blockquote>
<blockquote>
<p>Note: JavaScript 看不到 <code>:visited</code> 所应用的样式；此外，CSS 中也有一个限制，即禁止在 <code>:visited</code> 中应用更改几何形状的样式，这是为了确保一个不好的页面无法测试链接是否被访问，进而窥探隐私；</p>
</blockquote>
<h4 id="元素大小和滚动"><a href="#元素大小和滚动" class="headerlink" title="元素大小和滚动"></a>元素大小和滚动</h4><blockquote>
<p>Note: 一些浏览器（并非全部）通过从内容（上面标记为 “content width”）中获取空间来为滚动条保留空间；</p>
</blockquote>
<p>offsetParent 是最接近的 CSS 定位的祖先，或者是 td，th，table，body；</p>
<blockquote>
<p>Note: 有以下几种情况下，<code>offsetParent</code> 的值为 <code>null</code>：</p>
<ul>
<li>对于未显示的元素（display:none 或者不在文档中）；</li>
<li>对于 <code>&lt;body&gt;</code> 与 <code>&lt;html&gt;</code>；</li>
<li>对于带有 position:fixed 的元素；</li>
</ul>
</blockquote>
<p>属性 offsetLeft/offsetTop 提供相对于 offsetParent 左上角的 x/y 坐标；<br>属性 offsetWidth/offsetHeight 提供了元素的“外部” width/height，包括边框的完整大小；</p>
<blockquote>
<p>Note: 如果一个元素（或其任何祖先）具有 <code>display:none</code> 或不在文档中，则所有几何属性均为零（或 offsetParent 为 null）；</p>
</blockquote>
<p>属性 clientLeft/clientTop 在元素内部，用于测量内侧与外侧的相对坐标，大多数情况下其数值等于边框宽高，但当滚动条在左侧时，clientLeft 等于左边框宽加滚动条宽度；</p>
<p>属性 clientWidth/clientHeight 包括了 “content width” 和 “padding”，但不包括滚动条宽度；</p>
<p>属性 scrollWidth/scrollHeight 是内容区域的完整内部宽度/高度，包括滚动出的部分；<br>属性 scrollLeft/scrollTop 是元素的隐藏、滚动部分的 width/height；</p>
<blockquote>
<p>Tips: 大多数几何属性是只读的，但是 <code>scrollLeft/scrollTop</code> 是可修改的，并且浏览器会滚动该元素；</p>
</blockquote>
<blockquote>
<p>Note: CSS <code>width/height</code> 取决于另一个属性：<code>box-sizing</code>，它定义了“什么是” CSS 宽度和高度，出于 CSS 的目的而对 <code>box-sizing</code> 进行的更改可能会破坏此类 JavaScript 操作，其次，CSS 的 <code>width/height</code> 可能是 <code>auto</code>，有时滚动条也会造成一定的影响；因此通常不从 CSS 中获取 <code>width/height</code>；</p>
</blockquote>
<blockquote>
<p>Tips: 可以创建一个带有滚动条的元素，但是没有边框（border）和内边距（padding），其全宽度 <code>offsetWidth</code> 和内部内容宽度 <code>clientWidth</code> 之间的差值就是滚动条的宽度；</p>
</blockquote>
<ul>
<li><a href="https://zh.javascript.info/size-and-scroll">JavaScript 现代教程-元素大小和滚动文档</a></li>
</ul>
<h4 id="Window-大小和滚动"><a href="#Window-大小和滚动" class="headerlink" title="Window 大小和滚动"></a>Window 大小和滚动</h4><p>可以使用 document.documentElement 的 clientWidth/clientHeight 获取窗口宽高；浏览器也支持像 window.innerWidth/innerHeight 这样的属性，window.innerWidth/innerHeight 包括了滚动条；</p>
<blockquote>
<p>Tips: <code>window.innerWidth - document.documentElement.clientWidth</code> 也可获得滚动条宽度；</p>
</blockquote>
<p>为了可靠地获得完整的文档高度，我们应该采用以下这些属性的最大值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollHeight = <span class="built_in">Math</span>.max(</span><br><span class="line">  <span class="built_in">document</span>.body.scrollHeight, <span class="built_in">document</span>.documentElement.scrollHeight,</span><br><span class="line">  <span class="built_in">document</span>.body.offsetHeight, <span class="built_in">document</span>.documentElement.offsetHeight,</span><br><span class="line">  <span class="built_in">document</span>.body.clientHeight, <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;Full document height, with scrolled out part: &#x27;</span> + scrollHeight);</span><br></pre></td></tr></table></figure>

<p>使用 window.pageXOffset/pageYOffset 属性获取当前滚动位置；使用特殊方法 window.scrollBy(x,y) 和 window.scrollTo(pageX,pageY) 实现页面滚动；</p>
<ul>
<li>方法 scrollBy(x,y) 将页面滚动至 相对于当前位置的 (x, y) 位置；</li>
<li>方法 scrollTo(pageX,pageY) 将页面滚动至 绝对坐标，使得可见部分的左上角具有相对于文档左上角的坐标 (pageX, pageY)；</li>
<li>对 elem.scrollIntoView(top) 的调用将滚动页面以使 elem 可见；如果 top=true（默认值），页面滚动，使 elem 出现在窗口顶部，元素的上边缘将与窗口顶部对齐，如果 top=false，页面滚动，使 elem 出现在窗口底部，元素的底部边缘将与窗口底部对齐；</li>
</ul>
<blockquote>
<p>Tips: 使用 <code>elem.style.overflow = &quot;hidden&quot;</code> 禁止滚动；</p>
</blockquote>
<h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><p>大多数 JavaScript 方法处理的是以下两种坐标系中的一个：</p>
<ul>
<li>相对于窗口：类似于 position:fixed，从窗口的顶部/左侧边缘计算得出（clientX/clientY）；</li>
<li>相对于文档：与文档根（document root）中的 position:absolute 类似，从文档的顶部/左侧边缘计算得出（pageX/pageY）；</li>
</ul>
<p>clientX/clientY 窗口相对坐标随着页面滚动会发生变化，因为同一个点越来越靠近窗口左侧/顶部；<br>pageX/pageY 元素在文档中的相对坐标保持不变，从文档顶部（现在已滚动出去）开始计算；</p>
<p>方法 elem.getBoundingClientRect() 返回最小矩形的窗口坐标，该矩形将 elem 作为内建 DOMRect 类的对象；包括以下属性：</p>
<ul>
<li>x/y：矩形原点相对于窗口的 X/Y 坐标；</li>
<li>width/height：矩形的 width/height（可以为负）；</li>
<li>top/bottom：顶部/底部矩形边缘的 Y 坐标；</li>
<li>left/right：左/右矩形边缘的 X 坐标；</li>
</ul>
<blockquote>
<p>Note: 由于历史原因，IE 浏览器不支持 x/y 属性；</p>
</blockquote>
<p>对 document.elementFromPoint(x, y) 的调用会返回在窗口坐标 (x, y) 处嵌套最多（the most nested）的元素；只对在可见区域内的坐标 (x,y) 起作用，对于在窗口之外的坐标，elementFromPoint 返回 null；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> centerX = <span class="built_in">document</span>.documentElement.clientWidth / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> centerY = <span class="built_in">document</span>.documentElement.clientHeight / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> elem = <span class="built_in">document</span>.elementFromPoint(centerX, centerY);</span><br><span class="line">elem.style.background = <span class="string">&quot;red&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取元素的文档坐标</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCoords</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> box = elem.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    top: box.top + <span class="built_in">window</span>.pageYOffset,</span><br><span class="line">    right: box.right + <span class="built_in">window</span>.pageXOffset,</span><br><span class="line">    bottom: box.bottom + <span class="built_in">window</span>.pageYOffset,</span><br><span class="line">    left: box.left + <span class="built_in">window</span>.pageXOffset</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>当 HTML 的加载和处理均完成，DOM 被完全构建完成时触发 DOMContentLoaded 事件；当一个 CSS 动画完成时会触发 transitionend 事件；</p>
<p><strong>事件处理程序</strong></p>
<p>为了对事件作出响应，可以分配一个在事件发生时运行的函数处理程序（handler）；处理程序可以设置在 HTML 中名为 <code>on&lt;event&gt;</code> 的特性（attribute）中，也可以使用 DOM 属性（property）<code>on&lt;event&gt;</code> 来分配处理程序；</p>
<p>如果一个处理程序是通过 HTML 特性（attribute）分配的，那么随后浏览器读取它，并从特性的内容创建一个新函数，并将这个函数写入 DOM 属性（property）；</p>
<p>每个事件只有一个 <code>on&lt;event&gt;</code> 属性，无法分配更多事件处理程序；通过为 <code>on&lt;event&gt;</code> 属性赋值 null 可以移除处理程序；当浏览器读取 HTML 特性（attribute）时，浏览器将会使用特性中的内容（函数调用或多个语句）创建一个处理程序；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js 中方法不加括号</span></span><br><span class="line">button.onclick = sayThanks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html 中方法要加括号</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;button&quot; id=&quot;button&quot; onclick=&quot;sayThanks()&quot;&gt;</span></span><br><span class="line"></span><br><span class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  sayThanks(); <span class="comment">// &lt;-- 特性（attribute）中的内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 处理程序中的 this 的值是对应的元素，就是处理程序所在的那个元素；</p>
</blockquote>
<blockquote>
<p>因为特性总是字符串的，函数变成了一个字符串，因此使用 setAttribute 设置处理程序会失效；</p>
</blockquote>
<p>使用特殊方法 addEventListener 和 removeEventListener 来分配管理多个处理程序；</p>
<p>element.addEventListener(event, handler[, options]) 参数分别为 event 事件名，handler 处理程序，options 附加可选对象；如果同一事件设置有多个事件处理程序，并通过 addEventListener 分配给了相同的元素，则它们的运行顺序与创建顺序相同；</p>
<p>options 具有以下属性：</p>
<ul>
<li>once：如果为 true，那么会在被触发后自动删除监听器；</li>
<li>capture：事件处理的阶段，true 为捕获阶段，false 为冒泡阶段（默认）；</li>
<li>passive：如果为 true，那么处理程序将不会调用 preventDefault()；</li>
</ul>
<blockquote>
<p>Note: 由于历史原因，options 也可以是 false/true，它与 {capture: false/true} 相同；</p>
</blockquote>
<blockquote>
<p>Note: <code>passive: true</code> 选项告诉浏览器（特别是移动端浏览器），处理程序不会取消默认行为，然后浏览器先处理所有处理程序，再执行执行默认行为以提供最大程度的流畅体验，并通过某种方式处理事件；</p>
</blockquote>
<p>element.removeEventListener(event, handler[, options]) 要移除处理程序，我们需要传入与分配的函数完全相同的函数，以及同一阶段；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">elem.addEventListener( <span class="string">&quot;click&quot;</span> , <span class="function">() =&gt;</span> alert(<span class="string">&#x27;Thanks!&#x27;</span>));</span><br><span class="line"><span class="comment">// 无法移除两个不同的函数对象</span></span><br><span class="line">elem.removeEventListener( <span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> alert(<span class="string">&#x27;Thanks!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 对于某些事件，只能通过 <code>addEventListener</code> 设置处理程序，如 DOMContentLoaded 事件；</p>
</blockquote>
<p><strong>事件对象</strong></p>
<p>当事件发生时，浏览器会创建一个 event 对象，将详细信息放入其中，并将其作为参数传递给处理程序；</p>
<p>event 对象的一些属性：</p>
<ul>
<li>event.type 事件类型</li>
<li>event.currentTarget 处理事件的元素，同 this；</li>
</ul>
<blockquote>
<p>Tips: <code>event</code> 对象在 HTML 处理程序中也可用，<code>&lt;input type=&quot;button&quot; onclick=&quot;alert(event.type)&quot; value=&quot;Event type&quot;&gt;</code>；</p>
</blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/1a8a7e698447">window.onload 和 DOMContentLoaded 的区别</a></li>
</ul>
<h4 id="冒泡和捕获"><a href="#冒泡和捕获" class="headerlink" title="冒泡和捕获"></a>冒泡和捕获</h4><p>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序；</p>
<p>通过 event.target 属性，父元素上的处理程序始终可以获取事件实际发生位置的详细信息；event.target 与 event.currentTarget 有区别，event.target 是引发事件的“目标”元素，它在冒泡过程中不会发生变化，event.currentTarget 是“当前”元素，其中有一个当前正在运行的处理程序</p>
<p>冒泡事件从目标元素开始向上冒泡。通常，它会一直上升到 <code>&lt;html&gt;</code>，然后再到 document 对象，有些事件甚至会到达 window，它们会调用路径上所有的处理程序；但是任意处理程序都可以决定事件已经被完全处理，并通过调用 event.stopPropagation() 方法停止冒泡；</p>
<p>还有一个 event.stopImmediatePropagation() 方法，可以用于停止冒泡，并阻止当前元素上的处理程序运行，使用该方法之后，其他处理程序就不会被执行；</p>
<p>DOM 事件标准描述了事件传播的 3 个阶段：</p>
<ul>
<li>捕获阶段（Capturing phase）事件（从 Window）向下走近元素；</li>
<li>目标阶段（Target phase）事件到达目标元素；</li>
<li>冒泡阶段（Bubbling phase）事件从元素上开始冒泡；</li>
</ul>
<p>事件首先通过祖先链向下到达元素（捕获阶段），然后到达目标（目标阶段），最后上升（冒泡阶段），在途中调用处理程序；</p>
<blockquote>
<p>Tips: 通过属性 <code>event.eventPhase</code> 可以获得捕获事件的当前阶段（capturing=1，target=2，bubbling=3）；</p>
</blockquote>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>捕获和冒泡允许我们实现一种被称为事件委托的强大的事件处理模式；如果有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序，而是将单个处理程序放在它们的共同祖先上；</p>
<p>还可以使用事件委托将“行为（behavior）”以声明方式添加到具有特殊特性（attribute）和类的元素中，将自定义特性添加到描述其行为的元素，然后用文档范围级的处理程序追踪事件，如果事件发生在具有特定特性的元素上则执行行为（action）；</p>
<p>优点：</p>
<ul>
<li>简化初始化并节省内存：无需添加许多处理程序；</li>
<li>更少的代码：添加或移除元素时，无需添加/移除处理程序；</li>
<li>DOM 修改 ：我们可以使用 innerHTML 等，来批量添加/移除元素；</li>
</ul>
<p>缺点：</p>
<ul>
<li>事件必须冒泡，有些事件不会冒泡就无法使用事件委托；</li>
<li>委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应；</li>
</ul>
<h4 id="浏览器默认行为"><a href="#浏览器默认行为" class="headerlink" title="浏览器默认行为"></a>浏览器默认行为</h4><p>许多事件会自动触发浏览器执行某些行为，如链接点击，表单提交等；可以通过两种方式阻止浏览器默认行为：</p>
<ol>
<li>使用 event 对象的 event.preventDefault() 方法；</li>
<li>针对 <code>on&lt;event&gt;</code> 事件处理程序，返回 false 也同样有效；</li>
</ol>
<blockquote>
<p>Note: 事件处理程序返回的值通常会被忽略，唯一的例外是从使用 <code>on&lt;event&gt;</code> 分配的处理程序中返回的 <code>return false</code>；</p>
</blockquote>
<p>如果默认行为被阻止，那么 event.defaultPrevented 属性为 true，否则为 false；有时可以使用 event.defaultPrevented 来代替 event.stopPropagation()，来通知其他事件处理程序，该事件已经被处理；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Right-click for the document menu (added a check for event.defaultPrevented)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>Right-click for the button menu<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  elem.oncontextmenu = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line"><span class="javascript">    alert(<span class="string">&quot;Button context menu&quot;</span>);</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (event.defaultPrevented) <span class="keyword">return</span>;</span></span><br><span class="line"></span><br><span class="line">    event.preventDefault();</span><br><span class="line"><span class="javascript">    alert(<span class="string">&quot;Document context menu&quot;</span>);</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建自定义事件"><a href="#创建自定义事件" class="headerlink" title="创建自定义事件"></a>创建自定义事件</h4><p>内建事件类形成一个层次结构（hierarchy），类似于 DOM 元素类，根是内建的 Event 类；</p>
<p>通过 new Event(type[, options]) 创建一个事件对象，其中 type 是事件类型，自定义的字符串；options 是一个包含两个布尔值属性的对象：</p>
<ul>
<li>bubbles: true/false 如果为 true，那么事件会冒泡，默认 false；</li>
<li>cancelable: true/false 如果为 true，那么“默认行为”就会被阻止，默认 false；</li>
</ul>
<p>事件对象被创建后，使用 elem.dispatchEvent(event) 调用在元素上“运行”它；</p>
<blockquote>
<p>Tips: 对于来自真实用户操作的事件，<code>event.isTrusted</code> 属性为 <code>true</code>，对于脚本生成的事件，<code>event.isTrusted</code> 属性为 <code>false</code>；</p>
</blockquote>
<p>对于自己的全新事件类型，应该使用 new CustomEvent，从技术上讲，CustomEvent 和 Event 一样，除了第二个参数（对象）中，可以为想要与事件一起传递的任何自定义信息添加一个附加的属性 detail；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件附带给处理程序的其他详细信息</span></span><br><span class="line">elem.addEventListener(<span class="string">&quot;hello&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.detail.name);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">elem.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;hello&quot;</span>, &#123;</span><br><span class="line">  detail: &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>对于新的，自定义的事件，绝对没有默认的浏览器行为，但是分派（dispatch）此类事件的代码可能有自己的计划，触发该事件之后应该做什么，</p>
<p>通过调用 event.preventDefault()，事件处理程序可以发出一个信号，指出这些行为应该被取消；该事件必须具有 cancelable: true 标志，否则 event.preventDefault() 调用将会被忽略；</p>
<p>通常事件是在队列中处理的，但当一个事件是在另一个事件中发起的，例如使用 dispatchEvent，这类事件将会被立即处理，即在新的事件处理程序被调用之后，恢复到当前的事件处理程序；可以通过零延时 setTimeout 使原事件不受其它嵌套事件的影响，优先被处理完毕；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;menu&quot;</span>&gt;</span>Menu (click me)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  menu.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    alert(1);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    menu.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;menu-open&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">      bubbles: <span class="literal">true</span></span></span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    alert(2);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 在 1 和 2 之间触发</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;menu-open&#x27;</span>, <span class="function">() =&gt;</span> alert(<span class="string">&#x27;nested&#x27;</span>));</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 零延时 setTimeout</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;menu-open&#x27;</span>, <span class="function">() =&gt;</span> alert(<span class="string">&#x27;nested&#x27;</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>与点击相关的事件始终具有 button 属性，该属性允许获取确切的鼠标按钮；在 mousedown 和 mouseup 事件中则可能需要用到 event.button，因为这两个事件在任何按键上都会触发，所以我们可以使用 button 属性来区分是左键单击还是右键单击；</p>
<p>通常我们不在 click 和 contextmenu 事件中使用这一属性，因为前者只在单击鼠标左键时触发，后者只在单击鼠标右键时触发；</p>
<table>
<thead>
<tr>
<th align="left">鼠标按键状态</th>
<th align="left">event.button</th>
</tr>
</thead>
<tbody><tr>
<td align="left">左键 (主要按键)</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">中键 (辅助按键)</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">右键 (次要按键)</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">X1键 (后退按键)</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">X2键 (前进按键)</td>
<td align="left">4</td>
</tr>
</tbody></table>
<blockquote>
<p>Note: 一些老代码可能会使用 event.which 属性来获得按下的按键，这是一个古老的非标准的方式，左中右键的值分别为1、2、3；</p>
</blockquote>
<p>所有的鼠标事件都包含有关按下的组合键的信息：</p>
<ul>
<li>shiftKey：Shift；</li>
<li>altKey：Alt（或对于 Mac 是 Opt）；</li>
<li>ctrlKey：Ctrl；</li>
<li>metaKey：对于 Mac 是 Cmd；</li>
</ul>
<blockquote>
<p>Tips: 在 Mac 上我们通常使用 Cmd 代替 Ctrl，使用 <code>event.ctrlKey || event.metaKey</code> 判断；</p>
</blockquote>
<p>所有的鼠标事件都提供了两种形式的坐标：</p>
<ul>
<li>相对于窗口的坐标：clientX 和 clientY；</li>
<li>相对于文档的坐标：pageX 和 pageY；</li>
</ul>
<p>双击鼠标会有副作用，在某些界面中可能会出现干扰：它会选择文本；最合理的方式是防止浏览器对 mousedown 进行操作；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span> <span class="attr">ondblclick</span>=<span class="string">&quot;alert(&#x27;Click!&#x27;)&quot;</span> <span class="attr">onmousedown</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">  Double-click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想禁用选择以保护页面的内容不被复制粘贴，那么可以使用另一个事件：oncopy；</p>
<h4 id="移动鼠标：mouseover-out，mouseenter-leave"><a href="#移动鼠标：mouseover-out，mouseenter-leave" class="headerlink" title="移动鼠标：mouseover/out，mouseenter/leave"></a>移动鼠标：mouseover/out，mouseenter/leave</h4><p>当鼠标指针移到某个元素上时，mouseover 事件就会发生，而当鼠标离开该元素时，mouseout 事件就会发生；</p>
<p>在 mouseover 和 mouseout 事件中，有一个 relatedTarget 属性，表示鼠标来自的那个元素或是鼠标移动到的，当前指针位置下的元素；当鼠标从窗口外移入时，其值为 null；</p>
<p>在鼠标快速移动的情况下，中间元素可能会被忽略，但是我们可以肯定一件事：如果鼠标指针“正式地”进入了一个元素（生成了 mouseover 事件），那么一旦它离开，我们就会得到 mouseout；</p>
<p>从父元素转到子元素时，也会触发 mouseover/out 事件，浏览器假定鼠标一次只会位于一个元素上最深的那个；</p>
<p>事件 mouseenter/mouseleave 类似于 mouseover/mouseout，它们在鼠标指针进入/离开元素时触发；但元素内部与后代之间的转换不会产生影响，且事件 mouseenter/mouseleave 不会冒泡；</p>
<h4 id="鼠标拖放事件"><a href="#鼠标拖放事件" class="headerlink" title="鼠标拖放事件"></a>鼠标拖放事件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 球体拖动</span></span><br><span class="line">ball.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> shiftX = event.clientX - ball.getBoundingClientRect().left;</span><br><span class="line">  <span class="keyword">let</span> shiftY = event.clientY - ball.getBoundingClientRect().top;</span><br><span class="line"></span><br><span class="line">  ball.style.position = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line">  ball.style.zIndex = <span class="number">1000</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.append(ball);</span><br><span class="line"></span><br><span class="line">  moveAt(event.pageX, event.pageY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动现在位于坐标 (pageX, pageY) 上的球</span></span><br><span class="line">  <span class="comment">// 将初始的偏移考虑在内</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">moveAt</span>(<span class="params">pageX, pageY</span>) </span>&#123;</span><br><span class="line">    ball.style.left = pageX - shiftX + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    ball.style.top = pageY - shiftY + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onMouseMove</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    moveAt(event.pageX, event.pageY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 mousemove 事件上移动球</span></span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, onMouseMove);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 放下球，并移除不需要的处理程序</span></span><br><span class="line">  ball.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, onMouseMove);</span><br><span class="line">    ball.onmouseup = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ball.ondragstart = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="指针事件"><a href="#指针事件" class="headerlink" title="指针事件"></a>指针事件</h4><p>指针事件（Pointer Events）是一种用于处理来自各种输入设备（例如鼠标、触控笔和触摸屏等）的输入信息的现代化解决方案；</p>
<blockquote>
<p>Note: 除非你写的代码需要兼容旧版本的浏览器，例如 IE 10 或 Safari 12 或更低的版本，否则无需继续使用鼠标事件或触摸事件我们可以使用指针事件；</p>
</blockquote>
<p><strong>指针事件类型</strong></p>
<table>
<thead>
<tr>
<th align="left">指针事件</th>
<th align="left">类似的鼠标事件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pointerdown</td>
<td align="left">mousedown</td>
</tr>
<tr>
<td align="left">pointerup</td>
<td align="left">mouseup</td>
</tr>
<tr>
<td align="left">pointermove</td>
<td align="left">mousemove</td>
</tr>
<tr>
<td align="left">pointerover</td>
<td align="left">mouseover</td>
</tr>
<tr>
<td align="left">pointerout</td>
<td align="left">mouseout</td>
</tr>
<tr>
<td align="left">pointerenter</td>
<td align="left">mouseenter</td>
</tr>
<tr>
<td align="left">pointerleave</td>
<td align="left">mouseleave</td>
</tr>
<tr>
<td align="left">pointercancel</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">gotpointercapture</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">lostpointercapture</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p><strong>指针事件属性</strong></p>
<p>指针事件具备和鼠标事件完全相同的属性，包括 clientX/Y 和 target 等，以及一些其他属性：</p>
<ul>
<li>pointerId 触发当前事件的指针唯一标识符，由浏览器生成的，使能够处理多指针的情况，如多点触控功能；</li>
<li>pointerType 指针的设备类型，必须为字符串，可以是：“mouse”、“pen” 或 “touch”；</li>
<li>isPrimary 当指针为首要指针（多点触控时按下的第一根手指）时为 true；</li>
</ul>
<p>有些指针设备会测量接触面积和点按压力（例如一根手指压在触屏上），对于这种情况可以使用以下属性：</p>
<ul>
<li>width 指针（例如手指）接触设备的区域的宽度，对于不支持的设备（如鼠标），这个值总是 1；</li>
<li>height 指针（例如手指）接触设备的区域的长度，对于不支持的设备，这个值总是 1；</li>
<li>pressure 触摸压力，是一个介于 0 到 1 之间的浮点数，对于不支持压力检测的设备，这个值总是 0.5（按下时）或 0；</li>
<li>tangentialPressure 归一化后的切向压力（tangential pressure）；</li>
<li>tiltX, tiltY, twist 针对触摸笔的几个属性，用于描述笔和屏幕表面的相对位置；</li>
</ul>
<p>pointercancel 事件将会在一个正处于活跃状态的指针交互由于某些原因被中断时触发；在这个事件之后，该指针就不会继续触发更多事件了；</p>
<p>导致指针中断的可能原因如下：</p>
<ul>
<li>指针设备硬件在物理层面上被禁用；</li>
<li>设备方向旋转（例如给平板转了个方向）；</li>
<li>浏览器打算自行处理这一交互，比如将其看作是一个专门的鼠标手势或缩放操作等；</li>
</ul>
<p>阻止原生的拖放操作发生：</p>
<ol>
<li>对于非触屏设备：在 JS 中 ondragstart 事件处理返回 false；或者 event.preventDefault()；</li>
<li>对于触屏设备：在 CSS 中设置 touch-action: none；</li>
</ol>
<p><strong>指针捕获</strong></p>
<p>指针捕获（Pointer capturing）是针对指针事件的一个特性；elem.setPointerCapture(pointerId) 方法将给定的 pointerId 绑定到 elem；在调用之后，所有具有相同 pointerId 的指针事件都将 elem 作为目标（就像事件发生在 elem 上一样），无论这些 elem 在文档中的实际位置是什么；</p>
<p>绑定会在以下情况下被移除：</p>
<ul>
<li>当 pointerup 或 pointercancel 事件出现时，绑定会被自动地移除；</li>
<li>当 elem 被从文档中移除后，绑定会被自动地移除；</li>
<li>当 elem.releasePointerCapture(pointerId) 被调用，绑定会被移除；</li>
</ul>
<p>gotpointercapture 会在一个元素使用 setPointerCapture 来启用捕获后触发；<br>lostpointercapture 会在捕获被释放后触发：其触发可能是由于 releasePointerCapture 的显式调用，或是 pointerup/pointercancel 事件触发后的自动调用；</p>
<h4 id="键盘：keydown-和-keyup"><a href="#键盘：keydown-和-keyup" class="headerlink" title="键盘：keydown 和 keyup"></a>键盘：keydown 和 keyup</h4><p>当一个按键被按下时，会触发 keydown 事件，而当按键被释放时，会触发 keyup 事件；</p>
<p>事件对象的 key 属性允许获取字符，而事件对象的 code 属性则允许获取“物理按键代码”；每个按键的代码都取决于该按键在键盘上的位置，UI 事件代码规范 中描述了按键代码：</p>
<ul>
<li>字符键的代码为 <code>Key&lt;letter&gt;</code>：KeyA，KeyB 等；</li>
<li>数字键的代码为：<code>Digit&lt;number&gt;</code>：Digit0，Digit1 等；</li>
<li>特殊按键的代码为按键的名字：Enter，Backspace，Tab 等；</li>
</ul>
<blockquote>
<p>Tips: 为了可靠地跟踪与受键盘布局影响的字符，使用 <code>event.key</code> 可能是一个更好的方式；但为了满足切换了语言的情况下，依赖于它的热键也能正常工作，则使用绑定到物理键位置的 <code>event.code</code>；</p>
</blockquote>
<blockquote>
<p>Note: 如果按下一个键足够长的时间，它就会开始“自动重复”：<code>keydown</code> 会被一次又一次地触发，对于由自动重复触发的事件，<code>event</code> 对象的 <code>event.repeat</code> 属性被设置为 <code>true</code>；</p>
</blockquote>
<p>过去曾经有一个 keypress 事件，还有事件对象的 keyCode、charCode 和 which 属性；大多数浏览器对它们都存在兼容性问题；</p>
<ul>
<li><a href="https://www.w3.org/TR/uievents-code/#key-alphanumeric-section">字母数字按键代码W3C规范</a></li>
</ul>
<h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><p>scroll 事件在 window 和可滚动元素上都可以运行；不能通过在 onscroll 监听器中使用 event.preventDefault() 来阻止滚动，因为它会在滚动发生之后才触发；</p>
<p>但是我们可以在导致滚动的事件上，例如在 pageUp 和 pageDown 的 keydown 事件上，使用 event.preventDefault() 来阻止滚动；</p>
<p>滚动的两个重要特性：</p>
<ul>
<li>滚动是“弹性的”；在某些浏览器/设备中，我们可以在文档的顶端或末端稍微多滚动出一点（超出部分显示的是空白区域，然后文档将自动“弹回”到正常状态）；</li>
<li>滚动并不精确；当我们滚动到页面末端时，实际上我们可能距真实的文档末端约 0-50px；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否滚动到页面底部</span></span><br><span class="line"><span class="keyword">let</span> windowRelativeBottom = <span class="built_in">document</span>.documentElement.getBoundingClientRect().bottom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用户将页面滚动的距离不够远（文档末端距窗口底部 &gt;100px）</span></span><br><span class="line"><span class="keyword">if</span> (windowRelativeBottom &gt; <span class="built_in">document</span>.documentElement.clientHeight + <span class="number">100</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图片懒加载</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests if the element is visible (within the visible part of the page)</span></span><br><span class="line"><span class="comment"> * It&#x27;s enough that the top or bottom edge of the element are visible</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isVisible</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo: your code</span></span><br><span class="line">  <span class="keyword">let</span> position = image.getBoundingClientRect();</span><br><span class="line">  <span class="keyword">return</span> position.top &lt; <span class="built_in">window</span>.pageYOffset + <span class="built_in">document</span>.documentElement.clientHeight + <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showVisible</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> img <span class="keyword">of</span> <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> realSrc = img.dataset.src;</span><br><span class="line">    <span class="keyword">if</span> (!realSrc) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isVisible(img)) &#123;</span><br><span class="line">      <span class="comment">// disable caching</span></span><br><span class="line">      <span class="comment">// this line should be removed in production code</span></span><br><span class="line">      realSrc += <span class="string">&#x27;?nocache=&#x27;</span> + <span class="built_in">Math</span>.random();</span><br><span class="line"></span><br><span class="line">      img.src = realSrc;</span><br><span class="line"></span><br><span class="line">      img.dataset.src = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, showVisible);</span><br><span class="line">showVisible();</span><br></pre></td></tr></table></figure>

<h4 id="表单属性和方法"><a href="#表单属性和方法" class="headerlink" title="表单属性和方法"></a>表单属性和方法</h4><p>文档中的表单是特殊集合 document.forms 的成员，既可以使用名字，也可以使用在文档中的编号来获取表单；在表单中，其中的任何元素都可以通过命名的集合 form.elements 来获取到；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;my&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;two&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取表单</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> form = <span class="built_in">document</span>.forms.my; <span class="comment">// &lt;form name=&quot;my&quot;&gt; 元素</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取表单中的元素</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> elem = form.elements.one; <span class="comment">// &lt;input name=&quot;one&quot;&gt; 元素</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// let elem = form.elements[&quot;one&quot;];</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// let elem = form.elements[0];</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  alert(elem.value); <span class="comment">// 1</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于相同 name 字段的 input 单选按钮，form.elements[name] 将会是一个集合；这些导航（navigation）属性并不依赖于标签的结构，所有的控件元素，无论它们在表单中有多深，都可以通过 form.elements 获取到；</p>
<p>一个表单内会有一个或多个 <code>&lt;fieldset&gt;</code> 元素，它们也具有 elements 属性，该属性列出了 <code>&lt;fieldset&gt;</code> 中的表单控件；</p>
<blockquote>
<p>Tips: <code>elements</code> 可以省略，可以通过 <code>form[index/name]</code> 来访问元素；</p>
</blockquote>
<p>对于任何元素，其对应的表单都可以通过 element.form 访问到；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// form -&gt; element</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> login = form.login;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// element -&gt; form</span></span></span><br><span class="line"><span class="javascript">  alert(login.form); <span class="comment">// HTMLFormElement</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>表单元素</strong></p>
<p>一个 <code>&lt;select&gt;</code> 元素有 3 个重要的属性：</p>
<ul>
<li>select.options <code>&lt;option&gt;</code> 的子元素的集合；</li>
<li>select.value 当前所选择的 <code>&lt;option&gt;</code> 的 value；</li>
<li>select.selectedIndex 当前所选择的 <code>&lt;option&gt;</code> 的编号；</li>
</ul>
<p>并提供了三种为 <code>&lt;select&gt;</code> 设置 value 的不同方式：</p>
<ul>
<li>找到对应的 <code>&lt;option&gt;</code> 元素，并将 option.selected 设置为 true；</li>
<li>将 select.value 设置为对应的 value；</li>
<li>将 select.selectedIndex 设置为对应 <code>&lt;option&gt;</code> 的编号；</li>
</ul>
<p>如果 <code>&lt;select&gt;</code> 具有 multiple 特性（attribute），则允许多选；</p>
<p>在规范中，有一个很好的简短语法可以创建 <code>&lt;option&gt;</code> 元素：<code>new Option(text, value, defaultSelected, selected)</code>；其中参数：</p>
<ul>
<li>text <code>&lt;option&gt;</code> 中的文本；</li>
<li>value <code>&lt;option&gt;</code> 的 value；</li>
<li>defaultSelected 如果为 true，那么 selected HTML-特性（attribute）就会被创建；</li>
<li>selected 如果为 true，那么这个 <code>&lt;option&gt;</code> 就会被选中；</li>
</ul>
<p><code>&lt;option&gt;</code> 元素具有以下属性：</p>
<ul>
<li>option.selected <code>&lt;option&gt;</code> 是否被选择；</li>
<li>option.index <code>&lt;option&gt;</code> 在其所属的 <code>&lt;select&gt;</code> 中的编号；</li>
<li>option.text <code>&lt;option&gt;</code> 的文本内容（可以被访问者看到）；</li>
</ul>
<h4 id="聚焦：focus-blur"><a href="#聚焦：focus-blur" class="headerlink" title="聚焦：focus/blur"></a>聚焦：focus/blur</h4><p>当用户点击某个元素或使用键盘上的 Tab 键选中时，该元素将会获得聚焦（focus），还有一个 HTML 特性（attribute）autofocus 可以让焦点在网页加载时默认落在一个元素上，此外还有其它途径可以获得焦点；</p>
<p>当元素聚焦时，会触发 focus 事件，当元素失去焦点时，会触发 blur 事件；elem.focus() 和 elem.blur() 方法可以设置和移除元素上的焦点；</p>
<p>无法通过在 onblur 事件处理程序中调用 event.preventDefault() 来“阻止失去焦点”，因为 onblur 事件处理程序是在元素失去焦点 之后 运行的；</p>
<blockquote>
<p>Note: <code>alert</code> 会将焦点移至自身，因此会导致元素失去焦点（触发 blur 事件），而当 <code>alert</code> 对话框被取消时，焦点又回重新回到原元素上（触发 focus 事件）；如果一个元素被从 DOM 中移除，那么也会导致焦点丢失，如果稍后它被重新插入到 DOM，焦点也不会回到它身上；</p>
</blockquote>
<p>任何具有 tabindex 特性的元素，都会变成可聚焦的，该特性的 value 是当使用 Tab（或类似的东西）在元素之间进行切换时，元素的顺序号；可以使用 elem.tabIndex 通过 JavaScript 来添加 tabindex；</p>
<p>特殊值：</p>
<ul>
<li>tabindex=”0” 会使该元素被与那些不具有 tabindex 的元素放在一起。也就是说，当我们切换元素时，具有 tabindex=”0” 的元素将排在那些具有 tabindex ≥ 1 的元素的后面；</li>
<li>tabindex=”-1” 只允许以编程的方式聚焦于元素。Tab 键会忽略这样的元素，但是 elem.focus() 有效；</li>
</ul>
<p>focus 和 blur 事件不会向上冒泡，但会在捕获阶段向下传播，因此可以在捕获阶段进行事件委托；也可以使用冒泡事件 focusin 和 focusout，但必须使用 elem.addEventListener 来分配它们；</p>
<h4 id="事件：change，input，cut，copy，paste"><a href="#事件：change，input，cut，copy，paste" class="headerlink" title="事件：change，input，cut，copy，paste"></a>事件：change，input，cut，copy，paste</h4><p>当元素更改完成时，将触发 change 事件，对于文本输入框，当其失去焦点时，就会触发 change 事件；</p>
<p>每当用户对输入值进行修改后，就会触发 input 事件；与键盘事件不同，只要值改变了，input 事件就会触发，即使那些不涉及键盘行为（action）的值的更改也是如此：使用鼠标粘贴，或者使用语音识别来输入文本；</p>
<p>ClipboardEvent 类，并提供了对剪切/拷贝/粘贴的数据的访问方法；</p>
<h4 id="表单：事件和方法提交"><a href="#表单：事件和方法提交" class="headerlink" title="表单：事件和方法提交"></a>表单：事件和方法提交</h4><p>提交表单时，会触发 submit 事件，它通常用于在将表单发送到服务器之前对表单进行校验，或者中止提交，并使用 JavaScript 来处理表单；form.submit() 方法允许从 JavaScript 启动表单发送，我们可以使用此方法动态地创建表单，并将其发送到服务器；</p>
<p>提交表单主要有两种方式：</p>
<ul>
<li>点击 <code>&lt;input type=&quot;submit&quot;&gt;</code> 或 <code>&lt;input type=&quot;image&quot;&gt;</code>；</li>
<li>在 input 字段中按下 Enter 键；</li>
</ul>
<blockquote>
<p>Note: 在输入框中使用 Enter 发送表单时，会在 <code>&lt;input type=&quot;submit&quot;&gt;</code>上触发一次 click 事件；</p>
</blockquote>
<h4 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h4><p><strong>DOMContentLoaded</strong></p>
<p>浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成；此时处理程序可以查找 DOM 节点，并初始化接口；</p>
<p>DOMContentLoaded 事件发生在 document 对象上，且必须使用 addEventListener 来捕获；</p>
<p>具有 async 特性（attribute）的脚本，以及使用 document.createElement(‘script’) 动态生成并添加到网页的脚本也不会阻塞 DOMContentLoaded；</p>
<p>外部样式表不会影响 DOM，因此 DOMContentLoaded 不会等待它们，但如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 在样式表加载完成之前，脚本都不会执行</span></span></span><br><span class="line"><span class="javascript">  alert(getComputedStyle(<span class="built_in">document</span>.body).marginTop);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Firefox，Chrome 和 Opera 都会在 DOMContentLoaded 中自动填充表单，如果 DOMContentLoaded 被需要加载很长时间的脚本延迟触发，那么自动填充也会等待；</p>
<p><strong>window.load</strong></p>
<p>当整个页面，包括样式、图片和其他资源被加载完成时，会触发 window 对象上的 load 事件；此时外部资源已加载完成，样式已被应用，图片大小也已知了；</p>
<p><strong>window.onbeforeunload</strong></p>
<p>如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，beforeunload 处理程序将要求进行更多确认；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在某些旧浏览器中返回非空字符串也被视为取消事件；</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>window.unload</strong></p>
<p>当访问者离开页面时，window 对象上的 unload 事件就会被触发，如果希望通过 unload 事件将数据保存到服务器上，可以使用 navigator.sendBeacon(url, data) 方法；该方法在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 sendBeacon；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> analyticsData = &#123; <span class="comment">/* 带有收集的数据的对象 */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;unload&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 也可以发送表单以及其他格式的数据，数据大小限制在 64kb</span></span><br><span class="line">  navigator.sendBeacon(<span class="string">&quot;/analytics&quot;</span>, <span class="built_in">JSON</span>.stringify(analyticsData));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>readystatechange 和 document.readyState</strong></p>
<p>document.readyState 属性可以提供当前加载状态的信息，它有三个值：</p>
<ul>
<li>loading —— 文档正在被加载；</li>
<li>interactive —— 文档被全部读取；</li>
<li>complete —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成；</li>
</ul>
<p>readystatechange 事件是跟踪文档加载状态的另一种机制，它会在状态发生改变时触发；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  log(<span class="string">&#x27;readyState:&#x27;</span> + <span class="built_in">document</span>.readyState);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function">() =&gt;</span> log(<span class="string">&#x27;readyState:&#x27;</span> + <span class="built_in">document</span>.readyState));</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> log(<span class="string">&#x27;DOMContentLoaded&#x27;</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function">() =&gt;</span> log(<span class="string">&#x27;window onload&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;iframe.html&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;log(&#x27;iframe onload&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://en.js.cx/clipart/train.gif&quot;</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  img.onload = <span class="function">() =&gt;</span> log(<span class="string">&#x27;img onload&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>包含 <code>&lt;iframe&gt;</code>，<code>&lt;img&gt;</code> 和记录事件的处理程序的文档完整的事件流：</p>
<ol>
<li>readyState:loading</li>
<li>readyState:interactive</li>
<li>DOMContentLoaded</li>
<li>iframe onload</li>
<li>img onload</li>
<li>readyState:complete</li>
<li>window onload</li>
</ol>
<p>在 DOMContentLoaded 之前，document.readyState 会立即变成 interactive，它们的意义实际上是相同的；当所有资源（iframe 和 img）都加载完成后，document.readyState 变成 complete；转换到 complete 状态的意义与 window.onload 相同，区别在于 window.onload 始终在所有其他 load 处理程序之后运行；</p>
<p><strong>脚本：async，defer</strong></p>
<p>当浏览器加载 HTML 时遇到 <code>&lt;script&gt;</code> 标签，浏览器就不能继续构建 DOM，它必须立刻执行此脚本，对于外部脚本也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面；</p>
<p>通常把脚本放在页面底部，可以访问到页面上面的元素，并且不会阻塞页面显示内容；但是当遇到长的 HTML 文档时，则可能会造成明显的延迟；</p>
<p><strong>defer</strong></p>
<p>defer 特性告诉浏览器不要等待脚本，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行；</p>
<p>具有 defer 特性的脚本不会阻塞页面，总是要等到 DOM 解析完毕，但在 DOMContentLoaded 事件之前执行；</p>
<p>浏览器扫描页面寻找 defer 脚本，然后并行下载它们，以提高性能，且它们保持其相对顺序执行；</p>
<p><strong>async</strong></p>
<p>async 脚本就是一个会在加载完成时执行的完全独立的脚本，其他脚本不会等待 async 脚本加载完成，同样，async 脚本也不会等待其他脚本；浏览器也不会因 async 脚本而阻塞（与 defer 类似）；</p>
<p>DOMContentLoaded 和异步脚本不会彼此等待：</p>
<ul>
<li>如果异步脚本在页面完成后才加载完成，则 DOMContentLoaded 可能会发生在异步脚本之前；</li>
<li>如果异步脚本很短，或者是从 HTTP 缓存中加载的，则 DOMContentLoaded 也可能发生在异步脚本之后；</li>
</ul>
<p><strong>动态脚本</strong></p>
<p>可以使用 JavaScript 动态地创建一个脚本，并将其附加（append）到文档（document）中，当脚本被附加到文档时，脚本就会立即开始加载；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.src = <span class="string">&quot;/article/script-async-defer/long.js&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.append(script); <span class="comment">// 添加到文档</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，动态脚本的行为是“异步”的，即效果同 async；可以显式地设置 script.async=false，改变这个规则，使执行效果同 defer；</p>
<blockquote>
<p>Tips: 在实际开发中，<code>defer</code> 用于需要整个 DOM 的脚本，和/或脚本的相对执行顺序很重要的时候；<code>async</code> 用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要；</p>
</blockquote>
<h4 id="资源加载：onload，onerror"><a href="#资源加载：onload，onerror" class="headerlink" title="资源加载：onload，onerror"></a>资源加载：onload，onerror</h4><p>浏览器允许跟踪外部资源的加载，如脚本，iframe，图片等；readystatechange 事件也适用于资源，但很少被使用；</p>
<p>对于加载脚本 onload/onerror 事件仅跟踪加载本身；在脚本处理和执行期间可能发生的 error 超出了这些事件跟踪的范围；也就是说：如果脚本成功加载，则即使脚本中有编程 error，也会触发 onload 事件；</p>
<p>load 和 error 事件也适用于其他资源，基本上（basically）适用于具有外部 src 的任何资源；</p>
<p>大多数资源在被添加到文档中后，便开始加载，但是 <code>&lt;img&gt;</code> 是个例外，它要等到获得 src 后才开始加载；对于 <code>&lt;iframe&gt;</code> 来说，iframe 加载完成时会触发 iframe.onload 事件，无论是成功加载还是出现 error；</p>
<p>如果我们使用的是来自其他域的脚本，并且该脚本中存在 error，那么我们无法获取 error 的详细信息；</p>
<p>要允许跨源访问，<code>&lt;script&gt;</code> 标签需要具有 crossorigin 特性（attribute），并且远程服务器必须提供特殊的 header；这里有三个级别的跨源访问：</p>
<ul>
<li>无 crossorigin 特性 —— 禁止访问；</li>
<li>crossorigin=”anonymous” 如果服务器的响应带有包含 * 或我们的源（origin）的 header Access-Control-Allow-Origin，则允许访问，浏览器不会将授权信息和 cookie 发送到远程服务器；</li>
<li>crossorigin=”use-credentials” 如果服务器发送回带有我们的源的 header Access-Control-Allow-Origin 和 Access-Control-Allow-Credentials: true，则允许访问。浏览器会将授权信息和 cookie 发送到远程服务器；</li>
</ul>
<h4 id="DOM-变动观察器（Mutation-observer）"><a href="#DOM-变动观察器（Mutation-observer）" class="headerlink" title="DOM 变动观察器（Mutation observer）"></a>DOM 变动观察器（Mutation observer）</h4><p>MutationObserver 是一个内建对象，它观察 DOM 元素，并在检测到更改时触发回调；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个带有回调函数的观察器</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"><span class="comment">// 将其附加到一个 DOM 节点</span></span><br><span class="line">observer.observe(node, config);</span><br></pre></td></tr></table></figure>

<p>config 是一个具有布尔选项的对象，该布尔选项表示“将对哪些更改做出反应”：</p>
<ul>
<li>childList node 的直接子节点的更改；</li>
<li>subtree node 的所有后代的更改；</li>
<li>attributes node 的特性（attribute）；</li>
<li>attributeFilter 特性名称数组，只观察选定的特性；</li>
<li>characterData 是否观察 node.data（文本内容）；</li>
<li>attributeOldValue 如果为 true，则将特性的旧值和新值都传递给回调，否则只传新值（需要 attributes 选项）；</li>
<li>characterDataOldValue 如果为 true，则将 node.data 的旧值和新值都传递给回调，否则只传新值（需要 characterData 选项）；</li>
</ul>
<p>在发生任何更改后，将执行“回调”：更改被作为一个 MutationRecord 对象列表传入第一个参数，而观察器自身作为第二个参数，MutationRecord 对象具有以下属性：</p>
<ul>
<li>type 变动类型，以下类型之一：<ul>
<li>“attributes”：特性被修改了；</li>
<li>“characterData”：数据被修改了，用于文本节点；</li>
<li>“childList”：添加/删除了子元素；</li>
</ul>
</li>
<li>target 更改发生在何处：”attributes” 所在的元素，或 “characterData” 所在的文本节点，或 “childList” 变动所在的元素；</li>
<li>addedNodes/removedNodes 添加/删除的节点；</li>
<li>previousSibling/nextSibling 添加/删除的节点的上一个/下一个兄弟节点；</li>
<li>attributeName/attributeNamespace 被更改的特性的名称/命名空间（用于 XML）；</li>
<li>oldValue 之前的值，仅适用于特性或文本更改，如果设置了相应选项 attributeOldValue/characterDataOldValue</li>
</ul>
<p>方法 observer.disconnect() 可以停止观察，但这时观察器可能尚未处理某些更改；observer.takeRecords() 方法可以获取尚未处理的变动记录列表，表中记录的是已经发生，但回调暂未处理的变动；</p>
<blockquote>
<p>Note: 观察器在内部对节点使用弱引用，也就是说，如果一个节点被从 DOM 中移除了，并且该节点变得不可访问，那么它就可以被垃圾回收；</p>
</blockquote>
<h4 id="选择（Selection）和范围（Range）"><a href="#选择（Selection）和范围（Range）" class="headerlink" title="选择（Selection）和范围（Range）"></a>选择（Selection）和范围（Range）</h4><p>选择的基本概念是 Range：本质上是一对“边界点”：范围起点和范围终点；每个点都被表示为一个带有相对于起点的相对偏移（offset）的父 DOM 节点，如果父节点是元素节点，则偏移量是子节点的编号（子节点数），对于文本节点，则是文本中的位置（字符数）；</p>
<p>使用 new Range() 创建一个范围，Range 是一个无参的构造函数；使用 range.setStart(node, offset) 和 range.setEnd(node, offset) 来设置选择边界；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span>&gt;</span>Example: <span class="tag">&lt;<span class="name">i</span>&gt;</span>italic<span class="tag">&lt;/<span class="name">i</span>&gt;</span> and <span class="tag">&lt;<span class="name">b</span>&gt;</span>bold<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">From <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">value</span>=<span class="string">1</span>&gt;</span> – To <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;end&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">value</span>=<span class="string">4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Click to select<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  button.onclick = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> range = <span class="keyword">new</span> Range();</span></span><br><span class="line"></span><br><span class="line">    range.setStart(p, start.value);</span><br><span class="line">    range.setEnd(p, end.value);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 应用选择，后文有解释</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getSelection().removeAllRanges();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getSelection().addRange(range);</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 一个范围可能跨越许多不相关的节点，所以不必在 <code>setStart</code> 和 <code>setEnd</code> 中使用相同的节点，唯一要注意的是终点要在起点之后；</p>
</blockquote>
<p>range 对象具有以下属性：</p>
<ul>
<li>startContainer，startOffset 起始节点和偏移量；</li>
<li>endContainer，endOffset 结束节点和偏移量；</li>
<li>collapsed 布尔值，如果范围在同一点上开始和结束（所以范围内没有内容）则为 true；</li>
<li>commonAncestorContainer 在范围内的所有节点中最近的共同祖先节点；</li>
</ul>
<p>Range 方法：</p>
<ul>
<li><p>setStart(node, offset) 将起点设置在：node 中的位置 offset；</p>
</li>
<li><p>setStartBefore(node) 将起点设置在：node 前面；</p>
</li>
<li><p>setStartAfter(node) 将起点设置在：node 后面；</p>
</li>
<li><p>setEnd(node, offset) 将终点设置为：node 中的位置 offset；</p>
</li>
<li><p>setEndBefore(node) 将终点设置为：node 前面；</p>
</li>
<li><p>setEndAfter(node) 将终点设置为：node 后面；</p>
</li>
<li><p>selectNode(node) 设置范围以选择整个 node；</p>
</li>
<li><p>selectNodeContents(node) 设置范围以选择整个 node 的内容；</p>
</li>
<li><p>collapse(toStart) 如果 toStart=true 则设置 end=start，否则设置 start=end，从而折叠范围；</p>
</li>
<li><p>cloneRange() 创建一个具有相同起点/终点的新范围；</p>
</li>
<li><p>deleteContents() 从文档中删除范围内容；</p>
</li>
<li><p>extractContents() 从文档中删除范围内容，并将删除的内容作为 DocumentFragment 返回；</p>
</li>
<li><p>cloneContents() 复制范围内容，并将复制的内容作为 DocumentFragment 返回；</p>
</li>
<li><p>insertNode(node) 在范围的起始处将 node 插入文档；</p>
</li>
<li><p>surroundContents(node) 使用 node 将所选范围内容包裹起来，该范围必须包含其中所有元素的开始和结束标签；</p>
</li>
</ul>
<p>文档选择是由 Selection 对象表示的，可通过 window.getSelection() 或 document.getSelection() 来获取；Selection API 规范描述了一个选择可以包括零个或多个范围，但实际上，在除 Firefox 之外的所有浏览器中，范围最多是 1；</p>
<p>选择属性：</p>
<ul>
<li>anchorNode 选择的起始节点；</li>
<li>anchorOffset 选择开始的 anchorNode 中的偏移量；</li>
<li>focusNode 选择的结束节点；</li>
<li>focusOffset 选择开始处 focusNode 的偏移量；</li>
<li>isCollapsed 如果未选择任何内容（空范围）或不存在，则为 true ；</li>
<li>rangeCount 选择中的范围数，除 Firefox 外，其他浏览器最多为 1；</li>
</ul>
<blockquote>
<p>Tips: 可以通过 <code>elem.onselectstart</code> 跟踪当选择从 elem 上开始的事件，阻止默认行为会使选择无法开始；document.onselectionchange 当选择变动时触发；</p>
</blockquote>
<p>获取整个选择：</p>
<ul>
<li>作为文本：只需调用 document.getSelection().toString()；</li>
<li>作为 DOM 节点：获取底层的（underlying）范围，并调用它们的 cloneContents() 方法；</li>
</ul>
<p>选择方法：</p>
<ul>
<li><p>getRangeAt(i) 获取从 0 开始的第 i 个范围，在除 Firefox 之外的所有浏览器中，仅使用 0；</p>
</li>
<li><p>addRange(range) 将 range 添加到选择中，如果选择已有关联的范围，则除 Firefox 外的所有浏览器都将忽略该调用；</p>
</li>
<li><p>removeRange(range) 从选择中删除 range；</p>
</li>
<li><p>removeAllRanges() 删除所有范围；</p>
</li>
<li><p>empty() removeAllRanges 的别名；</p>
</li>
<li><p>collapse(node, offset) 用一个新的范围替换选定的范围，该新范围从给定的 node 处开始，到偏移 offset 处结束；</p>
</li>
<li><p>setPosition(node, offset) collapse 的别名；</p>
</li>
<li><p>collapseToStart() 折叠（替换为空范围）到选择起点；</p>
</li>
<li><p>collapseToEnd() 折叠到选择终点；</p>
</li>
<li><p>extend(node, offset) 将选择的焦点（focus）移到给定的 node，位置偏移 offset；</p>
</li>
<li><p>setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset) 用给定的起点 anchorNode/anchorOffset 和终点 focusNode/focusOffset 来替换选择范围，选中它们之间的所有内容；</p>
</li>
<li><p>selectAllChildren(node) 选择 node 的所有子节点；</p>
</li>
<li><p>deleteFromDocument() 从文档中删除所选择的内容；</p>
</li>
<li><p>containsNode(node, allowPartialContainment = false) 检查选择中是否包含 node（特别是如果第二个参数是 true 的话）；</p>
</li>
</ul>
<blockquote>
<p>Note: 如果选择已存在，需要先使用 <code>removeAllRanges()</code> 将其清空，然后添加范围；否则，除 Firefox 外的所有浏览器都将忽略新范围；</p>
</blockquote>
<p><strong>表单控件中的选择</strong></p>
<p>诸如 input 和 textarea 等表单元素提供了 专用的选择 API，没有 Selection 或 Range 对象；</p>
<ul>
<li>属性：<ul>
<li>input.selectionStart 选择的起始位置（可写）；</li>
<li>input.selectionEnd 选择的结束位置（可写）；</li>
<li>input.selectionDirection 选择方向，其中之一：“forward”，“backward” 或 “none”；</li>
</ul>
</li>
<li>事件：<ul>
<li>input.onselect 当某个东西被选择时触发；</li>
</ul>
</li>
<li>方法：<ul>
<li>input.select() 选择文本控件中的所有内容；</li>
<li>input.setSelectionRange(start, end, [direction]) 在给定方向上（可选），从 start 一直选择到 end；input.setRangeText(replacement, [start], [end], [selectionMode]) 用新文本替换范围中的文本；</li>
</ul>
</li>
</ul>
<p>input.setRangeText() 方法如果提供的话可选参数 start 和 end，则设置范围的起点和终点，否则使用用户的选择，最后一个可选参数 selectionMode 决定替换文本后如何设置选择，可能的值为：</p>
<ul>
<li>“select” 将选择新插入的文本；</li>
<li>“start” 选择范围将在插入的文本之前折叠（光标将在其之前）；</li>
<li>“end” 选择范围将在插入的文本之后折叠（光标将紧随其后）；</li>
<li>“preserve” 尝试保留选择，默认值；</li>
</ul>
<blockquote>
<p>Note: 根据规范，发表单控件内的选择不应该触发 <code>document.onselectionchange</code> 事件，因为它与 <code>document</code> 选择和范围不相关；</p>
</blockquote>
<blockquote>
<p>Tips: 一个重要的边界情况是 selectionStart 和 selectionEnd 彼此相等，也正是光标位置；通过将 selectionStart 和 selectionEnd 设置为相同的值，可以实现移动光标的效果；</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/* CSS 样式 */</span></span></span><br><span class="line">  #el &#123;</span><br><span class="line"><span class="css">    user-select: none;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;el&quot;</span>&gt;</span>Unselectable text.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 取消选择默认事件</span></span></span><br><span class="line"><span class="javascript">el.onselectstart = <span class="function">() =&gt;</span> <span class="literal">false</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 或者在选择发生后清除选择</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getSelection().empty() </span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="事件循环：微任务和宏任务"><a href="#事件循环：微任务和宏任务" class="headerlink" title="事件循环：微任务和宏任务"></a>事件循环：微任务和宏任务</h4><p>浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于事件循环的；事件循环是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环；</p>
<p>一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列；多个任务组成了一个队列，即所谓的“宏任务队列”（v8 术语）；例如以下宏任务：</p>
<ul>
<li>当外部脚本 <code>&lt;script src=&quot;...&quot;&gt;</code> 加载完成时，任务就是执行它</li>
<li>当用户移动鼠标时，任务就是派生出 mousemove 事件和执行处理程序；</li>
<li>当安排的（scheduled）setTimeout 时间到达时，任务就是执行其回调；</li>
</ul>
<p>引擎执行任务时永远不会进行渲染（render），如果任务执行需要很长一段时间也没关系，仅在任务完成后才会绘制对 DOM 的更改；如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，通常浏览器会抛出一个如“页面未响应”之类的警报；</p>
<p>当引擎忙于语法高亮时，它就无法处理其他 DOM 相关的工作，它甚至可能会导致浏览器“中断（hiccup）”甚至“挂起（hang）”一段时间；可以通过将大任务拆分成多个小任务来避免这个问题；对浏览器脚本中的过载型任务进行拆分的另一个好处是，可以显示进度指示；</p>
<blockquote>
<p>Tips: 在事件处理程序中，可能会推迟某些行为，直到事件冒泡并在所有级别上得到处理后；可以通过将该代码包装到零延迟的 <code>setTimeout</code> 中来做到这一点；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">menu.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个具有被点击的菜单项的数据的自定义事件</span></span><br><span class="line">  <span class="keyword">let</span> customEvent = <span class="keyword">new</span> CustomEvent(<span class="string">&quot;menu-open&quot;</span>, &#123;</span><br><span class="line">    bubbles: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步分派（dispatch）自定义事件</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> menu.dispatchEvent(customEvent));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>微任务仅来自于我们的代码，它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务；微任务也被用于 await 的“幕后”，因为它是 promise 处理的另一种形式；</p>
<p>还有一个特殊的函数 queueMicrotask(func)，它对 func 进行排队，以在微任务队列中执行；</p>
<p>微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成；如果我们想要异步执行（在当前代码之后）一个函数，但是要在更改被渲染或新事件被处理之前执行，那么我们可以使用 queueMicrotask 来对其进行安排（schedule）；</p>
<p>简化的事件循环算法：</p>
<ol>
<li>从宏任务队列中出队（dequeue）并执行最早的任务；</li>
<li>执行所有微任务：当微任务队列非空时：出队（dequeue）并执行最早的微任务；</li>
<li>如果有变更，则将变更渲染出来；</li>
<li>如果宏任务队列为空，则休眠直到出现宏任务；</li>
<li>转到步骤 1；</li>
</ol>
<h4 id="弹窗和-window-的方法"><a href="#弹窗和-window-的方法" class="headerlink" title="弹窗和 window 的方法"></a>弹窗和 window 的方法</h4><p>如果弹窗是在用户触发的事件处理程序（如 onclick）之外调用的，大多数浏览器都会阻止此类弹窗；</p>
<p><strong>window.open</strong></p>
<p>打开一个弹窗的语法是 window.open(url, name, params)：</p>
<ul>
<li>url 要在新窗口中加载的 URL；</li>
<li>name 新窗口的名称，每个窗口都有一个 window.name，在这里我们可以指定哪个窗口用于弹窗，如果已经有一个这样名字的窗口，将在该窗口打开给定的 URL，否则会打开一个新窗口；</li>
<li>params 新窗口的配置字符串，用逗号分隔，参数之间不能有空格；</li>
</ul>
<p>params 的设置项：</p>
<ul>
<li>left/top屏幕上窗口的左上角的坐标；这有一个限制：不能将新窗口置于屏幕外；</li>
<li>width/height 新窗口的宽度和高度；宽度/高度的最小值是有限制的，因此不可能创建一个不可见的窗口；</li>
<li>menubar（yes/no）显示或隐藏新窗口的浏览器菜单；</li>
<li>toolbar（yes/no）显示或隐藏新窗口的浏览器导航栏（后退，前进，重新加载等）；</li>
<li>location（yes/no）显示或隐藏新窗口的 URL 字段。Firefox 和 IE 浏览器不允许默认隐藏它；</li>
<li>status（yes/no）显示或隐藏状态栏；大多数浏览器都会强制显示它；</li>
<li>resizable（yes/no）允许禁用新窗口大小调整，不建议使用；</li>
<li>scrollbars（yes/no）允许禁用新窗口的滚动条，不建议使用；</li>
</ul>
<p>设置中的省略规则：</p>
<ul>
<li>如果 open 调用中没有第三个参数，或者它是空的，则使用默认的窗口参数；</li>
<li>如果这里有一个参数字符串，但是某些 yes/no 功能被省略了，那么被省略的功能则被默认值为 no；</li>
<li>如果参数中没有 left/top，那么浏览器会尝试在最后打开的窗口附近打开一个新窗口；</li>
<li>如果没有 width/height，那么新窗口的大小将与上次打开的窗口大小相同；</li>
</ul>
<p>open 调用会返回对新窗口的引用，它可以用来操纵弹窗的属性，更改位置，甚至更多操作；弹窗也可以使用 window.opener 来访问 opener 窗口；除了弹窗之外，对其他所有窗口来说，window.opener 均为 null；</p>
<blockquote>
<p>Note: 只有在窗口是同源的时，窗口才能自由访问彼此的内容；</p>
</blockquote>
<p>通过 win.close() 方法关闭一个窗口，使用 win.closed 属性检查一个窗口是否被关闭；</p>
<ul>
<li><a href="https://zh.javascript.info/popup-windows">JavaScript 现代教程-弹窗和 window 的方法</a></li>
</ul>
<h4 id="跨窗口通信"><a href="#跨窗口通信" class="headerlink" title="跨窗口通信"></a>跨窗口通信</h4><p>如果两个 URL 具有相同的协议，域和端口，则称它们是“同源”的；“同源（Same Origin）”策略限制了窗口（window）和 frame 之间的相互访问；非同源窗口引用只能更改其 location；</p>
<p><strong>iframe</strong></p>
<p>一个 <code>&lt;iframe&gt;</code> 标签承载了一个单独的嵌入的窗口，它具有自己的 document 和 window；</p>
<ul>
<li>iframe.contentWindow 来获取 <code>&lt;iframe&gt;</code> 中的 window；</li>
<li>iframe.contentDocument 来获取 <code>&lt;iframe&gt;</code> 中的 document，是 iframe.contentWindow.document 的简写形式；</li>
</ul>
<blockquote>
<p>Tips: 通过运行脚本设置拥有二级子域名子窗口的 <code>document.domain</code> 属性为主窗口的主域名，可以实现子窗口和主窗口无限制通信；</p>
</blockquote>
<p>获取 <code>&lt;iframe&gt;</code> 的 window 对象的另一个方式是从命名集合 window.frames 中获取：</p>
<ul>
<li>通过索引获取：window.frames[0] 文档中的第一个 iframe 的 window 对象；</li>
<li>通过名称获取：window.frames.iframeName 获取 name=”iframeName” 的 iframe 的 window 对象；</li>
</ul>
<p>多层嵌套 iframe：</p>
<ul>
<li>window.frames “子”窗口的集合（用于嵌套的 iframe）；</li>
<li>window.parent 对“父”（外部）窗口的引用；</li>
<li>window.top 对最顶级父窗口的引用；</li>
</ul>
<blockquote>
<p>Tips: 可以使用 <code>top</code> 属性来检查当前的文档是否是在 <code>iframe</code> 内打开的：<code>window == window.top</code>；</p>
</blockquote>
<p>sandbox 特性（attribute）允许在 <code>&lt;iframe&gt;</code> 中禁止某些特定行为，以防止其执行不被信任的代码；它通过将 iframe 视为非同源的，或者应用其他限制来实现 iframe 的“沙盒化”；</p>
<p>对于 <code>&lt;iframe sandbox src=&quot;...&quot;&gt;</code>，有一个应用于其上的默认的限制集，一个空的 “sandbox” 特性会施加最严格的限制，但是我们用一个以空格分隔的列表，列出要移除的限制；包括以下限制：</p>
<ul>
<li>allow-same-origin：默认情况下，”sandbox” 会为 iframe 强制实施“不同来源”的策略；</li>
<li>allow-top-navigation：允许 iframe 更改 parent.location；</li>
<li>allow-forms：允许在 iframe 中提交表单；</li>
<li>allow-scripts：允许在 iframe 中运行脚本；</li>
<li>allow-popups：允许在 iframe 中使用 window.open 打开弹窗；</li>
<li>allow-popups：允许在 iframe 中使用 window.open 打开弹窗；</li>
</ul>
<blockquote>
<p>Note: <code>sandbox</code> 特性的目的仅是添加更多限制，它无法移除这些限制；尤其是，如果 <code>iframe</code> 来自其他源，则无法放宽同源策略；</p>
</blockquote>
<p>postMessage 接口允许窗口之间相互通信，无论它们来自什么源；win.postMessage(data, targetOrigin) 方法，data 是要发送的数据，可以是任何对象，数据会被通过使用“结构化序列化算法（structured serialization algorithm）”进行克隆；targetOrigin 指定目标窗口的源，以便只有来自给定的源的窗口才能获得该消息；</p>
<p>targetOrigin 是一种安全措施，如果目标窗口是非同源的，我们无法在发送方窗口读取它的 location；如果不希望做这个检查，可以将 targetOrigin 设置为 *；</p>
<p>为了接收消息，目标窗口应该在 message 事件上有一个处理程序；当 postMessage 被调用时触发该事件（并且 targetOrigin 检查成功）；回调参数 event 对象具有特殊属性：</p>
<ul>
<li>data 从 postMessage 传递来的数据；</li>
<li>origin 发送方的源；</li>
<li>source 对发送方窗口的引用，可以通过 source.postMessage(…) 立即回复；</li>
</ul>
<blockquote>
<p>Note: <code>message</code> 事件只能通过 <code>addEventListener</code> 分配处理程序；</p>
</blockquote>
<h4 id="ArrayBuffer，二进制数组"><a href="#ArrayBuffer，二进制数组" class="headerlink" title="ArrayBuffer，二进制数组"></a>ArrayBuffer，二进制数组</h4><p>ArrayBuffer 是 JavaScript 中基本的二进制对象，是对固定长度的连续内存空间的引用；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配一个 16 字节的连续内存空间，并用 0 进行预填充</span></span><br><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>); </span><br></pre></td></tr></table></figure>

<p>如要操作 ArrayBuffer，需要使用“视图”对象；视图对象本身并不存储任何东西；它是一副“眼镜”，透过它来解释存储在 ArrayBuffer 中的字节；</p>
<ul>
<li>Uint8Array 将 ArrayBuffer 中的每个字节视为 0 到 255 之间的单个数字，这称为 “8 位无符号整数”；</li>
<li>Uint16Array 将每 2 个字节视为一个 0 到 65535 之间的整数，这称为 “16 位无符号整数”；</li>
<li>Uint32Array 将每 4 个字节视为一个 0 到 4294967295 之间的整数，这称为 “32 位无符号整数”；</li>
<li>Float64Array 将每 8 个字节视为一个 5.0x10^324 到 1.8x10^308 之间的浮点数；</li>
<li>Uint8ClampedArray 用于 8 位整数，在赋值时便“固定“其值；</li>
<li>Int8Array，Int16Array，Int32Array 用于有符号整数（可以为负数）；</li>
<li>Float32Array，Float64Array 用于 32 位和 64 位的有符号浮点数；</li>
</ul>
<p>所有这些视图（Uint8Array，Uint32Array 等）的通用术语是 TypedArray，它们都享有同一组方法和属性；构造方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果给定的是 ArrayBuffer 参数，则会在其上创建视图</span></span><br><span class="line"><span class="comment">// 给定起始位置 byteOffset（默认为 0）以及 length（默认至 buffer 的末尾），视图仅涵盖 buffer 的一段</span></span><br><span class="line"><span class="comment">// new TypedArray(buffer, [byteOffset], [length]);</span></span><br><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>); <span class="comment">// 创建一个长度为 16 的 buffer</span></span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(buffer); <span class="comment">// 将 buffer 视为一个 32 位整数的序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果给定的是 Array，或任何类数组对象，则会创建一个相同长度的类型化数组，并复制其内容</span></span><br><span class="line"><span class="comment">// new TypedArray(object);</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">alert( arr.length ); <span class="comment">// 4，创建了相同长度的二进制数组</span></span><br><span class="line">alert( arr[<span class="number">1</span>] ); <span class="comment">// 1，用给定值填充了 4 个字节（无符号 8 位整数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果给定的是另一个 TypedArray，也是如此：创建一个相同长度的类型化数组，并复制其内容；</span></span><br><span class="line"><span class="comment">// 如果需要的话，数据在此过程中会被转换为新的类型</span></span><br><span class="line"><span class="comment">// new TypedArray(typedArray);</span></span><br><span class="line"><span class="keyword">let</span> arr16 = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>([<span class="number">1</span>, <span class="number">1000</span>]);</span><br><span class="line"><span class="keyword">let</span> arr8 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(arr16);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于数字参数 length —— 创建类型化数组以包含这么多元素；</span></span><br><span class="line"><span class="comment">// 它的字节长度将是 length 乘以单个 TypedArray.BYTES_PER_ELEMENT 中的字节数</span></span><br><span class="line"><span class="comment">// new TypedArray(length);</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">4</span>); <span class="comment">// 为 4 个整数创建类型化数组</span></span><br><span class="line">alert( <span class="built_in">Uint16Array</span>.BYTES_PER_ELEMENT ); <span class="comment">// 每个整数 2 个字节</span></span><br><span class="line">alert( arr.byteLength ); <span class="comment">// 8（字节中的大小）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带参数的情况下，创建长度为零的类型化数组</span></span><br><span class="line"><span class="keyword">new</span> TypedArray();</span><br></pre></td></tr></table></figure>

<p>可以直接创建一个 TypedArray，而无需提及 ArrayBuffer，除第一种情况（已提供 ArrayBuffer）外，其他所有情况都会自动创建 ArrayBuffer；可以通过 buffer 属性，访问 ArrayBuffer，byteLength 属性获取 ArrayBuffer 的长度；</p>
<p>如果尝试将越界值写入类型化数组，多余的位被切除；Uint8ClampedArray 在这方面比较特殊，它的表现不太一样；对于大于 255 的任何数字，它将保存为 255，对于任何负数，它将保存为 0，此行为对于图像处理很有用；</p>
<p>TypedArray 具有常规的 Array 方法：</p>
<ul>
<li>可以遍历（iterate），map，slice，find 和 reduce 等；</li>
<li>没有 splice 和 concat；</li>
<li>arr.set(fromArr, [offset]) 从 offset（默认为 0）开始，将 fromArr 中的所有元素复制到 arr；</li>
<li>arr.subarray([begin, end]) 创建一个从 begin 到 end（不包括）相同类型的新视图，不复制任何内容；</li>
</ul>
<p>DataView 是在 ArrayBuffer 上的一种特殊的超灵活“未类型化”视图；它允许以任何格式访问任何偏移量（offset）的数据；</p>
<p>对于类型化的数组，构造器决定了其格式，整个数组应该是统一的，第 i 个数字是 arr[i]；通过 DataView，我们可以使用 .getUint8(i) 或 .getUint16(i) 之类的方法访问数据；可以在调用方法时选择格式，而不是在构造的时候；</p>
<p>通过调用 new DataView(buffer, [byteOffset], [byteLength]) 创建一个 dataView 视图；</p>
<ul>
<li>buffer 底层的 ArrayBuffer；与类型化数组不同，DataView 不会自行创建缓冲区（buffer）；</li>
<li>byteOffset 视图的起始字节位置（默认为 0）；</li>
<li>byteLength 视图的字节长度（默认至 buffer 的末尾）；</li>
</ul>
<blockquote>
<p>Note: 还有另外两个术语，用于对二进制数据进行操作的方法的描述：<code>ArrayBufferView</code> 是所有这些视图的总称，<code>BufferSource</code> 是 <code>ArrayBuffer</code> 和 <code>ArrayBufferView</code> 的总称；</p>
</blockquote>
<h4 id="TextDecoder-和-TextEncoder"><a href="#TextDecoder-和-TextEncoder" class="headerlink" title="TextDecoder 和 TextEncoder"></a>TextDecoder 和 TextEncoder</h4><p>内建的 TextDecoder 对象在给定缓冲区（buffer）和编码格式（encoding）的情况下，能够将值读取到实际的 JavaScript 字符串中；</p>
<p>decoder 通过 new TextDecoder([label], [options]) 创建：</p>
<ul>
<li>label 编码格式，默认为 utf-8，但同时也支持 big5，windows-1251 等许多其他编码格式；</li>
<li>options 可选对象；<ul>
<li>fatal 布尔值，如果为 true 则为无效（不可解码）字符抛出异常，否则（默认）用字符 \uFFFD 替换无效字符 ；</li>
<li>ignoreBOM 布尔值，如果为 true 则 BOM（可选的字节顺序 unicode 标记），很少需要使用；</li>
</ul>
</li>
</ul>
<p>通过 decoder.decode([input], [options]) 方法解码：</p>
<ul>
<li>input 要被解码的 BufferSource；</li>
<li>options 可选对象：<ul>
<li>stream 对于解码流，为 true，则将传入的数据块（chunk）作为参数重复调用 decoder；</li>
</ul>
</li>
</ul>
<p>stream 为 true 时，多字节的字符可能偶尔会在块与块之间被分割，这个选项告诉 TextDecoder 记住“未完成”的字符，并在下一个数据块来的时候进行解码；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uint8Array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>]);</span><br><span class="line"></span><br><span class="line">alert( <span class="keyword">new</span> TextDecoder().decode(uint8Array) ); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>TextEncoder 做相反的事情：将字符串转换为字节；通过 new TextEncoder() 创建；encoder 有两个方法：</p>
<ul>
<li>encode(str) 从字符串返回 Uint8Array；</li>
<li>encodeInto(str, destination) 将 str 编码到 destination 中，该目标必须为 Uint8Array；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> encoder = <span class="keyword">new</span> TextEncoder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uint8Array = encoder.encode(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">alert(uint8Array); <span class="comment">// 72,101,108,108,111</span></span><br></pre></td></tr></table></figure>

<h4 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h4><p>arrayBuffer 和视图（view）都是 ECMA 标准的一部分，是 JavaScript 的一部分；浏览器还有一个二进制类型大对象 Blob，Blob 对象表示一个不可变、原始数据的类文件对象，由可选的字符串 type（通常是 MIME 类型）和 blobParts 组成；</p>
<p>new Blob(blobParts, options) 创建一个 Blob；</p>
<ul>
<li>blobParts 是 Blob/BufferSource/String 类型的值的数组；</li>
<li>options 可选对象；<ul>
<li>type Blob 类型，通常是 MIME 类型；</li>
<li>endings 是否转换换行符，使 Blob 对应于当前操作系统的换行符（\r\n 或 \n）；默认为 “transparent”（不转换），或者 “native”（转换）；</li>
</ul>
</li>
</ul>
<p>可以用 blob.slice([byteStart], [byteEnd], [contentType]) 方法来提取 Blob 片段：</p>
<ul>
<li>byteStart 起始字节，默认为 0；</li>
<li>byteEnd 最后一个字节（专有，默认为最后）；</li>
<li>contentType 新 blob 的 type，默认与源 blob 相同；</li>
</ul>
<blockquote>
<p>Note: 无法直接在 <code>Blob</code> 中更改数据，但我们可以通过 <code>slice</code> 获得 <code>Blob</code> 的多个部分，从这些部分创建新的 <code>Blob</code> 对象，将它们组成新的 <code>Blob</code>；</p>
</blockquote>
<p><strong>Blob 作为 URL</strong></p>
<p>Blob 可以很容易用作 <code>&lt;a&gt;</code>、<code>&lt;img&gt;</code> 或其他标签的 URL，来显示它们的内容；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// download 特性（attribute）强制浏览器下载而不是导航</span></span><br><span class="line"><span class="comment">// &lt;a download=&quot;hello.txt&quot; href=&quot;blob:http://localhost:8000/c2d14ed6-c271-46be-9164-06042e419312&quot;&gt;hello.txt&lt;/a&gt;</span></span><br><span class="line"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([<span class="string">&quot;Hello, world!&quot;</span>], &#123; <span class="attr">type</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">link.download = <span class="string">&quot;hello.txt&quot;</span>;</span><br><span class="line">link.href = URL.createObjectURL(blob);</span><br><span class="line">link.innerHTML = <span class="string">&quot;hello.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到 DOM</span></span><br><span class="line"><span class="built_in">document</span>.body.append(link);</span><br><span class="line"><span class="comment">// 或者模拟点击，自动下载</span></span><br><span class="line">link.click();</span><br><span class="line"><span class="comment">// 从内部映射中移除引用</span></span><br><span class="line">URL.revokeObjectURL(link.href);</span><br></pre></td></tr></table></figure>

<p>URL.createObjectURL 取一个 Blob，并为其创建一个唯一的 URL，形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code>；浏览器内部为每个通过 URL.createObjectURL 生成的 URL 存储了一个 URL -&gt; Blob 映射，生成的 URL（即其链接）仅在当前文档打开的状态下才有效；</p>
<blockquote>
<p>Note: 如果我们创建一个 <code>URL</code>，那么即使我们不再需要该 <code>Blob</code> 了，它也会被挂在内存中；<code>URL.revokeObjectURL(url)</code> 从内部映射中移除引用，因此允许 <code>Blob</code> 被删除（如果没有其他引用的话），并释放内存；</p>
</blockquote>
<p><strong>Blob 转为 base64</strong></p>
<p>URL.createObjectURL 的一个替代方法是，将 Blob 转换为 base64-编码的字符串；这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读”；</p>
<p>可以在 “data-url” 中使用此编码，“data-url” 的形式为 <code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code>，并且可以在任何地方和“常规” url 一样使用这种 url；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([<span class="string">&#x27;Hello, world!&#x27;</span>], &#123;<span class="attr">type</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内建的 FileReader 对象可以将 Blob 转换为 base64；</span></span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">reader.readAsDataURL(blob); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 onload</span></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  link.href = reader.result; <span class="comment">// data url</span></span><br><span class="line">  link.click();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>Blob</code> 转换为 <code>data url</code>，当对大的 <code>Blob</code> 进行编码时，性能和内存会有损耗；</p>
</blockquote>
<p><strong>Image 转为 blob</strong></p>
<p>可以创建一个图像（image）的、图像的一部分、或者甚至创建一个页面截图的 Blob；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取任何图像</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成同尺寸的 &lt;canvas&gt;</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">canvas.width = img.clientWidth;</span><br><span class="line">canvas.height = img.clientHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> context = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向其中复制图像（此方法允许剪裁图像）</span></span><br><span class="line">context.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 我们 context.rotate()，并在 canvas 上做很多其他事情</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toBlob 是异步操作，结束后会调用 callback</span></span><br><span class="line"><span class="keyword">let</span> blob = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> canvasElem.toBlob(resolve, <span class="string">&#x27;image/png&#x27;</span>));</span><br><span class="line">  <span class="comment">// blob 创建完成，下载它</span></span><br><span class="line"><span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">link.download = <span class="string">&#x27;example.png&#x27;</span>;</span><br><span class="line"></span><br><span class="line">link.href = URL.createObjectURL(blob);</span><br><span class="line">link.click();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除内部 blob 引用，这样浏览器可以从内存中将其清除</span></span><br><span class="line">URL.revokeObjectURL(link.href);</span><br></pre></td></tr></table></figure>

<p><strong>Blob 转为 arrayBuffer</strong></p>
<p>Blob 构造器允许从几乎所有东西创建 blob，包括任何 BufferSource；如果需要执行低级别的操作的话，则可以使用 blob.arrayBuffer() 从 blob 中获取最低级别的 arrayBuffer；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 blob 获取 arrayBuffer</span></span><br><span class="line"><span class="keyword">const</span> bufferPromise = <span class="keyword">await</span> blob.arrayBuffer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">blob.arrayBuffer().then(<span class="function"><span class="params">buffer</span> =&gt;</span> <span class="comment">/* 处理 arrayBuffer */</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Blob 转为 stream</strong></p>
<p>当读取和写入超过 2 GB 的 blob 时，将其转换为 arrayBuffer 的使用对我们来说会更加占用内存；这种情况下，可以直接将 blob 转换为 stream 进行处理；stream 是一种特殊的对象，我们可以从它那里逐部分地读取（或写入）；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 blob 获取可读流（readableStream）</span></span><br><span class="line"><span class="keyword">const</span> readableStream = blob.stream();</span><br><span class="line"><span class="keyword">const</span> stream = readableStream.getReader();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 对于每次迭代：data 是下一个 blob 数据片段</span></span><br><span class="line">  <span class="keyword">let</span> &#123; done, data &#125; = <span class="keyword">await</span> stream.read();</span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="comment">// 读取完毕，stream 里已经没有数据了</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;all blob processed.&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对刚从 blob 中读取的数据片段做一些处理</span></span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File-和-FileReader"><a href="#File-和-FileReader" class="headerlink" title="File 和 FileReader"></a>File 和 FileReader</h4><p>File 对象继承自 Blob，并扩展了与文件系统相关的功能；</p>
<p>File 对象可以通古构造器创建 new File(fileParts, fileName, [options])；</p>
<ul>
<li>fileParts Blob/BufferSource/String 类型值的数组；</li>
<li>fileName 文件名字符串；</li>
<li>options 可选对象，<ul>
<li>lastModified 最后一次修改的时间戳（整数日期）；</li>
</ul>
</li>
</ul>
<p>或者通常从 <code>&lt;input type=&quot;file&quot;&gt;</code> 或拖放或其他浏览器接口来获取文件；在这种情况下，file 将从操作系统（OS）获得 this 信息；输入（input）可以选择多个文件，因此 input.files 是一个类数组对象；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> file = <span class="built_in">document</span>.createElement(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">file.type = <span class="string">&quot;file&quot;</span>;</span><br><span class="line">file.onchange = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.files[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.append(file);</span><br></pre></td></tr></table></figure>

<p>FileReader 是一个对象，其唯一目的是从 Blob（因此也从 File）对象中读取数据；但使用事件来传递数据，因为从磁盘读取数据可能比较费时间；</p>
<ul>
<li>创建：<ul>
<li>new FileReader() 一个无参构造函数；</li>
</ul>
</li>
<li>方法：<ul>
<li>readAsArrayBuffer(blob) 将数据读取为二进制格式的 ArrayBuffer；</li>
<li>readAsText(blob, [encoding]) 将数据读取为给定编码（默认为 utf-8 编码）的文本字符串；</li>
<li>readAsDataURL(blob) 读取二进制数据，并将其编码为 base64 的 data url；</li>
<li>abort() 取消操作；</li>
</ul>
</li>
<li>事件：<ul>
<li>loadstart 开始加载；</li>
<li>progress 在读取过程中出现；</li>
<li>load 读取完成，没有 error；</li>
<li>abort 调用了 abort()；</li>
<li>error 出现 error；</li>
<li>loadend 读取完成，无论成功还是失败；</li>
</ul>
</li>
<li>结果：<ul>
<li>reader.result 是结果（如果成功）；</li>
<li>reader.error 是 error（如果失败）；</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;readFile(this)&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">input</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> file = input.files[<span class="number">0</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"></span><br><span class="line">  reader.readAsText(file);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(reader.result);</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(reader.error);</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 对于 <code>Web Worker</code>，还有一种同步的 <code>FileReader</code> 变体，称为 <code>FileReaderSync</code>；读取方法 <code>read*</code> 不会生成事件，而是会像常规函数那样返回一个结果；</p>
</blockquote>
<h4 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h4><p>JavaScript 可以将网络请求发送到服务器，并在需要时加载新信息；fetch() 方法是一种现代通用的方法；</p>
<ul>
<li>语法：<ul>
<li>let promise = fetch(url, [options])</li>
</ul>
</li>
<li>参数：<ul>
<li>url 要访问的 URL；</li>
<li>options 可选参数：method，header 等；</li>
</ul>
</li>
<li>响应：<ul>
<li>status HTTP 状态码；</li>
<li>ok 布尔值，如果 HTTP 状态码为 200-299，则为 true；</li>
</ul>
</li>
<li>方法：<ul>
<li>response.text() 读取 response，并以文本形式返回 response；</li>
<li>response.json() 将 response 解析为 JSON；</li>
<li>response.formData() 以 FormData 对象的形式返回 response；</li>
<li>response.blob() 以 Blob（具有类型的二进制数据）形式返回 response；</li>
<li>response.arrayBuffer() 以 ArrayBuffer（低级别的二进制数据）形式返回 response；</li>
</ul>
</li>
</ul>
<p>没有 options fetch 就是一个简单的 GET 请求，下载 url 的内容；返回一个该调用代码应该用来获取结果的 promise；</p>
<p>获取响应分为两个阶段：第一阶段，当服务器发送了响应头（response header），fetch 返回的 promise 就使用内建的 Response class 对象来对响应头进行解析；第二阶段，需要使用其他的方法调用以获取 response body；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// await 调用</span></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url, options); <span class="comment">// 解析 response header</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> response.json(); <span class="comment">// 将 body 读取为 json</span></span><br><span class="line"><span class="comment">// 或者 promise</span></span><br><span class="line">fetch(url, options)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="comment">/* process result */</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例</span></span><br><span class="line">fetch(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.ok) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        res.text().then(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(text);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 如果已经使用了 <code>response</code> 读取方法来获取 <code>response</code>，那么如果再用另一种 <code>response</code> 方法，则不会生效，因为 <code>body</code> 内容已经被处理过了；</p>
</blockquote>
<p>Response header 位于 response.headers 中的一个类似于 Map 的 header 对象；但不是真正的 Map，只是具有类似的方法，可以按名称（name）获取各个 header，或迭代所有 header；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个 header</span></span><br><span class="line">alert(response.headers.get(<span class="string">&#x27;Content-Type&#x27;</span>)); <span class="comment">// application/json; charset=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代所有 header</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> response.headers) &#123;</span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 headers 选项在 fetch 中设置 request header，它有一个带有输出 header 的对象；但有一些无法设置的 header，参见 <a href="https://fetch.spec.whatwg.org/#forbidden-header-name">forbidden HTTP headers</a>；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> response = fetch(protectedUrl, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Authentication: <span class="string">&#x27;secret&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过设置选项中 method 可以创建一个 POST 或者其他类型的请求；此外选项中 body 字段会作为请求体发送，需是以下内容之一：</p>
<ul>
<li>字符串；</li>
<li>FormData 对象，以 form/multipart 形式发送数据；</li>
<li>Blob/BufferSource 发送二进制数据；</li>
<li>URLSearchParams，以 x-www-form-urlencoded 编码形式发送数据，很少使用；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  surname: <span class="string">&#x27;Smith&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/fetch/post/user&#x27;</span>, &#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(user)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> response.json();</span><br><span class="line">alert(result.message);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 如果请求的 body 是字符串，则 Content-Type 会默认设置为 text/plain;charset=UTF-8；但要发送 JSON 时，会使用 headers 选项来发送 application/json，这是 JSON 编码的数据的正确的 Content-Type；</p>
</blockquote>
<h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p>FormData 的特殊之处在于网络方法（network methods），例如 fetch 可以接受一个 FormData 对象作为 body；它会被编码并发送出去，带有 Content-Type: multipart/form-data；</p>
<ul>
<li>创建：如果提供了 HTML form 元素，它会自动捕获 form 元素字段<br>let formData = new FormData([form])</li>
<li>方法：<ul>
<li>formData.append(name, value) 添加具有给定 name 和 value 的表单字段；</li>
<li>formData.append(name, blob, fileName) 添加一个文件字段，相当于 <code>&lt;input type=&quot;file&quot;&gt;</code>，第三个参数 fileName 设置文件名；</li>
<li>formData.delete(name) 移除带有给定 name 的字段；</li>
<li>formData.get(name) 获取带有给定 name 的字段值；</li>
<li>formData.has(name) 如果存在带有给定 name 的字段，则返回 true，否则返回 false；</li>
<li>formData.set(name, value) 类似于 append，但移除所有具有给定 name 的字段，然后附加一个新字段；</li>
<li>formData.set(name, blob, fileName) 类似 append，同名字段值会被新值覆盖；</li>
</ul>
</li>
</ul>
<p>从技术上来讲，一个表单可以包含多个具有相同 name 的字段，因此，多次调用 append 将会添加多个具有相同名称的字段；而 set 方法确保了只有一个具有这种 name 的字段；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;formElem&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;surname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Smith&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  formElem.onsubmit = <span class="keyword">async</span> (e) =&gt; &#123;</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/formdata/post/user&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">      method: <span class="string">&#x27;POST&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      body: <span class="keyword">new</span> FormData(formElem)</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> result = <span class="keyword">await</span> response.json();</span></span><br><span class="line"></span><br><span class="line">    alert(result.message);</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表单始终以 Content-Type: multipart/form-data 来发送数据，这个编码允许发送文件；</p>
<h4 id="Fetch：下载进度"><a href="#Fetch：下载进度" class="headerlink" title="Fetch：下载进度"></a>Fetch：下载进度</h4><p>fetch 方法允许去跟踪下载进度，但到目前为止，fetch 方法无法跟踪上传进度；</p>
<p>要跟踪下载进度，可以使用 response.body 属性，它是一个可以逐块（chunk）提供 body 的特殊的对象 ReadableStream；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代替 response.json() 以及其他方法</span></span><br><span class="line"><span class="keyword">const</span> reader = response.body.getReader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 body 下载时，一直为无限循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 当最后一块下载完成时，done 值为 true</span></span><br><span class="line">  <span class="comment">// value 是块字节的 Uint8Array</span></span><br><span class="line">  <span class="keyword">const</span> &#123;done, value&#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Received <span class="subst">$&#123;value.length&#125;</span> bytes`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 await reader.read() 调用的结果是一个具有两个属性的对象：</p>
<ul>
<li>done 当读取完成时为 true，否则为 false；</li>
<li>value 字节的类型化数组：Uint8Array；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 1：启动 fetch，并获得一个 reader</span></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reader = response.body.getReader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2：获得总长度（length）</span></span><br><span class="line"><span class="keyword">const</span> contentLength = +response.headers.get(<span class="string">&#x27;Content-Length&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3：读取数据</span></span><br><span class="line"><span class="keyword">let</span> receivedLength = <span class="number">0</span>; <span class="comment">// 当前接收到了这么多字节</span></span><br><span class="line"><span class="keyword">let</span> chunks = []; <span class="comment">// 接收到的二进制块的数组（包括 body）</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;done, value&#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  chunks.push(value);</span><br><span class="line">  receivedLength += value.length;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Received <span class="subst">$&#123;receivedLength&#125;</span> of <span class="subst">$&#123;contentLength&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4：将块连接到单个 Uint8Array</span></span><br><span class="line"><span class="keyword">let</span> chunksAll = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(receivedLength); <span class="comment">// (4.1)</span></span><br><span class="line"><span class="keyword">let</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> chunk <span class="keyword">of</span> chunks) &#123;</span><br><span class="line">  chunksAll.set(chunk, position); <span class="comment">// (4.2)</span></span><br><span class="line">  position += chunk.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 5：解码成字符串</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">new</span> TextDecoder(<span class="string">&quot;utf-8&quot;</span>).decode(chunksAll);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们完成啦！</span></span><br><span class="line"><span class="keyword">let</span> commits = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">alert(commits[<span class="number">0</span>].author.login);</span><br></pre></td></tr></table></figure>

<h4 id="Fetch：中止"><a href="#Fetch：中止" class="headerlink" title="Fetch：中止"></a>Fetch：中止</h4><p>有一个特殊的内建对象：AbortController；它不仅可以中止 fetch，还可以中止其他异步任务；</p>
<ul>
<li>创建：</li>
<li>let controller = new AbortController();</li>
<li>方法：</li>
<li>abort() 中止异步操作；</li>
<li>属性：</li>
<li>signal 可以在这个属性上设置事件监听器；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line"><span class="keyword">let</span> signal = controller.signal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可取消的操作这一部分</span></span><br><span class="line"><span class="comment">// 获取 &quot;signal&quot; 对象，</span></span><br><span class="line"><span class="comment">// 并将监听器设置为在 controller.abort() 被调用时触发</span></span><br><span class="line">signal.addEventListener(<span class="string">&#x27;abort&#x27;</span>, <span class="function">() =&gt;</span> alert(<span class="string">&quot;abort!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一部分，取消（在之后的任何时候）：</span></span><br><span class="line">controller.abort(); <span class="comment">// 中止！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件触发，signal.aborted 变为 true</span></span><br><span class="line">alert(signal.aborted); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>为了能够取消 fetch，请将 AbortController 的 signal 属性作为 fetch 的一个可选参数（option）进行传递；fetch 方法知道如何与 AbortController 一起工作，它会监听 signal 上的 abort 事件；当一个 fetch 被中止，它的 promise 就会以一个 error AbortError reject，因此我们应该对其进行处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 秒后中止</span></span><br><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> controller.abort(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/fetch-abort/demo/hang&#x27;</span>, &#123;</span><br><span class="line">    signal: controller.signal</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.name == <span class="string">&#x27;AbortError&#x27;</span>) &#123; <span class="comment">// handle abort()</span></span><br><span class="line">    alert(<span class="string">&quot;Aborted!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbortController 是可伸缩的，它允许一次取消多个 fetch；如果我们有自己的与 fetch 不同的异步任务，我们可以使用单个 AbortController 中止这些任务以及 fetch；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urls = [...];</span><br><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ourJob = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// 我们的任务</span></span><br><span class="line">  ...</span><br><span class="line">  controller.signal.addEventListener(<span class="string">&#x27;abort&#x27;</span>, reject);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fetchJobs = urls.map(<span class="function"><span class="params">url</span> =&gt;</span> fetch(url, &#123; <span class="comment">// fetches</span></span><br><span class="line">  signal: controller.signal</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待完成我们的任务和所有 fetch</span></span><br><span class="line"><span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([...fetchJobs, ourJob]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 controller.abort() 被从其他地方调用，</span></span><br><span class="line"><span class="comment">// 它将中止所有 fetch 和 ourJob</span></span><br></pre></td></tr></table></figure>

<h4 id="Fetch：跨源请求"><a href="#Fetch：跨源请求" class="headerlink" title="Fetch：跨源请求"></a>Fetch：跨源请求</h4><p>可以使用 script 标签实现跨域，也成为 jsonp；</p>
<p>有两种类型的跨源请求：</p>
<ul>
<li>所有其他请求；</li>
<li>简单的请求：<ul>
<li>method 为 GET，POST 或 HEAD 类型；</li>
<li>仅允许自定义这些 header：Accept，Accept-Language，Content-Language，Content-Type 的值为 application/x-www-form-urlencoded，multipart/form-data 或 text/plain；</li>
</ul>
</li>
</ul>
<p>当尝试发送一个非简单请求时，浏览器会发送一个特殊的“预检（preflight）”请求到服务器，询问服务器，是否接受此类跨源请求，并且，除非服务器明确通过 header 进行确认，否则非简单请求不会被发送；</p>
<p>如果一个请求是跨源的，浏览器始终会向其添加 Origin header；服务器可以检查 Origin，如果同意接受这样的请求，就会在响应中添加一个特殊的 header Access-Control-Allow-Origin；</p>
<p>对于跨源请求，默认情况下，JavaScript 只能访问“简单” response header：Cache-Control，Content-Language，Content-Type，Expires，Last-Modified，Pragma；访问任何其他 response header 都将导致 error；</p>
<p>可能仍然存在有些 Web 服务将非标准方法视为一个信号：“这不是浏览器”；因此，为了避免误解，任何“非标准”请求，浏览器不会立即发出在过去无法完成的这类请求；即在它发送这类请求前，会先发送“预检（preflight）”请求来请求许可；预检请求发生在“幕后”，它对 JavaScript 不可见；</p>
<p>预检请求使用 OPTIONS 方法，它没有 body，但是有两个 header：</p>
<ul>
<li>Access-Control-Request-Method header 带有非简单请求的方法；</li>
<li>Access-Control-Request-Headers header 提供一个以逗号分隔的非简单 HTTP-header 列表；</li>
</ul>
<p>如果服务器同意处理请求，那么它会进行响应，此响应的状态码应该为 200，没有 body，具有 header：</p>
<ul>
<li>Access-Control-Allow-Origin 必须为 * 或进行请求的源才能允许此请求；</li>
<li>Access-Control-Allow-Methods 必须具有允许的方法；</li>
<li>Access-Control-Allow-Headers 必须具有一个允许的 header 列表；</li>
<li>header Access-Control-Max-Age 可以指定缓存此权限的秒数，因此，浏览器不是必须为满足给定权限的后续请求发送预检；</li>
</ul>
<blockquote>
<p>Note: 服务器不应该忘记在主响应中添加 <code>Access-Control-Allow-Origin</code>，成功的预检并不能免除此要求；</p>
</blockquote>
<p>默认情况下，由 JavaScript 代码发起的跨源请求不会带来任何凭据，cookies 或者 HTTP 认证（HTTP authentication）；这是因为具有凭据的请求比没有凭据的请求要强大得多，如果被允许，它会使用它们的凭据授予 JavaScript 代表用户行为和访问敏感信息的全部权力；</p>
<p>服务器必须显式地带有允许请求的凭据和附加 header，如果服务器同意接受 带有凭据 的请求，则除了 Access-Control-Allow-Origin 外，服务器还应该在响应中添加 header Access-Control-Allow-Credentials: true；对于具有凭据的请求，禁止 Access-Control-Allow-Origin 使用星号 *；</p>
<ul>
<li><a href="https://zh.javascript.info/fetch-crossorigin">JavaScript 现代教程-Fetch：跨源请求</a></li>
</ul>
<h4 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = fetch(url, &#123;</span><br><span class="line">  method: <span class="string">&quot;GET&quot;</span>, <span class="comment">// POST，PUT，DELETE，等。</span></span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="comment">// 内容类型 header 值通常是自动设置的</span></span><br><span class="line">    <span class="comment">// 取决于 request body</span></span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain;charset=UTF-8&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="literal">undefined</span> <span class="comment">// string，FormData，Blob，BufferSource，或 URLSearchParams</span></span><br><span class="line">  referrer: <span class="string">&quot;about:client&quot;</span>, <span class="comment">// 或 &quot;&quot; 以不发送 Referer header，</span></span><br><span class="line">  <span class="comment">// 或者是当前源的 url</span></span><br><span class="line">  referrerPolicy: <span class="string">&quot;no-referrer-when-downgrade&quot;</span>, <span class="comment">// no-referrer，origin，same-origin...</span></span><br><span class="line">  mode: <span class="string">&quot;cors&quot;</span>, <span class="comment">// same-origin，no-cors</span></span><br><span class="line">  credentials: <span class="string">&quot;same-origin&quot;</span>, <span class="comment">// omit，include</span></span><br><span class="line">  cache: <span class="string">&quot;default&quot;</span>, <span class="comment">// no-store，reload，no-cache，force-cache，或 only-if-cached</span></span><br><span class="line">  redirect: <span class="string">&quot;follow&quot;</span>, <span class="comment">// manual，error</span></span><br><span class="line">  integrity: <span class="string">&quot;&quot;</span>, <span class="comment">// 一个 hash，像 &quot;sha256-abcdef1234567890&quot;</span></span><br><span class="line">  keepalive: <span class="literal">false</span>, <span class="comment">// true keepalive 选项表示该请求可能会在网页关闭后继续存在</span></span><br><span class="line">  signal: <span class="literal">undefined</span>, <span class="comment">// AbortController 来中止请求</span></span><br><span class="line">  <span class="built_in">window</span>: <span class="built_in">window</span> <span class="comment">// null</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://zh.javascript.info/long-polling">JavaScript 现代教程-长轮询（Long polling）</a></li>
</ul>
<h4 id="URL-对象"><a href="#URL-对象" class="headerlink" title="URL 对象"></a>URL 对象</h4><p>内建的 URL 类提供了用于创建和解析 URL 的便捷接口；URL 对象立即允许我们访问其组件，因此这是一个解析 url 的好方法；</p>
<ul>
<li>创建 new URL(url, [base])：<ul>
<li>url 完整的 URL，或者仅路径（如果设置了 base）；</li>
<li>base 可选的 base URL：如果设置了此参数，且参数 url 只有路径，则会根据这个 base 生成 URL；</li>
</ul>
</li>
<li>组件：<ul>
<li>href 是完整的 URL，与 url.toString() 相同；</li>
<li>protocol 以冒号字符 : 结尾；</li>
<li>search 以问号 ? 开头的一串参数；</li>
<li>hash 以哈希字符 # 开头；</li>
</ul>
</li>
<li>方法：<ul>
<li>append(name, value) 按照 name 添加参数；</li>
<li>delete(name) 按照 name 移除参数；</li>
<li>get(name) 按照 name 获取参数；</li>
<li>getAll(name) 获取相同 name 的所有参数；</li>
<li>has(name) 按照 name 检查参数是否存在；</li>
<li>set(name, value) set/replace 参数；</li>
<li>sort() 按 name 对参数进行排序，很少使用；</li>
</ul>
</li>
</ul>
<blockquote>
<p>Tips: 可以在 <code>fetch</code> 或 <code>XMLHttpRequest</code> 中使用 <code>URL</code> 对象，几乎可以在任何需要 <code>URL</code> 字符串的地方都能使用 <code>URL</code> 对象，大多数方法都会执行字符串转换，这会将 <code>URL</code> 对象转换为具有完整 <code>URL</code> 的字符串；</p>
</blockquote>
<p>URL 对象会自动处理那些不被允许的字符必须被编码，用其 UTF-8 代码代替；</p>
<p>下面是用于编码/解码 URL 的内建函数：</p>
<ul>
<li>encodeURI 编码整个 URL；</li>
<li>decodeURI 解码为编码前的状态；</li>
<li>encodeURIComponent 编码 URL 组件，例如搜索参数，或者 hash，或者 pathname；</li>
<li>decodeURIComponent 解码为编码前的状态；</li>
</ul>
<blockquote>
<p>Note: <code>encodeURI</code> 仅编码 <code>URL</code> 中完全禁止的字符；<code>encodeURIComponent</code> 也编码这类字符，此外，还编码 <code># $ &amp; + , / : ; = ? @</code> 字符；因此对于一个 <code>URL</code> 整体，可以使用 <code>encodeURI</code>，对于 <code>URL</code> 参数，应该改用 <code>encodeURIComponent</code>；</p>
</blockquote>
<blockquote>
<p>Note: <code>encode*</code> 与 <code>URL</code> 在对 IPv6 地址的编码方式不同，<code>URL</code> 可以正确编码；</p>
</blockquote>
<h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><p>XMLHttpRequest 是一个内建的浏览器对象，它允许使用 JavaScript 发送 HTTP 请求；XMLHttpRequest 有两种执行模式：同步（synchronous）和异步（asynchronous）；</p>
<ul>
<li>创建：let xhr = new XMLHttpRequest();</li>
<li>初始化：xhr.open(method, URL, [async, user, password])<ul>
<li>method HTTP 方法，通常是 “GET” 或 “POST”；</li>
<li>URL 要请求的 URL，通常是一个字符串，也可以是 URL 对象；</li>
<li>async 如果显式地设置为 false，那么请求将会以同步的方式处理；</li>
<li>user，password HTTP 基本身份验证（如果需要的话）的登录名和密码；</li>
</ul>
</li>
<li>发送请求：xhr.send([body])；</li>
<li>监听响应：<ul>
<li>load 当请求完成，并且响应已完全下载；</li>
<li>error 当无法发出请求，例如网络中断或者无效的 URL；</li>
<li>progress 在下载响应期间定期触发，报告已经下载了多少；</li>
</ul>
</li>
<li>响应：<ul>
<li>status HTTP 状态码（一个数字）：如果出现非 HTTP 错误，则为 0；</li>
<li>statusText HTTP 状态消息（一个字符串）；</li>
<li>response（旧脚本可能是 responseText）：服务器 response body；</li>
</ul>
</li>
<li>xhr 属性：<ul>
<li>timeout 超时时间，在给定时间内请求没有成功执行，请求就会被取消，并且触发 timeout 事件；</li>
<li>responseType 响应类型，<ul>
<li>“” 响应格式为字符串（默认）；</li>
<li>“text” 响应格式为字符串；</li>
<li>“arraybuffer” 响应格式为 ArrayBuffer；</li>
<li>“blob” 响应格式为 Blob；</li>
<li>“document” 响应格式为 XML document；</li>
<li>“json” 响应格式为 JSON（自动解析）；</li>
</ul>
</li>
<li>readyState 请求处理状态，XMLHttpRequest 的状态会随着它的处理进度变化而变化；<ul>
<li>0 UNSENT 初始状态；</li>
<li>1 OPENED open 被调用；</li>
<li>2 HEADERS_RECEIVED 接收到 response header；</li>
<li>3 LOADING 响应正在被加载，每接收到一个数据包会重复一次该状态；</li>
<li>4 DONE 请求完成；</li>
</ul>
</li>
<li>withCredentials true，将 cookie 和 HTTP 授权发送到其他域，默认 false；</li>
<li>abort() 方法，终止请求；会触发 abort 事件，且 xhr.status 变为 0；</li>
<li>setRequestHeader(name, value) 使用给定的 name 和 value 设置 request header；</li>
<li>getResponseHeader(name) 获取具有给定 name 的 header（Set-Cookie 和 Set-Cookie2 除外）；</li>
<li>getAllResponseHeaders() 返回除 Set-Cookie 和 Set-Cookie2 外的所有 response header；</li>
</ul>
</li>
<li>xhr 事件：上传需要专门用于跟踪上传事件的 xhr.upload 对象上监听；<ul>
<li>readystatechange 事件，跟踪请求处理状态变化；</li>
<li>loadstart 请求开始；</li>
<li>progress 一个响应数据包到达，此时整个 response body 都在 response 中；</li>
<li>abort 调用 xhr.abort() 取消了请求；</li>
<li>error 发生连接错误，例如，域错误。不会发生诸如 404 这类的 HTTP 错误；</li>
<li>load 请求成功完成；</li>
<li>timeout 由于请求超时而取消了该请求（仅发生在设置了 timeout 的情况下）；</li>
<li>loadend 在 load，error，timeout 或 abort 之后触发；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 new XMLHttpRequest 对象</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置它：从 URL /article/.../load GET-request</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/article/xmlhttprequest/example/load&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过网络发送请求</span></span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 当接收到响应后，将调用此函数</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.status != <span class="number">200</span>) &#123; <span class="comment">// 分析响应的 HTTP 状态</span></span><br><span class="line">    alert(<span class="string">`Error <span class="subst">$&#123;xhr.status&#125;</span>: <span class="subst">$&#123;xhr.statusText&#125;</span>`</span>); <span class="comment">// 例如 404: Not Found</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 显示结果</span></span><br><span class="line">    alert(<span class="string">`Done, got <span class="subst">$&#123;xhr.response.length&#125;</span> bytes`</span>); <span class="comment">// response 是服务器响应</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">    alert(<span class="string">`Received <span class="subst">$&#123;event.loaded&#125;</span> of <span class="subst">$&#123;event.total&#125;</span> bytes`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">`Received <span class="subst">$&#123;event.loaded&#125;</span> bytes`</span>); <span class="comment">// 没有 Content-Length</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Request failed&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧代码中会使用 onreadystatechange 事件监听器</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 加载中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// 请求完成</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果在 open 方法中将第三个参数 async 设置为 false，那么请求就会以同步的方式进行；JavaScript 执行在 send() 处暂停，并在收到响应后恢复执行；</p>
<blockquote>
<p>Note: <code>XMLHttpRequest</code> 的另一个特点是不能撤销 <code>setRequestHeader</code>；一旦设置了 <code>header</code>，就无法撤销了。其他调用会向 <code>header</code> 中添加信息，但不会覆盖它；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带有进度指示的文件上传</span></span><br><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> onchange=<span class="string">&quot;upload(this.files[0])&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跟踪上传进度</span></span><br><span class="line">  xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Uploaded <span class="subst">$&#123;event.loaded&#125;</span> of <span class="subst">$&#123;event.total&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跟踪完成：无论成功与否</span></span><br><span class="line">  xhr.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;error &quot;</span> + <span class="built_in">this</span>.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.open(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/article/xmlhttprequest/post/upload&quot;</span>);</span><br><span class="line">  xhr.send(file);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://zh.javascript.info/resume-upload">JavaScript 现代教程-可恢复的文件上传</a></li>
</ul>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket 协议提供了一种在浏览器和服务器之间建立持久连接来交换数据的方法，数据可以作为“数据包”在两个方向上传递，而不会断开连接和其他 HTTP 请求；</p>
<ul>
<li>创建：let socket = new WebSocket(“ws://javascript.info”, [“soap”, “wamp”]);<ul>
<li>第一个参数为服务器地址；</li>
<li>第二个参数可选的子协议数组；</li>
</ul>
</li>
<li>事件：<ul>
<li>open 连接已建立；</li>
<li>message 接收到数据；</li>
<li>error WebSocket 错误；</li>
<li>close 连接已关闭；</li>
</ul>
</li>
<li>请求头：<ul>
<li>Origin 客户端页面的源，允许服务器决定是否使用 WebSocket 与该网站通信；</li>
<li>Connection: Upgrade 表示客户端想要更改协议；</li>
<li>Upgrade: websocket 请求的协议是 “websocket”；</li>
<li>Sec-WebSocket-Key 浏览器随机生成的安全密钥；</li>
<li>Sec-WebSocket-Version WebSocket 协议版本；</li>
</ul>
</li>
<li>数据传输：WebSocket 通信由 frames（即数据片段）组成，可以从任何一方发送，并且有以下几种类型；<ul>
<li>text frames 包含各方发送给彼此的文本数据；</li>
<li>binary data frames 包含各方发送给彼此的二进制数据；</li>
<li>ping/pong frames 被用于检查从服务器发送的连接，浏览器会自动响应它们；</li>
<li>connection close frame 以及其他服务 frames；</li>
</ul>
</li>
<li>方法：<ul>
<li>send(data) 可以发送文本或二进制数据；</li>
<li>socket.close([code], [reason]) 可以发送一个带有数字码（numeric code）和文本形式的原因的 “connection close frame”；</li>
</ul>
</li>
<li>数字码；<ul>
<li>1000 默认，正常关闭，如果没有指明 code 时使用它；</li>
<li>1006 没有办法手动设定这个数字码，表示连接丢失（没有 close frame）；</li>
<li>1001 一方正在离开，例如服务器正在关闭，或者浏览器离开了该页面；</li>
<li>1009 消息太大，无法处理；</li>
<li>1011 服务器上发生意外错误；</li>
</ul>
</li>
<li>连接状态：可以通过带有值的 socket.readyState 属性获取；<ul>
<li>0 CONNECTING：连接还未建立；</li>
<li>1 OPEN：通信中；</li>
<li>2 CLOSING：连接关闭中；</li>
<li>3 CLOSED：连接已关闭；</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: <code>wss://</code> 是基于 TLS 的 WebSocket，类似于 HTTPS 是基于 TLS 的 HTTP，传输安全层在发送方对数据进行了加密，在接收方进行解密；因此，数据包是通过代理加密传输的，它们看不到传输的里面的内容，且会让这些数据通过；</p>
</blockquote>
<blockquote>
<p>Note: WebSocket 对象是原生支持跨源的，没有特殊的 header 或其他限制；旧的服务器无法处理 WebSocket，因此不存在兼容性问题；如果服务器同意切换为 WebSocket 协议，服务器应该返回响应码 <code>101</code>；</p>
</blockquote>
<p>在浏览器里，仅直接使用文本或二进制 frames；socket.send(body) 调用允许 body 是字符串或二进制格式，包括 Blob，ArrayBuffer 等；当我们收到数据时，文本总是以字符串形式呈现，对于二进制数据默认为 “blob”，因此二进制数据通常以 Blob 对象呈现，可以通过 socket.binaryType 属性设置；</p>
<blockquote>
<p>Note: 在网速受限的情况下，反复地调用 <code>socket.send(data)</code> 时，数据将会缓冲（储存）在内存中，并且只能在网速允许的情况下尽快将数据发送出去；<code>socket.bufferedAmount</code> 属性储存目前已缓冲的字节数，等待通过网络发送；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个简单的服务器端 WebSocket</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    WebSocketServer,</span><br><span class="line">    WebSocket</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;ws&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123;</span><br><span class="line">    port: <span class="number">8081</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">data, isBinary</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;received: %s&#x27;</span>, data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="string">&quot;online&quot;</span>) &#123;</span><br><span class="line">            ws.send(wss.clients.size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wss.clients.forEach(<span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123;</span><br><span class="line">                  client.send(data, &#123; <span class="attr">binary</span>: isBinary &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.send(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Server-Sent-Events"><a href="#Server-Sent-Events" class="headerlink" title="Server-Sent Events"></a>Server-Sent Events</h4><p>Server-Sent Events 规范描述了一个内建的类 EventSource，它能保持与服务器的连接，并允许从中接收事件，与 WebSocket 类似，其连接是持久的；</p>
<table>
<thead>
<tr>
<th align="left">WebSocket</th>
<th align="left">EventSource</th>
</tr>
</thead>
<tbody><tr>
<td align="left">双向：客户端和服务端都能交换消息</td>
<td align="left">单向：仅服务端能发送消息</td>
</tr>
<tr>
<td align="left">二进制和文本数据</td>
<td align="left">仅文本数据</td>
</tr>
<tr>
<td align="left">WebSocket 协议</td>
<td align="left">常规 HTTP 协议</td>
</tr>
</tbody></table>
<ul>
<li>创建：let source = new EventSource(url, [credentials]);<ul>
<li>第二个参数只有一个可选项 { withCredentials: true }，它允许发送跨源凭证；</li>
</ul>
</li>
<li>事件：默认情况下 EventSource 对象生成三个事件：<ul>
<li>message 收到消息，可以用 event.data 访问；</li>
<li>open 连接已打开；</li>
<li>error 无法建立连接，例如，服务器返回 HTTP 500 状态码；</li>
</ul>
</li>
<li>属性：<ul>
<li>lastEventId 最后接收到的 id；重新连接后，浏览器在 header Last-Event-ID 中发送此 id；</li>
<li>readyState 连接状态<ul>
<li>0 EventSource.CONNECTING 表示连接中或者重连中</li>
<li>1 EventSource.OPEN 表示已连接</li>
<li>2 EventSource.CLOSED 表示连接已关闭</li>
</ul>
</li>
</ul>
</li>
<li>响应：服务器发送由 \n\n 分隔的消息，一条消息可以按任何顺序包含一个或多个字段，但是 id: 通常排在最后；<ul>
<li>data: 消息体（body），一系列多个 data 被解释为单个消息，各个部分之间由 \n 分隔；</li>
<li>id: 更新 lastEventId，重连时以 Last-Event-ID 发送此 id；</li>
<li>retry: 建议重连的延迟，以 ms 为单位。无法通过 JavaScript 进行设置；</li>
<li>event: 事件名，必须在 data: 之前；</li>
</ul>
</li>
</ul>
<p>服务器响应状态码应该为 200，header 为 Content-Type: text/event-stream，然后保持此连接并以一种特殊的格式写入消息；复杂的消息通常是用 JSON 编码后发送；</p>
<p>EventSource 支持跨源请求，就像 fetch 任何其他网络方法，可以使用任何 URL；远程服务器将会获取到 Origin header，并且必须以 Access-Control-Allow-Origin 响应来处理；</p>
<p><strong>重新连接</strong></p>
<p>如果与创建连接的服务器，连接断开则会自动重新连接，每次重新连接之间有一点小的延迟，默认为几秒钟；服务器可以使用 retry: 来设置需要的延迟响应时间（以毫秒为单位）；retry: 既可以与某些数据一起出现，也可以作为独立的消息出现；</p>
<p>如果服务器想要浏览器停止重新连接，那么它应该使用 HTTP 状态码 204 进行响应，如果浏览器想要关闭连接，则应该调用 eventSource.close()；当连接最终被关闭时，就无法“重新打开”它；如果想要再次连接，只需要创建一个新的 EventSource；</p>
<p>如果响应具有不正确的 Content-Type 或者其 HTTP 状态码不是 301，307，200 和 204，则不会进行重新连接；在这种情况下，将会发出 “error” 事件，并且浏览器不会重新连接；</p>
<p><strong>事件</strong></p>
<p>服务器可以在事件开始时使用 event: … 指定另一种类型事件，此外还可以通过 addEventListener 监听自定义事件；</p>
<h4 id="Cookie，document-cookie"><a href="#Cookie，document-cookie" class="headerlink" title="Cookie，document.cookie"></a>Cookie，document.cookie</h4><p>Cookie 是直接存储在浏览器中的一小串数据，它们是 HTTP 协议的一部分，Cookie 通常是由 Web 服务器使用响应 Set-Cookie HTTP-header 设置的，然后浏览器使用 Cookie HTTP-header 将它们自动添加到（几乎）每个对相同域的请求中；</p>
<p>document.cookie 的值由 name=value 对组成，以 ; 分隔，每一个都是独立的 cookie；对 document.cookie 的写入操作只会更新其中提到的 cookie，而不会涉及其他 cookie；</p>
<blockquote>
<p>Note: 从技术上讲，<code>cookie</code> 的名称和值可以是任何字符，为了保持有效的格式，它们应该使用内建的 <code>encodeURIComponent</code> 函数对其进行转义；</p>
</blockquote>
<blockquote>
<p>Note: 一个 cookie 最大为 4KB，每个域的 <code>cookie</code> 总数不得超过 <code>20+</code> 左右，具体限制取决于浏览器；</p>
</blockquote>
<p>cookie 的其他选项：</p>
<ul>
<li>path url 路径前缀，该路径下的页面可以访问该 cookie，必须是绝对路径，默认为当前路径；</li>
<li>domain 可访问 cookie 的域，无法使 cookie 可以被从另一个二级域访问，但其子域名可以访问；</li>
<li>expire cookie 的到期日期，那时浏览器会自动删除它，日期必须完全采用 GMT 时区的这种格式；如果将 expires 设置为过去的时间，则 cookie 会被删除；</li>
<li>max-age expires 的替代选项，具指明 cookie 的过期时间距离当前时间的秒数，如果为 0 或负数，则 cookie 会被删除；</li>
<li>secure Cookie 应只能被通过 HTTPS 传输，默认情况下，cookie 是基于域的，不区分协议；</li>
<li>samesite 用于防止 XSRF（跨网站请求伪造）攻击，samesite=strict 或 samesite 采用严格模式，samesite=lax 宽松模式；</li>
<li>httpOnly 服务器端可以设置该选项禁止任何 JavaScript 访问 cookie；那么 document.cookie 看不到 cookie；</li>
</ul>
<p>默认情况下，如果一个 cookie 没有设置 expire、max-age 这两个参数中的任何一个，那么在关闭浏览器之后，它就会消失，此类 cookie 被称为 “session cookie”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回具有给定 name 的 cookie，</span></span><br><span class="line"><span class="comment">// 如果没找到，则返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> matches = <span class="built_in">document</span>.cookie.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(</span><br><span class="line">    <span class="string">&quot;(?:^|; )&quot;</span> + name.replace(<span class="regexp">/([\.$?*|&#123;&#125;\(\)\[\]\\\/\+^])/g</span>, <span class="string">&#x27;\\$1&#x27;</span>) + <span class="string">&quot;=([^;]*)&quot;</span></span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> matches ? <span class="built_in">decodeURIComponent</span>(matches[<span class="number">1</span>]) : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  options = &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果需要，可以在这里添加其他默认值</span></span><br><span class="line">    ...options</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    options.expires = options.expires.toUTCString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updatedCookie = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&quot;=&quot;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> optionKey <span class="keyword">in</span> options) &#123;</span><br><span class="line">    updatedCookie += <span class="string">&quot;; &quot;</span> + optionKey;</span><br><span class="line">    <span class="keyword">let</span> optionValue = options[optionKey];</span><br><span class="line">    <span class="keyword">if</span> (optionValue !== <span class="literal">true</span>) &#123;</span><br><span class="line">      updatedCookie += <span class="string">&quot;=&quot;</span> + optionValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.cookie = updatedCookie;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  setCookie(name, <span class="string">&quot;&quot;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;max-age&#x27;</span>: -<span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用范例：</span></span><br><span class="line">setCookie(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, &#123;<span class="attr">secure</span>: <span class="literal">true</span>, <span class="string">&#x27;max-age&#x27;</span>: <span class="number">3600</span>&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 如果一个脚本设置了一个 <code>cookie</code>，那么无论脚本来自何处这个 <code>cookie</code> 都属于当前网页的域；</p>
</blockquote>
<blockquote>
<p>Note: 如果 <code>cookie</code> 是由用户所访问的页面的域以外的域放置的，则称其为第三方 <code>cookie</code>，通常用于跟踪和广告服务；</p>
</blockquote>
<h4 id="LocalStorage，sessionStorage"><a href="#LocalStorage，sessionStorage" class="headerlink" title="LocalStorage，sessionStorage"></a>LocalStorage，sessionStorage</h4><p>Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器上保存键/值对；</p>
<p>两个存储对象都提供相同的方法和属性：</p>
<ul>
<li>setItem(key, value) 存储键/值对；</li>
<li>getItem(key) 按照键获取值；</li>
<li>removeItem(key) 删除键及其对应的值；</li>
<li>clear() 删除所有数据；</li>
<li>key(index) 获取该索引下的键名；</li>
<li>length 存储的内容的长度，只读；</li>
</ul>
<p>localStorage 最主要的特点是：</p>
<ul>
<li>在同源的所有标签页和窗口之间共享数据；</li>
<li>数据不会过期，它在浏览器重启甚至系统重启后仍然存在；</li>
<li>可以像使用一个普通对象那样，读取/设置键，且存储对象是不可迭代的；</li>
<li>键和值都必须是字符串；如果是任何其他类型，会被自动转换为字符串；</li>
</ul>
<p>sessionStorage 特点：</p>
<ul>
<li>sessionStorage 的数据只存在于当前浏览器标签页，具有相同页面的另一个标签页中将会有不同的存储；但在同一标签页下的同源 iframe 之间是共享的；数据在页面刷- 新后仍然保留，但在关闭/重新打开浏览器标签页后不会被保留</li>
</ul>
<blockquote>
<p>Note: 存储对象是不可迭代的；可以通过 Object.keys() 或者 for..in （需要 hasOwnProperty 检查）遍历；</p>
</blockquote>
<p>当 localStorage 或 sessionStorage 中的数据更新后，storage 事件就会触发，但以类对象方式访问时，不会触发该事件；</p>
<ul>
<li>key 发生更改的数据的 key（如果调用的是 .clear() 方法，则为 null）；</li>
<li>oldValue 旧值（如果是新增数据，则为 null）；</li>
<li>newValue 新值（如果是删除数据，则为 null）；</li>
<li>url 发生数据更新的文档的 url；</li>
<li>storageArea 发生数据更新的 localStorage 或 sessionStorage 对象；</li>
</ul>
<p>该事件会在所有可访问到存储对象的 window 对象上触发，导致当前数据改变的 window 对象除外；如果两个窗口都在监听 window.onstorage 事件，那么每个窗口都会对另一个窗口中发生的更新作出反应；</p>
<h4 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h4><p>IndexedDB 是一个浏览器内建的数据库：</p>
<ul>
<li>通过支持多种类型的键，来存储几乎可以是任何类型的值；</li>
<li>支撑事务的可靠性；</li>
<li>支持键范围查询、索引；</li>
<li>和 localStorage 相比，它可以存储更大的数据量；</li>
</ul>
<p>对于传统的客户端-服务器应用，这些功能通常是没有必要的；IndexedDB 适用于离线应用，可与 ServiceWorkers 和其他技术相结合使用；</p>
<p>创建连接：let openRequest = indexedDB.open(name, version);</p>
<ul>
<li>name 字符串，即数据库名称；</li>
<li>version 一个正整数版本，默认为 1；</li>
</ul>
<p>其他用法：</p>
<ul>
<li><p>获取一个 promise 包装器，比如 idb；</p>
</li>
<li><p>打开一个数据库：idb.openDb(name, version, onupgradeneeded)</p>
<ul>
<li>在 onupgradeneeded 处理程序中创建对象存储和索引，或者根据需要执行版本更新；</li>
</ul>
</li>
<li><p>对于请求：</p>
<ul>
<li>创建事务 db.transaction(‘books’)（如果需要的话，设置 readwrite）；</li>
<li>获取对象存储 transaction.objectStore(‘books’)；</li>
</ul>
</li>
<li><p>按键搜索，可以直接调用对象库上的方法，要按对象字段搜索，需要创建索引；</p>
</li>
<li><p>如果内存中容纳不下数据，可以使用光标；</p>
</li>
<li><p><a href="https://zh.javascript.info/indexeddb">JavaScript 现代教程-IndexedDB</a></p>
</li>
</ul>
<h4 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h4><p>CSS 动画可以在不借助 Javascript 的情况下做出一些简单的动画效果；</p>
<p>CSS 提供了四个属性来描述一个过渡：</p>
<ul>
<li>transition-property 列举要设置动画的所有属性，all 表示应用在所有属性上，但不是所有的 CSS 属性都可以使用过渡动画；</li>
<li>transition-duration 允许我们指定动画持续的时间，单位为s 或者 ms；</li>
<li>transition-timing-function 时间函数描述了动画进程在时间上的分布，如果没有指定时间函数，那么将使用 ease 作为默认值；</li>
<li>transition-delay 允许设定动画开始前的延迟时间；还可以提供一个负值，使动画从整个过渡的中间时刻开始渲染；</li>
</ul>
<p>也可以在 transition 中以 property duration timing-function delay 的顺序一次性定义它们，并且可以同时为多个属性设置过渡动画；</p>
<p><strong>贝塞尔曲线</strong></p>
<p>时间函数可以用贝塞尔曲线描述，通过设置四个满足以下条件的控制点：</p>
<ul>
<li>第一个应为：(0,0)。</li>
<li>最后一个应为：(1,1)。</li>
<li>对于中间值，x 必须位于 0..1 之间，y 可以为任意值</li>
</ul>
<p>CSS 中设置一贝塞尔曲线的语法为：cubic-bezier(x2, y2, x3, y3)，只需要设置第二个和第三个值，因为第一个点固定为 (0,0)，第四个点固定为 (1,1)；</p>
<p>CSS 提供几条内建的曲线：</p>
<ul>
<li>linear cubic-bezier(0, 0, 1, 1)</li>
<li>ease cubic-bezier(0.25, 0.1, 0.25, 1.0)</li>
<li>ease-in cubic-bezier(0.42, 0, 1.0, 1.0)</li>
<li>ease-out cubic-bezier(0, 0, 0.58, 1.0)</li>
<li>ease-in-out cubic-bezier(0.42, 0, 0.58, 1.0)</li>
</ul>
<p>贝塞尔曲线可以使动画超出其原本的范围；曲线上的控制点的 y 值可以使任意的：不管是负值还是一个很大的值；</p>
<p><strong>阶跃函数</strong></p>
<p>时间函数 steps(number of steps[, start/end]) 允许你让动画分段进行，number of steps 表示需要拆分为多少段</p>
<p>start 表示在动画开始时，我们需要立即开始第一段的动画，另一个值 end 表示：改变不应该在最开始的时候发生，而是发生在每一段的最后时刻；</p>
<p>CSS 动画完成后，会触发 transitionend 事件，该事件对象有几个特定的属性：</p>
<ul>
<li>event.propertyName ：当前完成动画的属性，这在同时为多个属性加上动画时会很有用；</li>
<li>event.elapsedTime ：动画完成的时间（按秒计算），不包括 transition-delay；</li>
</ul>
<p>此外还可以通过 CSS 提供的 @keyframes 规则整合多个简单的动画；</p>
<ul>
<li><a href="http://cubic-bezier.com/">贝塞尔曲线在线制作工具</a></li>
</ul>
<h4 id="JavaScript-动画"><a href="#JavaScript-动画" class="headerlink" title="JavaScript 动画"></a>JavaScript 动画</h4><p>标准动画时序提供了 requestAnimationFrame 函数；当页面在后台时，根本没有重绘，因此回调将不会运行：动画将被暂停并且不会消耗资源；</p>
<ul>
<li>创建方式： let requestId = requestAnimationFrame(callback)；</li>
<li>取消回调：cancelAnimationFrame(requestId)；</li>
</ul>
<p>这是一个设置大多数动画的 helper 函数 animate：</p>
<ul>
<li>duration 动画运行的总毫秒数；</li>
<li>timing 计算动画进度的函数；获取从 0 到 1 的小数时间，返回动画进度，通常也是从 0 到 1；</li>
<li>draw 绘制动画的函数；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">&#123;timing, draw, duration&#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = performance.now();</span><br><span class="line"></span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// timeFraction 从 0 增加到 1</span></span><br><span class="line">    <span class="keyword">let</span> timeFraction = (time - start) / duration;</span><br><span class="line">    <span class="keyword">if</span> (timeFraction &gt; <span class="number">1</span>) timeFraction = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前动画状态</span></span><br><span class="line">    <span class="keyword">let</span> progress = timing(timeFraction);</span><br><span class="line"></span><br><span class="line">    draw(progress); <span class="comment">// 绘制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeFraction &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      requestAnimationFrame(animate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://zh.javascript.info/js-animation">JavaScript 现代教程-JS 动画</a></li>
</ul>
<h4 id="Custom-elements"><a href="#Custom-elements" class="headerlink" title="Custom elements"></a>Custom elements</h4><p>Custom elements 有两种：自主自定义标签和自定义内建元素；Custom element 在各浏览器中的兼容性已经非常好了，Edge 支持地相对较差，可以使用 <a href="https://github.com/webcomponents/webcomponentsjs">polyfill</a>；</p>
<p><strong>Autonomous custom elements</strong> </p>
<p>自主自定义标签 “全新的” 元素, 继承自 HTMLElement 抽象类；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// 元素在这里创建</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在元素被添加到文档之后，浏览器会调用这个方法</span></span><br><span class="line">    <span class="comment">//（如果一个元素被反复添加到文档／移除文档，那么这个方法会被多次调用）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">disconnectedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在元素从文档移除的时候，浏览器会调用这个方法</span></span><br><span class="line">    <span class="comment">// （如果一个元素被反复添加到文档／移除文档，那么这个方法会被多次调用）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> <span class="title">observedAttributes</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="comment">/* 属性数组，这些属性的变化会被监视 */</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">attributeChangedCallback</span>(<span class="params">name, oldValue, newValue</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 当上面数组中的属性发生变化的时候，这个方法会被调用</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">adoptedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在元素被移动到新的文档的时候，这个方法会被调用</span></span><br><span class="line">    <span class="comment">// （document.adoptNode 会用到, 非常少见）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 还可以添加更多的元素方法和属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让浏览器知道我们新定义的类是为 &lt;my-element&gt; 服务的</span></span><br><span class="line">customElements.define(<span class="string">&quot;my-element&quot;</span>, MyElement);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 为了确保 <code>custom element</code> 和内建 HTML 元素之间不会发生命名冲突，<code>Custom element</code> 名称必须包括一个短横线 <code>-</code>；</p>
</blockquote>
<p>如果浏览器在 customElements.define 之前的任何地方见到了 custom element 元素，并不会报错，但会把这个元素当作未知元素，就像任何非标准标签一样；:not(:defined) CSS 选择器可以对这样未定义的元素加上样式；</p>
<p>customElements.get(name) 返回指定 custom element name 的类；<br>customElements.whenDefined(name) 返回一个 promise，将会在这个具有给定 name 的 custom element 变为已定义状态的时候 resolve（不带值）；</p>
<p>在 HTML 解析器构建 DOM 的时候，会按照先后顺序处理元素，先处理父级元素再处理子元素；</p>
<p><strong>Customized built-in elements</strong></p>
<p>自定义内建元素继承内建的 HTML 元素，比如自定义 HTMLButtonElement 等；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 类继承自 HTMLButtonElement</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 这个按钮在被点击的时候说 &quot;hello&quot;</span></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">HelloButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">super</span>();</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> alert(<span class="string">&quot;Hello!&quot;</span>));</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 给 customElements.define 提供定义标签的第三个参数</span></span></span><br><span class="line"><span class="javascript">  customElements.define(<span class="string">&#x27;hello-button&#x27;</span>, HelloButton, &#123;<span class="attr">extends</span>: <span class="string">&#x27;button&#x27;</span>&#125;);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 插入一个普通的 &lt;button&gt; 标签，但添加 is=&quot;hello-button&quot; 到这个元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">&quot;hello-button&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">&quot;hello-button&quot;</span> <span class="attr">disabled</span>&gt;</span>Disabled<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="影子-DOM"><a href="#影子-DOM" class="headerlink" title="影子 DOM"></a>影子 DOM</h4><p>浏览器在内部使用 DOM/CSS 来绘制它们，这个 DOM 结构一般来说对我们是隐藏的，但可以在开发者工具里面看见它，在 #shadow-root 下看到的就是被称为「shadow DOM」的东西；</p>
<p>一个 DOM 元素可以有以下两类 DOM 子树：</p>
<ul>
<li>Light tree（光明树）一个常规 DOM 子树，由 HTML 子元素组成；</li>
<li>Shadow tree（影子树）一个隐藏的 DOM 子树，不在 HTML 中反映，无法被察觉；</li>
</ul>
<p>如果一个元素同时有以上两种子树，那么浏览器只渲染 shadow tree；影子树可以在自定义元素中被使用，其作用是隐藏组件内部结构和添加只在组件内有效的样式；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">customElements.define(<span class="string">&#x27;show-hello&#x27;</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> shadow = <span class="built_in">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;);</span></span><br><span class="line"><span class="handlebars"><span class="xml">    shadow.innerHTML = `<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">      Hello, $&#123;<span class="built_in">this</span>.getAttribute(<span class="string">&#x27;name&#x27;</span>)&#125;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span>`;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">show-hello</span> <span class="attr">name</span>=<span class="string">&quot;John&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">show-hello</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>调用 elem.attachShadow({mode: …}) 可以创建一个 shadow tree：</p>
<ul>
<li>mode 选项可以设定封装层级，他必须是以下两个值之一<ul>
<li>open：shadow root 可以通过 elem.shadowRoot 访问；</li>
<li>closed：elem.shadowRoot 永远是 null；</li>
</ul>
</li>
</ul>
<p>浏览器原生的 shadow tree，是封闭的，没有任何方法可以访问它们；</p>
<p>Shadow DOM 元素对于 light DOM 中的 querySelector 不可见；实际上，Shadow DOM 中的元素可能与 light DOM 中某些元素的 id 冲突，这些元素必须在 shadow tree 中独一无二；Shadow DOM 有自己的样式，外部样式规则在 shadow DOM 中不产生作用；</p>
<h4 id="模板元素"><a href="#模板元素" class="headerlink" title="模板元素"></a>模板元素</h4><p>内建的 <code>&lt;template&gt;</code> 元素用来存储 HTML 模板。浏览器将忽略它的内容，仅检查语法的有效性，但是我们可以在 JavaScript 中访问和使用它来创建其他元素；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;temp&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, world.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold; &#125;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&quot;Hello&quot;</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// Clone the template content to reuse it multiple times</span></span></span><br><span class="line"><span class="javascript">  elem.append(temp.content.cloneNode(<span class="literal">true</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.append(elem);</span></span><br><span class="line"><span class="javascript">  <span class="comment">// Now the script from &lt;template&gt; runs</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器认为 <code>&lt;template&gt;</code> 的内容“不在文档中”：样式不会被应用，脚本也不会被执行；当内容插入文档时，该内容将变为活动状态（应用样式，运行脚本等）；</p>
<p>模板的 content 属性可看作 DocumentFragment，将它插入时，会被插入的则是其子节点；</p>
<h4 id="Shadow-DOM-插槽，组成"><a href="#Shadow-DOM-插槽，组成" class="headerlink" title="Shadow DOM 插槽，组成"></a>Shadow DOM 插槽，组成</h4><p>为了渲染 shadow DOM 中的每一个 <code>&lt;slot name=&quot;...&quot;&gt;</code> 元素，浏览器在 light DOM 中寻找相同名字的 slot=”…”，这些元素在插槽内被渲染；最后得到一个扁平化（flattened）DOM；</p>
<p>扁平化 DOM 是通过插入插槽从 shadow DOM 派生出来的，浏览器渲染它并且用于样式继承、事件传播；但是 JavaScript 在扁平前仍按原样看到文档；slot=”…” 属性仅仅对 shadow host 的直接子代有效，对于嵌套元素它将被忽略；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">customElements.define(<span class="string">&#x27;user-card&#x27;</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;);</span><br><span class="line">    <span class="built_in">this</span>.shadowRoot.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div&gt;Name:</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;Birthday:</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;user-card&gt;</span><br><span class="line">  &lt;span slot=<span class="string">&quot;username&quot;</span>&gt;John Smith&lt;/span&gt;</span><br><span class="line">  &lt;span slot=<span class="string">&quot;birthday&quot;</span>&gt;<span class="number">01</span><span class="number">.01</span><span class="number">.2001</span>&lt;/span&gt;</span><br><span class="line">&lt;/user-card&gt;</span><br></pre></td></tr></table></figure>

<p>shadow DOM 中第一个没有名字的 <code>&lt;slot&gt;</code> 是一个默认插槽，它从 light DOM 中获取没有放置在其他位置的所有节点；</p>
<p>如果添加/删除了插槽元素，浏览器将监视插槽并更新渲染，触发 slotchange 事件；</p>
<h4 id="Shadow-DOM-样式"><a href="#Shadow-DOM-样式" class="headerlink" title="Shadow DOM 样式"></a>Shadow DOM 样式</h4><p>:host 选择器允许选择 shadow 宿主（包含 shadow 树的元素）；:host(selector) 还可以添加选择器；</p>
<p>shadow 宿主驻留在 light DOM 中，因此它受到文档 CSS 规则的影响；如果在局部的 :host 和文档中都给一个属性设置样式，那么文档样式优先；</p>
<p>使用 ::slotted(selector) 伪类可以给插槽添加样式，但 ::slotted 选择器不能用于任何插槽中更深层的内容，且只能在 CSS 中使用，不能在 querySelector 中使用；</p>
<p>自定义 CSS 属性存在于所有层次，包括 light DOM 和 shadow DOM；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 在外部文档中声明此属性 */</span></span></span><br><span class="line">  user-card &#123;</span><br><span class="line"><span class="css">    --user-card-field-<span class="attribute">color</span>: green;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;tmpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .field &#123;</span><br><span class="line"><span class="css">      <span class="comment">/* 如果 --user-card-field-color 没有被声明过，则取值为 black */</span></span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: <span class="built_in">var</span>(--user-card-field-color, black);</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span>Birthday: <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">customElements.define(<span class="string">&#x27;user-card&#x27;</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.shadowRoot.append(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;tmpl&#x27;</span>).content.cloneNode(<span class="literal">true</span>));</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user-card</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;username&quot;</span>&gt;</span>John Smith<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span>01.01.2001<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Shadow-DOM-和事件"><a href="#Shadow-DOM-和事件" class="headerlink" title="Shadow DOM 和事件"></a>Shadow DOM 和事件</h4><p>当事件在组件外部捕获时，shadow DOM 中发生的事件将会以 host 元素作为目标，这就是事件重定向；但如果事件发生在 slotted 元素上，实际存在于 light DOM 上，则不会发生重定向；</p>
<p>事件仅仅是在它们的 composed 标志设置为 true 的时候才能通过 shadow DOM 边界；这些事件仅能在同一 DOM 中的元素上捕获：mouseenter，mouseleave（也不冒泡），load，unload，abort，error，select，slotchange；</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>在 JavaScript 中，正则表达式通过内建的“RegExp”类的对象来实现，并与字符串集成；</p>
<p>正则表达式包含模式和可选的修饰符，使用 RegExp 对象或 // 字面量创建；new RegExp 允许从字符串中动态地构造模式；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;pattern&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line">regexp = <span class="regexp">/pattern/</span>; <span class="comment">// 没有修饰符</span></span><br><span class="line">regexp = <span class="regexp">/pattern/gmi</span>;</span><br></pre></td></tr></table></figure>

<p>字符串 str.search 方法，可以搜索一个正则表达式，并返回第一个索引；</p>
<p>在 JavaScript 中，有 6 个修饰符：</p>
<ul>
<li>i 使用此修饰符后，搜索时不区分大小写；</li>
<li>g 使用此修饰符后，搜索时会查找所有的匹配项，而不只是第一个；</li>
<li>m 多行模式；</li>
<li>s 启用 dotall 模式，允许点 . 匹配换行符 \n；</li>
<li>u 开启完整的 unicode 支持。该修饰符能够修正对于代理对的处理；</li>
<li>y 粘滞模式；</li>
</ul>
<p><strong>字符类</strong></p>
<p>字符类（Character classes） 是一个特殊的符号，匹配特定集中的任何符号；</p>
<ul>
<li>\d 表示数字 digit：从 0 到 9 的字符；</li>
<li>\s 空格符号 space：包括空格，制表符 \t，换行符 \n 和其他少数稀有字符，例如 \v，\f 和 \r；</li>
<li>\w 单字字符 word：拉丁字母或数字或下划线 _；</li>
<li>\D 非数字：除 \d 以外的任何字符；</li>
<li>\S 非空格符号：除 \s 以外的任何字符；</li>
<li>\W 非单字字符：除 \w 以外的任何字符；</li>
<li>. 点是一种特殊字符类，它与 “除换行符之外的任何字符” 匹配，带 s 标志时，匹配包括换行符在内的任何字符；</li>
<li>\p{Letter} 或 \p{L} 表示任何语言中的一个字母，需要带 u 标志；</li>
</ul>
<p><strong>Unicode</strong></p>
<p>Unicode 全称 Unicode Translation Format，又叫做统一码、万国码、单一码，Unicode 的实现方式（也就是编码方式）有很多种，常见的是 UTF-8、UTF-16、UTF-32 和 USC-2；UTF-8 是使用最广泛的 Unicode 编码方式，它是一种可变长的编码方式，可以是 1—4 个字节不等，它可以完全兼容 ASCII 码的 128 个字符；</p>
<p>默认情况下，正则表达式同样把一个 4 个字节的“长字符”当成一对 2 个字节长的字符；</p>
<p>主要的字符类别和它们对应的子类别：</p>
<ul>
<li>字母（Letter） L:<ul>
<li>小写（lowercase） Ll</li>
<li>修饰（modifier） Lm</li>
<li>首字母大写（titlecase） Lt</li>
<li>大写（uppercase） Lu</li>
<li>其它（other） Lo</li>
</ul>
</li>
<li>数字（Number） N:<ul>
<li>十进制数字（decimal digit） Nd</li>
<li>十六进制 </li>
<li>字母数字（letter number） Nl</li>
<li>其它（other） No</li>
</ul>
</li>
<li>标点符号（Punctuation） P:<ul>
<li>链接符（connector） Pc</li>
<li>横杠（dash） Pd</li>
<li>起始引用号（initial quote） Pi</li>
<li>结束引用号（final quote） Pf</li>
<li>开（open） Ps</li>
<li>闭（close） Pe</li>
<li>其它（other） Po</li>
</ul>
</li>
<li>标记（Mark） M (accents etc):<ul>
<li>间隔合并（spacing combining） Mc</li>
<li>封闭（enclosing） Me</li>
<li>非间隔（non-spacing） Mn</li>
</ul>
</li>
<li>符号（Symbol） S:<ul>
<li>货币（currency） Currency_Symbol/Sc</li>
<li>修饰（modifier） Sk</li>
<li>数学（math） Sm</li>
<li>其它（other） So</li>
</ul>
</li>
<li>分隔符（Separator） Z:<ul>
<li>行（line） Zl</li>
<li>段落（paragraph） Zp</li>
<li>空格（space） Zs</li>
</ul>
</li>
<li>其它（Other） C:<ul>
<li>控制符（control） Cc</li>
<li>格式（format） Cf</li>
<li>未分配（not assigned） Cn</li>
<li>私有（private use） Co</li>
<li>代理伪字符（surrogate） Cs</li>
</ul>
</li>
<li>书写系统：Script/sc<ul>
<li>中文 Han</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配标点</span></span><br><span class="line"><span class="string">&quot;。&quot;</span>.search(<span class="regexp">/\p&#123;P&#125;/u</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="string">&quot;number: xAF&quot;</span>.search(<span class="regexp">/x\p&#123;Hex_Digit&#125;\p&#123;Hex_Digit&#125;/u</span>); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;你好&quot;</span>.search(<span class="regexp">/\p&#123;sc=Han&#125;/u</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: Edge 和 Firefox 尚未实现 Unicode 属性 <code>p&#123;…&#125;</code>，可以使用库 <a href="http://xregexp.com/">XRegExp</a>；</p>
</blockquote>
<p><strong>锚点</strong></p>
<p>插入符号 ^ 匹配文本开头，而美元符号 $ － 则匹配文本末尾，统称为“锚点”；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> goodInput = <span class="string">&quot;12:34&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> badInput = <span class="string">&quot;12:345&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/^\d\d:\d\d$/</span>;</span><br><span class="line">alert( regexp.test(goodInput) ); <span class="comment">// true</span></span><br><span class="line">alert( regexp.test(badInput) ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>对于空字符串 “”，正则表达式引擎将会首先匹配模式 ^（输入开始），匹配成功之后，会紧跟着检查模式 $，也匹配成功，所以空字符串是匹配 ^$ 的；</p>
<p><strong>多行模式</strong></p>
<p>通过 flag /…/m 可以开启多行模式；默认情况下，锚符 ^ 仅仅匹配文本的开头，在多行模式下，它匹配行的开头；锚符 $ 也可在多行模式下匹配行的结尾；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`1st place: Winnie</span></span><br><span class="line"><span class="string">2nd place: Piglet</span></span><br><span class="line"><span class="string">33rd place: Eeyore`</span>;</span><br><span class="line"></span><br><span class="line">alert( str.match(<span class="regexp">/^\d+/gm</span>) ); <span class="comment">// 1, 2, 33</span></span><br><span class="line">alert( str.match(<span class="regexp">/\w+\n/gim</span>) ); <span class="comment">// Winnie\n,Piglet\n</span></span><br></pre></td></tr></table></figure>

<p><strong>词边界</strong></p>
<p>当正则表达式引擎遇到 \b 时，它会检查字符串中的位置是否是词边界：</p>
<ul>
<li>在字符串开头，如果第一个字符是单词字符 \w；</li>
<li>在字符串中的两个字符之间，其中一个是单词字符 \w，另一个不是；</li>
<li>在字符串末尾，如果最后一个字符是单词字符 \w；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello, Java!&quot;</span>.match(<span class="regexp">/\b\w+\b/g</span>); <span class="comment">// [&#x27;Hello&#x27;, &#x27;Java&#x27;]</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">&quot;1 23 456 78&quot;</span>.match(<span class="regexp">/\b\d\d\b/g</span>) ); <span class="comment">// 23,78</span></span><br><span class="line">alert( <span class="string">&quot;12,34,56&quot;</span>.match(<span class="regexp">/\b\d\d\b/g</span>) ); <span class="comment">// 12,34,56</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: <code>\b</code> 既可以用于单词，也可以用于数字，词边界 <code>\b</code> 不适用于非拉丁字母；</p>
</blockquote>
<p><strong>转义字符</strong></p>
<p><code>[ \ ^ $ . | ? * + ( )</code>，这些字符在正则表达式中有特殊的含义；如果要把特殊字符作为常规字符来使用，只需要在它前面加个反斜杠，这个过程叫转义；</p>
<p>斜杠符号 ‘/‘ 并不是一个特殊符号，但是它被用于在 Javascript 中开启和关闭正则匹配：/…pattern…/，所以我们也应该转义它；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">&quot;Chapter 5.1&quot;</span>.match(<span class="regexp">/\d\.\d/</span>) ); <span class="comment">// 5.1</span></span><br><span class="line">alert( <span class="string">&quot;1\\2&quot;</span>.match(<span class="regexp">/\\/</span>) ); <span class="comment">// &#x27;\&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 斜杠 /</span></span><br><span class="line">alert( <span class="string">&quot;/&quot;</span>.match(<span class="regexp">/\//</span>) ); <span class="comment">// &#x27;/&#x27;</span></span><br><span class="line">alert( <span class="string">&quot;/&quot;</span>.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;/&quot;</span>)) ); <span class="comment">// &#x27;/&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在字符串中的反斜杠表示转义或者类似 \n 这种只能在字符串中使用的特殊字符；其它有些并没有特殊的含义，就像 \d 或者 \z，碰到这种情况的话会把反斜杠移除；所以传递一个字符串（参数）给 new RegExp 时，需要双反斜杠 \，因为字符串引号会消费其中的一个；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;\d\.\d&quot;</span>); <span class="comment">// d.d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regStr = <span class="string">&quot;\\d\\.\\d&quot;</span>;</span><br><span class="line">alert(regStr); <span class="comment">// \d\.\d (correct now)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr);</span><br><span class="line"></span><br><span class="line">alert( <span class="string">&quot;Chapter 5.1&quot;</span>.match(regexp) ); <span class="comment">// 5.1</span></span><br></pre></td></tr></table></figure>

<p><strong>集合和范围</strong></p>
<p>在方括号 […] 中的几个字符或者字符类意味着“搜索给定的字符中的任意一个”；集合可以在正则表达式中和其它常规字符一起使用，方括号也可以包含字符范围；[a-z] 会匹配从 a 到 z 范围内的字母；</p>
<p>字符类是某些字符集的简写：</p>
<ul>
<li>\d 和 [0-9] 相同；</li>
<li>\w 和 [a-zA-Z0-9_] 相同；</li>
<li>\s 和 [\t\n\v\f\r ] 外加少量罕见的 unicode 空格字符相同；</li>
</ul>
<p>除了普通的范围匹配，还有类似 [^…] 的“排除”范围匹配；通过在匹配查询的开头添加插入符号 ^ 来表示，它会匹配所有除了给定的字符之外的任意字符；且在方括号中的特殊字符不需要转义；</p>
<p>破折号 ‘-‘ 在方括号中有特殊含义，但这个含义只有当它位于其它字符之间而不是开头或结尾时才会发生作用，所以我们并不需要转义它；需要匹配 <code>^</code> 时，建议转义；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并不需要转义</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/[-().^+]/g</span>;</span><br><span class="line">alert( <span class="string">&quot;1 + 2 - 3&quot;</span>.match(reg) ); <span class="comment">// 匹配 +，-</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">&#x27;𝒳&#x27;</span>.match(<span class="regexp">/[𝒳𝒴]/u</span>) ); <span class="comment">// 𝒳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d\d[-:]\d\d/g</span>;</span><br><span class="line">alert( <span class="string">&quot;Breakfast at 09:00. Dinner at 21-30&quot;</span>.match(reg) ); <span class="comment">// 09:00, 21-30</span></span><br></pre></td></tr></table></figure>

<p>如果集合中有代理对（surrogate pairs），则需要标志 u 以使其正常工作；</p>
<p><strong>量词</strong></p>
<p>最明显的量词便是一对引号间的数字：{n, m}；在一个字符（或一个字符类等等）后跟着一个量词，用来指出我们具体需要的数量；</p>
<ul>
<li>{n} 表示确切的位数；</li>
<li>{n, m} 表示 n 到 m  之间的位数；</li>
<li>{n,} 省略上限，表示查找位数大于或等于 n 的位数；</li>
</ul>
<p>大多数常用的量词都可以有缩写：</p>
<ul>
<li><code>+</code> 代表“一个或多个”，相当于 {1,}；</li>
<li>? 代表“零个或一个”，相当于 {0,1}；使得符号变得可选；</li>
<li><ul>
<li>代表着“零个或多个”，相当于 {0,}，表示这个字符可以多次出现或不出现；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Should I write color or colour?&quot;</span>;</span><br><span class="line">alert( str.match(<span class="regexp">/colou?r/g</span>) ); <span class="comment">// color, colour</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">&quot;100 10 1&quot;</span>.match(<span class="regexp">/\d0+/g</span>) ); <span class="comment">// 100, 10</span></span><br><span class="line">alert( <span class="string">&quot;100 10 1&quot;</span>.match(<span class="regexp">/\d0*/g</span>) ); <span class="comment">// 100, 10, 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则表达式“浮点数”（带浮点的数字）：\d+\.\d+</span></span><br><span class="line"><span class="comment">// 正则表达式“打开没有属性的 HTML 标记”，比如 &lt;span&gt; 或 &lt;p&gt;：/&lt;[a-z]+&gt;/i</span></span><br><span class="line"><span class="comment">// 正则表达式“打开没有属性的HTML标记”（改进版）：/&lt;[a-z][a-z0-9]*&gt;/i</span></span><br><span class="line"><span class="comment">// 正则表达式“打开没有属性的HTML标记”：/&lt;\/?[a-z][a-z0-9]*&gt;/i</span></span><br></pre></td></tr></table></figure>

<p><strong>贪婪量词和惰性量词</strong></p>
<p>在贪婪模式下（默认情况下），量词都会尽可能地重复多次；正则表达式引擎尝试用 .+ 去获取尽可能多的字符，然后再一步步地筛选它们</p>
<p>通过在量词之后添加一个问号 ‘?’ 来启用懒惰模式，所以匹配模式变为 *? 或 +?，甚至将 ‘?’ 变为 ??；懒惰模式只能够通过带 ? 的量词启用，其它的量词依旧保持贪婪模式；</p>
<p>有时需要运用集合和反向集合来解决懒惰模式下的一些问题；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;...&lt;a href=&quot;link1&quot; class=&quot;wrong&quot;&gt;... &lt;p style=&quot;&quot; class=&quot;doc&quot;&gt;...&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;...&lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;... &lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;...&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;a href=&quot;[^&quot;]*&quot; class=&quot;doc&quot;&gt;/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Works!</span></span><br><span class="line">alert( str1.match(reg) ); <span class="comment">// 没有匹配项，是正确的</span></span><br><span class="line">alert( str2.match(reg) ); <span class="comment">// &lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;, &lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配注释</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;!--[\s\S]*?--&gt;/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`... &lt;!-- My -- comment</span></span><br><span class="line"><span class="string"> test --&gt; ..  &lt;!----&gt; ..</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">alert( str.match(reg) ); <span class="comment">// &#x27;&lt;!-- My -- comment \n test --&gt;&#x27;, &#x27;&lt;!----&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配标签 </span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;[^&lt;&gt;]+&gt;/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&lt;&gt; &lt;a href=&quot;/&quot;&gt; &lt;input type=&quot;radio&quot; checked&gt; &lt;b&gt;&#x27;</span>;</span><br><span class="line">alert( str.match(reg) ); <span class="comment">// &#x27;&lt;a href=&quot;/&quot;&gt;&#x27;, &#x27;&lt;input type=&quot;radio&quot; checked&gt;&#x27;, &#x27;&lt;b&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://zh.javascript.info/regexp-greedy-and-lazy">JavaScript 现代教程-贪婪量词和惰性量词</a></li>
</ul>
<p><strong>捕获组</strong></p>
<p>模式的一部分可以用括号括起来 (…)，这称为“捕获组（capturing group）”；这允许将匹配的一部分作为结果数组中的单独项，如果我们将量词放在括号后，则它将括号视为一个整体；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配域名</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/([\w-]+\.)+\w+/g</span>;</span><br><span class="line">alert( <span class="string">&quot;site.com my.site.com&quot;</span>.match(regexp) ); <span class="comment">// site.com,my.site.com</span></span><br></pre></td></tr></table></figure>

<p>方法 str.match(regexp)，如果 regexp 没有 g 标志，将查找第一个匹配并将它作为一个数组返回；</p>
<ul>
<li>在索引 0 处：完全匹配；</li>
<li>在索引 1 处：第一个括号的内容；</li>
<li>在索引 2 处：第二个括号的内容；</li>
<li>…</li>
</ul>
<p>括号可以嵌套；在这种情况下，编号也从左到右，零索引始终保持完全匹配；即使组是可选的并且在匹配项中不存在，也存在相应的 result 数组项，并且等于 undefined；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&lt;h1&gt;Hello, world!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> tag = str.match(<span class="regexp">/&lt;(.*?)&gt;/</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tag); <span class="comment">//  [&#x27;&lt;h1&gt;&#x27;, &#x27;h1&#x27;, index: 0, input: &#x27;&lt;h1&gt;Hello, world!&lt;/h1&gt;&#x27;, groups: undefined]</span></span><br><span class="line">alert( tag[<span class="number">0</span>] ); <span class="comment">// &lt;h1&gt;</span></span><br><span class="line">alert( tag[<span class="number">1</span>] ); <span class="comment">// h1</span></span><br></pre></td></tr></table></figure>

<p>当搜索所有匹配项（标志 g）时，match 方法不会返回组的内容，结果是一个匹配数组，但没有每个匹配项的详细信息；使用方法 str.matchAll(regexp) 进行搜索并获取捕获组的内容；</p>
<p>matchAll 和 match 有三个区别：</p>
<ul>
<li>它返回的不是数组，而是一个可迭代的对象；</li>
<li>当标志 g 存在时，它将每个匹配组作为一个数组返回；</li>
<li>如果没有匹配项，则不返回 null，而是返回一个空的可迭代对象；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> results = <span class="string">&#x27;&lt;h1&gt; &lt;h2&gt;&#x27;</span>.matchAll(<span class="regexp">/&lt;(.*?)&gt;/gi</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// results - is not an array, but an iterable object</span></span><br><span class="line">alert(results); <span class="comment">// [object RegExp String Iterator]</span></span><br><span class="line"></span><br><span class="line">alert(results[<span class="number">0</span>]); <span class="comment">// undefined (*)</span></span><br><span class="line"></span><br><span class="line">results = <span class="built_in">Array</span>.from(results); <span class="comment">// let&#x27;s turn it into array</span></span><br><span class="line"></span><br><span class="line">alert(results[<span class="number">0</span>]); <span class="comment">// &lt;h1&gt;,h1 (1st tag)</span></span><br><span class="line">alert(results[<span class="number">1</span>]); <span class="comment">// &lt;h2&gt;,h2 (2nd tag)</span></span><br></pre></td></tr></table></figure>

<p>命名组是通过在开始括号之后立即放置 <code>?&lt;name&gt;</code> 来完成的；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dateRegexp = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;2019-10-30 2020-01-01&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> results = str.matchAll(dateRegexp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> result <span class="keyword">of</span> results) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;year, month, day&#125; = result.groups;</span><br><span class="line"></span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;day&#125;</span>.<span class="subst">$&#123;month&#125;</span>.<span class="subst">$&#123;year&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// 第一个 alert：30.10.2019</span></span><br><span class="line">  <span class="comment">// 第二个：01.01.2020</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 str.replace(regexp, replacement) 用 replacement 替换 str 中匹配 regexp 的所有捕获组；使用 $n 或者名称 <code>$&lt;name&gt;</code>；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;John Bull&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(\w+) (\w+)/</span>;</span><br><span class="line">alert( str.replace(regexp, <span class="string">&#x27;$2, $1&#x27;</span>) ); <span class="comment">// Bull, John</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;2019-10-30, 2020-01-01&quot;</span>;</span><br><span class="line">alert( str.replace(regexp, <span class="string">&#x27;$&lt;day&gt;.$&lt;month&gt;.$&lt;year&gt;&#x27;</span>) );</span><br><span class="line"><span class="comment">// 30.10.2019, 01.01.2020</span></span><br></pre></td></tr></table></figure>

<p>可以通过在开头添加 ?: 来排除组；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Gogogo John!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?: 从捕获组中排除 &#x27;go&#x27;</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(?:go)+ (\w+)/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = str.match(regexp);</span><br><span class="line"></span><br><span class="line">alert( result[<span class="number">0</span>] ); <span class="comment">// Gogogo John（完全匹配）</span></span><br><span class="line">alert( result[<span class="number">1</span>] ); <span class="comment">// John</span></span><br><span class="line">alert( result.length ); <span class="comment">// 2（数组中没有更多项）</span></span><br></pre></td></tr></table></figure>

<p><strong>模式中的反向引用</strong></p>
<p>我们不仅可以在结果或替换字符串中使用捕获组 (…) 的内容，还可以在模式本身中使用它们；</p>
<p>可以使用 \N 在模式中引用一个组，其中 N 是组号；\1 在模式中进一步的含义是“查找与第一（捕获）分组相同的文本”；</p>
<p>如果正则表达式中有很多括号对（注：捕获组），给它们起个名字方便引用；要引用命名组，我们可以使用：<code>\k&lt;name&gt;</code>；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`He said: &quot;She&#x27;s the one!&quot;.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(?&lt;quote&gt;[&#x27;&quot;])(.*?)\k&lt;quote&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">alert( str.match(regexp) ); <span class="comment">// &quot;She&#x27;s the one!&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>选择（OR）|</strong></p>
<p>通常用圆括号把模式中的选择部分括起来，像这样 before(XXX|YYY)after；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/([01]\d|2[0-3]):[0-5]\d/g</span>;</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&quot;00:00 10:10 23:59 25:99 1:2&quot;</span>.match(reg)); <span class="comment">// 00:00,10:10,23:59</span></span><br></pre></td></tr></table></figure>

<p><strong>环视断言</strong></p>
<p>一般来说，环视断言括号中（前瞻和后瞻的通用名称）的内容不会成为匹配到的一部分结果，如果想要捕捉整个环视表达式或其中的一部分，只需要将其包裹在另加的括号中；</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">类型</th>
<th align="left">匹配</th>
</tr>
</thead>
<tbody><tr>
<td align="left">x(?=y)</td>
<td align="left">前瞻肯定断言</td>
<td align="left">x ，仅当后面跟着 y</td>
</tr>
<tr>
<td align="left">x(?!y)</td>
<td align="left">前瞻否定断言</td>
<td align="left">x ，仅当后面不跟 y</td>
</tr>
<tr>
<td align="left">(?&lt;=y)x</td>
<td align="left">后瞻肯定断言</td>
<td align="left">x ，仅当跟在 y 后面</td>
</tr>
<tr>
<td align="left">(?&lt;!y)x</td>
<td align="left">后瞻否定断言</td>
<td align="left">x ，仅当不跟在 y 后面</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1 turkey costs 30€&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+(?=(€|kr))/</span>; <span class="comment">// €|kr 两边有额外的括号</span></span><br><span class="line">alert( str.match(reg) ); <span class="comment">// 30, €</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1 turkey costs $30&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?&lt;=(\$|£))\d+/</span>;</span><br><span class="line">alert( str.match(reg) ); <span class="comment">// 30, $</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配非负数</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(?&lt;![-\d])\d+/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;0 12 -5 123 -18&quot;</span>;</span><br><span class="line">alert( str.match(regexp) ); <span class="comment">// 0, 12, 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 body 后插入，在替换字符串中，$&amp; 表示匹配本身</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;...&lt;body style=&quot;...&quot;&gt;...&#x27;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/(?&lt;=&lt;body.*?&gt;)/</span>, <span class="string">`&lt;h1&gt;Hello&lt;/h1&gt;`</span>);</span><br><span class="line">str = str.replace(<span class="regexp">/&lt;body.*?&gt;/</span>, <span class="string">&#x27;$&amp;&lt;h1&gt;Hello&lt;/h1&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>灾难性回溯</strong></p>
<p>解决方式：</p>
<ul>
<li>第一种重写正则表达式，尽可能减少其中排列组合的数量；</li>
<li>另一种使用前瞻断言禁止量词的回溯；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">&quot;JavaScript&quot;</span>.match(<span class="regexp">/\w+Script/</span>)); <span class="comment">// JavaScript</span></span><br><span class="line">alert( <span class="string">&quot;JavaScript&quot;</span>.match(<span class="regexp">/(?=(\w+))\1Script/</span>)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 括号被命名为 ?&lt;word&gt;，使用 \k&lt;word&gt; 来引用</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/^((?=(?&lt;word&gt;\w+))\k&lt;word&gt;\s?)*$/</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;An input string that takes a long time or even makes this regex to hang!&quot;</span>;</span><br><span class="line"></span><br><span class="line">alert( regexp.test(str) ); <span class="comment">// false</span></span><br><span class="line">alert( regexp.test(<span class="string">&quot;A correct string&quot;</span>) ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>粘性标志 “y”</strong></p>
<p>y 标志允许在源字符串中的指定位置执行搜索；</p>
<p>方法 regexp.exec(str)：</p>
<ul>
<li>如果 regexp 没有标志 g 或 y，那么这个方法就可以寻找字符串 str 中的第一个匹配，就像 str.match(regexp) 一样；</li>
<li>如果有标志 g，那么它就会在字符串 str 中执行搜索，从存储在 regexp.lastIndex 属性中的位置开始，如果发现匹配，则将 regexp.lastIndex 设置为匹配后的索引；</li>
<li>如果正则表达式带有标记 y，则搜索将精确地在 regexp.lastIndex 位置执行，不会再继续了；</li>
</ul>
<p><strong>正则表达式（RegExp）和字符串（String）的方法</strong></p>
<ul>
<li><p>str.match(regexp) 方法在字符串 str 中找到匹配 regexp 的字符；</p>
<ul>
<li>如果 regexp 不带有 g 标记，则以数组的形式返回第一个匹配项，其中包含分组和属性 index（匹配项的位置）、input（输入字符串，等于 str）；</li>
<li>如果 regexp 带有 g 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息；</li>
<li>如果没有匹配项，则无论是否带有标记 g ，都将返回 null；</li>
</ul>
</li>
<li><p>str.matchAll(regexp) 方法 str.matchAll(regexp) 是 str.match “新改进的”变体；</p>
<ul>
<li>它返回包含匹配项的可迭代对象，而不是数组。可以用 Array.from 从中得到一个常规数组；</li>
<li>每个匹配项均以包含分组的数组形式返回（返回格式与不带 g 标记的 str.match 相同）；</li>
<li>如果没有结果，则返回的不是 null，而是一个空的可迭代对象；</li>
</ul>
</li>
<li><p>str.split(regexp|substr, limit) 可以使用正则表达式（或子字符串）作为分隔符来分割字符串；</p>
</li>
<li><p>str.search(regexp) 方法返回第一个匹配项的位置，如果未找到，则返回 -1；</p>
</li>
<li><p>str.replace(str|regexp, str|func) 用于搜索和替换的通用方法；</p>
<ul>
<li>当第一个参数是字符串时，它仅替换第一个匹配项；</li>
<li>第二个参数是一个替代字符串，可以在其中使用特殊字符：<ul>
<li>$&amp;    插入整个匹配项；</li>
<li>$`    在匹配项之前插入字符串的一部分；</li>
<li>$’    在匹配项之后插入字符串的一部分；</li>
<li>$n    插入第 n 个分组的内容；</li>
<li><code>$&lt;name&gt;</code>    插入带有给定 name 的括号内的内容；</li>
<li><code>$$</code>    插入字符 $；</li>
</ul>
</li>
<li>第二个参数可以是一个函数：</li>
<li>func(match, p1, p2, …, pn, offset, input, groups) 带参数调用：<ul>
<li>match 匹配项；</li>
<li>p1, p2, …, pn 分组的内容（如有）；</li>
<li>offset 匹配项的位置；</li>
<li>input 源字符串；</li>
<li>groups 所指定分组的对象；</li>
</ul>
</li>
<li>如果正则表达式中没有括号，则只有 3 个参数：func(str, offset, input)</li>
</ul>
</li>
<li><p>regexp.exec(str) 方法返回字符串 str 中的 regexp 匹配项；</p>
</li>
<li><p>regexp.test(str) 方法查找匹配项，然后返回 true/false 表示是否存在；</p>
<ul>
<li>如果正则表达式带有标记 g，则 regexp.test 从 regexp.lastIndex 属性中查找，并更新此属性，就像 regexp.exec 一样；</li>
<li>如果我们在不同的源字符串上应用相同的全局表达式，可能会出现错误的结果，因为 regexp.test 的调用会增加 regexp.lastIndex 属性值，因此在另一个字符串中的搜索可能是从非 0 位置开始的</li>
</ul>
</li>
<li><p><a href="https://zh.javascript.info/regexp-methods">JavaScript 现代教程-正则表达式（RegExp）和字符串（String）的方法</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>学习笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
